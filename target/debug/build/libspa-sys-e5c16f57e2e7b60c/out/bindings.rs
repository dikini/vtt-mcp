/* automatically generated by rust-bindgen 0.72.1 */

pub const SPA_NSEC_PER_SEC: u32 = 1000000000;
pub const SPA_NSEC_PER_MSEC: u32 = 1000000;
pub const SPA_NSEC_PER_USEC: u32 = 1000;
pub const SPA_USEC_PER_SEC: u32 = 1000000;
pub const SPA_USEC_PER_MSEC: u32 = 1000;
pub const SPA_MSEC_PER_SEC: u32 = 1000;
pub const SPA_TYPE_INFO_BASE: &[u8; 5] = b"Spa:\0";
pub const SPA_TYPE_INFO_Flags: &[u8; 10] = b"Spa:Flags\0";
pub const SPA_TYPE_INFO_FLAGS_BASE: &[u8; 11] = b"Spa:Flags:\0";
pub const SPA_TYPE_INFO_Enum: &[u8; 9] = b"Spa:Enum\0";
pub const SPA_TYPE_INFO_ENUM_BASE: &[u8; 10] = b"Spa:Enum:\0";
pub const SPA_TYPE_INFO_Pod: &[u8; 8] = b"Spa:Pod\0";
pub const SPA_TYPE_INFO_POD_BASE: &[u8; 9] = b"Spa:Pod:\0";
pub const SPA_TYPE_INFO_Struct: &[u8; 15] = b"Spa:Pod:Struct\0";
pub const SPA_TYPE_INFO_STRUCT_BASE: &[u8; 16] = b"Spa:Pod:Struct:\0";
pub const SPA_TYPE_INFO_Object: &[u8; 15] = b"Spa:Pod:Object\0";
pub const SPA_TYPE_INFO_OBJECT_BASE: &[u8; 16] = b"Spa:Pod:Object:\0";
pub const SPA_TYPE_INFO_Pointer: &[u8; 12] = b"Spa:Pointer\0";
pub const SPA_TYPE_INFO_POINTER_BASE: &[u8; 13] = b"Spa:Pointer:\0";
pub const SPA_TYPE_INFO_Interface: &[u8; 22] = b"Spa:Pointer:Interface\0";
pub const SPA_TYPE_INFO_INTERFACE_BASE: &[u8; 23] = b"Spa:Pointer:Interface:\0";
pub const SPA_TYPE_INFO_Event: &[u8; 21] = b"Spa:Pod:Object:Event\0";
pub const SPA_TYPE_INFO_EVENT_BASE: &[u8; 22] = b"Spa:Pod:Object:Event:\0";
pub const SPA_TYPE_INFO_Command: &[u8; 23] = b"Spa:Pod:Object:Command\0";
pub const SPA_TYPE_INFO_COMMAND_BASE: &[u8; 24] = b"Spa:Pod:Object:Command:\0";
pub const SPA_POD_PROP_FLAG_READONLY: u32 = 1;
pub const SPA_POD_PROP_FLAG_HARDWARE: u32 = 2;
pub const SPA_POD_PROP_FLAG_HINT_DICT: u32 = 4;
pub const SPA_POD_PROP_FLAG_MANDATORY: u32 = 8;
pub const SPA_POD_PROP_FLAG_DONT_FIXATE: u32 = 16;
pub const SPA_META_HEADER_FLAG_DISCONT: u32 = 1;
pub const SPA_META_HEADER_FLAG_CORRUPTED: u32 = 2;
pub const SPA_META_HEADER_FLAG_MARKER: u32 = 4;
pub const SPA_META_HEADER_FLAG_HEADER: u32 = 8;
pub const SPA_META_HEADER_FLAG_GAP: u32 = 16;
pub const SPA_META_HEADER_FLAG_DELTA_UNIT: u32 = 32;
pub const SPA_CHUNK_FLAG_NONE: u32 = 0;
pub const SPA_CHUNK_FLAG_CORRUPTED: u32 = 1;
pub const SPA_CHUNK_FLAG_EMPTY: u32 = 2;
pub const SPA_DATA_FLAG_NONE: u32 = 0;
pub const SPA_DATA_FLAG_READABLE: u32 = 1;
pub const SPA_DATA_FLAG_WRITABLE: u32 = 2;
pub const SPA_DATA_FLAG_DYNAMIC: u32 = 4;
pub const SPA_DATA_FLAG_READWRITE: u32 = 3;
pub const SPA_DATA_FLAG_MAPPABLE: u32 = 8;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_META: u32 = 1;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_CHUNK: u32 = 2;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_DATA: u32 = 4;
pub const SPA_BUFFER_ALLOC_FLAG_INLINE_ALL: u32 = 7;
pub const SPA_BUFFER_ALLOC_FLAG_NO_DATA: u32 = 8;
pub const SPA_TYPE_INFO_Buffer: &[u8; 19] = b"Spa:Pointer:Buffer\0";
pub const SPA_TYPE_INFO_BUFFER_BASE: &[u8; 20] = b"Spa:Pointer:Buffer:\0";
pub const SPA_TYPE_INFO_Data: &[u8; 14] = b"Spa:Enum:Data\0";
pub const SPA_TYPE_INFO_DATA_BASE: &[u8; 15] = b"Spa:Enum:Data:\0";
pub const SPA_TYPE_INFO_DATA_Fd: &[u8; 17] = b"Spa:Enum:Data:Fd\0";
pub const SPA_TYPE_INFO_DATA_FD_BASE: &[u8; 18] = b"Spa:Enum:Data:Fd:\0";
pub const SPA_TYPE_INFO_Meta: &[u8; 17] = b"Spa:Pointer:Meta\0";
pub const SPA_TYPE_INFO_META_BASE: &[u8; 18] = b"Spa:Pointer:Meta:\0";
pub const SPA_TYPE_INFO_META_Array: &[u8; 23] = b"Spa:Pointer:Meta:Array\0";
pub const SPA_TYPE_INFO_META_ARRAY_BASE: &[u8; 24] = b"Spa:Pointer:Meta:Array:\0";
pub const SPA_TYPE_INFO_META_Region: &[u8; 24] = b"Spa:Pointer:Meta:Region\0";
pub const SPA_TYPE_INFO_META_REGION_BASE: &[u8; 25] = b"Spa:Pointer:Meta:Region:\0";
pub const SPA_TYPE_INFO_META_ARRAY_Region: &[u8; 30] = b"Spa:Pointer:Meta:Array:Region\0";
pub const SPA_TYPE_INFO_META_ARRAY_REGION_BASE: &[u8; 31] = b"Spa:Pointer:Meta:Array:Region:\0";
pub const SPA_TYPE_INFO_META_Transformation: &[u8; 29] = b"Spa:Enum:Meta:Transformation\0";
pub const SPA_TYPE_INFO_META_TRANSFORMATION_BASE: &[u8; 30] = b"Spa:Enum:Meta:Transformation:\0";
pub const SPA_TYPE_INFO_Control: &[u8; 17] = b"Spa:Enum:Control\0";
pub const SPA_TYPE_INFO_CONTROL_BASE: &[u8; 18] = b"Spa:Enum:Control:\0";
pub const SPA_TYPE_INFO_Direction: &[u8; 19] = b"Spa:Enum:Direction\0";
pub const SPA_TYPE_INFO_DIRECTION_BASE: &[u8; 20] = b"Spa:Enum:Direction:\0";
pub const SPA_TYPE_INFO_Choice: &[u8; 16] = b"Spa:Enum:Choice\0";
pub const SPA_TYPE_INFO_CHOICE_BASE: &[u8; 17] = b"Spa:Enum:Choice:\0";
pub const SPA_TYPE_INFO_DeviceEvent: &[u8; 28] = b"Spa:Pod:Object:Event:Device\0";
pub const SPA_TYPE_INFO_DEVICE_EVENT_BASE: &[u8; 29] = b"Spa:Pod:Object:Event:Device:\0";
pub const SPA_TYPE_INFO_DeviceEventId: &[u8; 23] = b"Spa:Enum:DeviceEventId\0";
pub const SPA_TYPE_INFO_DEVICE_EVENT_ID_BASE: &[u8; 24] = b"Spa:Enum:DeviceEventId:\0";
pub const SPA_STATUS_OK: u32 = 0;
pub const SPA_STATUS_NEED_DATA: u32 = 1;
pub const SPA_STATUS_HAVE_DATA: u32 = 2;
pub const SPA_STATUS_STOPPED: u32 = 4;
pub const SPA_STATUS_DRAINED: u32 = 8;
pub const SPA_IO_CLOCK_FLAG_FREEWHEEL: u32 = 1;
pub const SPA_IO_CLOCK_FLAG_XRUN_RECOVER: u32 = 2;
pub const SPA_IO_CLOCK_FLAG_LAZY: u32 = 4;
pub const SPA_IO_CLOCK_FLAG_NO_RATE: u32 = 8;
pub const SPA_IO_VIDEO_SIZE_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_BAR_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_VALID: u32 = 1;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_DROP_FRAME: u32 = 2;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_PULL_DOWN: u32 = 4;
pub const SPA_IO_SEGMENT_VIDEO_FLAG_INTERLACED: u32 = 8;
pub const SPA_IO_SEGMENT_FLAG_LOOPING: u32 = 1;
pub const SPA_IO_SEGMENT_FLAG_NO_POSITION: u32 = 2;
pub const SPA_IO_POSITION_MAX_SEGMENTS: u32 = 8;
pub const SPA_IO_RATE_MATCH_FLAG_ACTIVE: u32 = 1;
pub const SPA_TYPE_INFO_IO: &[u8; 12] = b"Spa:Enum:IO\0";
pub const SPA_TYPE_INFO_IO_BASE: &[u8; 13] = b"Spa:Enum:IO:\0";
pub const SPA_TYPE_INFO_NodeEvent: &[u8; 26] = b"Spa:Pod:Object:Event:Node\0";
pub const SPA_TYPE_INFO_NODE_EVENT_BASE: &[u8; 27] = b"Spa:Pod:Object:Event:Node:\0";
pub const SPA_TYPE_INFO_NodeCommand: &[u8; 28] = b"Spa:Pod:Object:Command:Node\0";
pub const SPA_TYPE_INFO_NODE_COMMAND_BASE: &[u8; 29] = b"Spa:Pod:Object:Command:Node:\0";
pub const SPA_PARAM_INFO_SERIAL: u32 = 1;
pub const SPA_PARAM_INFO_READ: u32 = 2;
pub const SPA_PARAM_INFO_WRITE: u32 = 4;
pub const SPA_PARAM_INFO_READWRITE: u32 = 6;
pub const SPA_KEY_FORMAT_DSP: &[u8; 11] = b"format.dsp\0";
pub const SPA_TYPE_INFO_ParamId: &[u8; 17] = b"Spa:Enum:ParamId\0";
pub const SPA_TYPE_INFO_PARAM_ID_BASE: &[u8; 18] = b"Spa:Enum:ParamId:\0";
pub const SPA_TYPE_INFO_Param: &[u8; 21] = b"Spa:Pod:Object:Param\0";
pub const SPA_TYPE_INFO_PARAM_BASE: &[u8; 22] = b"Spa:Pod:Object:Param:\0";
pub const SPA_AUDIO_MAX_CHANNELS: u32 = 64;
pub const SPA_AUDIO_FLAG_NONE: u32 = 0;
pub const SPA_AUDIO_FLAG_UNPOSITIONED: u32 = 1;
pub const SPA_KEY_AUDIO_FORMAT: &[u8; 13] = b"audio.format\0";
pub const SPA_KEY_AUDIO_CHANNEL: &[u8; 14] = b"audio.channel\0";
pub const SPA_KEY_AUDIO_CHANNELS: &[u8; 15] = b"audio.channels\0";
pub const SPA_KEY_AUDIO_RATE: &[u8; 11] = b"audio.rate\0";
pub const SPA_KEY_AUDIO_POSITION: &[u8; 15] = b"audio.position\0";
pub const SPA_KEY_AUDIO_ALLOWED_RATES: &[u8; 20] = b"audio.allowed-rates\0";
pub const SPA_TYPE_INFO_AudioFormat: &[u8; 21] = b"Spa:Enum:AudioFormat\0";
pub const SPA_TYPE_INFO_AUDIO_FORMAT_BASE: &[u8; 22] = b"Spa:Enum:AudioFormat:\0";
pub const SPA_TYPE_INFO_AudioFlags: &[u8; 21] = b"Spa:Flags:AudioFlags\0";
pub const SPA_TYPE_INFO_AUDIO_FLAGS_BASE: &[u8; 22] = b"Spa:Flags:AudioFlags:\0";
pub const SPA_TYPE_INFO_AudioChannel: &[u8; 22] = b"Spa:Enum:AudioChannel\0";
pub const SPA_TYPE_INFO_AUDIO_CHANNEL_BASE: &[u8; 23] = b"Spa:Enum:AudioChannel:\0";
pub const SPA_TYPE_INFO_AudioVolumeRampScale: &[u8; 30] = b"Spa:Enum:AudioVolumeRampScale\0";
pub const SPA_TYPE_INFO_AUDIO_VOLUME_RAMP_SCALE_BASE: &[u8; 31] =
    b"Spa:Enum:AudioVolumeRampScale:\0";
pub const SPA_TYPE_INFO_AudioIEC958Codec: &[u8; 26] = b"Spa:Enum:AudioIEC958Codec\0";
pub const SPA_TYPE_INFO_AUDIO_IEC958_CODEC_BASE: &[u8; 27] = b"Spa:Enum:AudioIEC958Codec:\0";
pub const SPA_TYPE_INFO_AudioMP3ChannelMode: &[u8; 29] = b"Spa:Enum:AudioMP3ChannelMode\0";
pub const SPA_TYPE_INFO_AUDIO_MP3_CHANNEL_MODE_BASE: &[u8; 30] = b"Spa:Enum:AudioMP3ChannelMode:\0";
pub const SPA_TYPE_INFO_AudioAACStreamFormat: &[u8; 30] = b"Spa:Enum:AudioAACStreamFormat\0";
pub const SPA_TYPE_INFO_AUDIO_AAC_STREAM_FORMAT_BASE: &[u8; 31] =
    b"Spa:Enum:AudioAACStreamFormat:\0";
pub const SPA_TYPE_INFO_AudioWMAProfile: &[u8; 25] = b"Spa:Enum:AudioWMAProfile\0";
pub const SPA_TYPE_INFO_AUDIO_WMA_PROFILE_BASE: &[u8; 26] = b"Spa:Enum:AudioWMAProfile:\0";
pub const SPA_TYPE_INFO_AudioAMRBandMode: &[u8; 26] = b"Spa:Enum:AudioAMRBandMode\0";
pub const SPA_TYPE_INFO_AUDIO_AMR_BAND_MODE_BASE: &[u8; 27] = b"Spa:Enum:AudioAMRBandMode:\0";
pub const SPA_TYPE_INFO_ParamBitorder: &[u8; 23] = b"Spa:Enum:ParamBitorder\0";
pub const SPA_TYPE_INFO_PARAM_BITORDER_BASE: &[u8; 24] = b"Spa:Enum:ParamBitorder:\0";
pub const SPA_TYPE_INFO_ParamAvailability: &[u8; 27] = b"Spa:Enum:ParamAvailability\0";
pub const SPA_TYPE_INFO_PARAM_AVAILABILITY_BASE: &[u8; 28] = b"Spa:Enum:ParamAvailability:\0";
pub const SPA_TYPE_INFO_PARAM_Meta: &[u8; 26] = b"Spa:Pod:Object:Param:Meta\0";
pub const SPA_TYPE_INFO_PARAM_META_BASE: &[u8; 27] = b"Spa:Pod:Object:Param:Meta:\0";
pub const SPA_TYPE_INFO_PARAM_IO: &[u8; 24] = b"Spa:Pod:Object:Param:IO\0";
pub const SPA_TYPE_INFO_PARAM_IO_BASE: &[u8; 25] = b"Spa:Pod:Object:Param:IO:\0";
pub const SPA_TYPE_INFO_PARAM_Buffers: &[u8; 29] = b"Spa:Pod:Object:Param:Buffers\0";
pub const SPA_TYPE_INFO_PARAM_BUFFERS_BASE: &[u8; 30] = b"Spa:Pod:Object:Param:Buffers:\0";
pub const SPA_TYPE_INFO_PARAM_BlockInfo: &[u8; 39] = b"Spa:Pod:Object:Param:Buffers:BlockInfo\0";
pub const SPA_TYPE_INFO_PARAM_BLOCK_INFO_BASE: &[u8; 40] =
    b"Spa:Pod:Object:Param:Buffers:BlockInfo:\0";
pub const SPA_TYPE_INFO_BluetoothAudioCodec: &[u8; 29] = b"Spa:Enum:BluetoothAudioCodec\0";
pub const SPA_TYPE_INFO_BLUETOOTH_AUDIO_CODEC_BASE: &[u8; 30] = b"Spa:Enum:BluetoothAudioCodec:\0";
pub const SPA_TYPE_INFO_Props: &[u8; 27] = b"Spa:Pod:Object:Param:Props\0";
pub const SPA_TYPE_INFO_PROPS_BASE: &[u8; 28] = b"Spa:Pod:Object:Param:Props:\0";
pub const SPA_TYPE_INFO_PropInfo: &[u8; 30] = b"Spa:Pod:Object:Param:PropInfo\0";
pub const SPA_TYPE_INFO_PROP_INFO_BASE: &[u8; 31] = b"Spa:Pod:Object:Param:PropInfo:\0";
pub const SPA_VIDEO_MAX_PLANES: u32 = 4;
pub const SPA_VIDEO_MAX_COMPONENTS: u32 = 4;
pub const SPA_TYPE_INFO_VideoFormat: &[u8; 21] = b"Spa:Enum:VideoFormat\0";
pub const SPA_TYPE_INFO_VIDEO_FORMAT_BASE: &[u8; 22] = b"Spa:Enum:VideoFormat:\0";
pub const SPA_TYPE_INFO_VideoFlags: &[u8; 21] = b"Spa:Flags:VideoFlags\0";
pub const SPA_TYPE_INFO_VIDEO_FLAGS_BASE: &[u8; 22] = b"Spa:Flags:VideoFlags:\0";
pub const SPA_TYPE_INFO_VideoInterlaceMode: &[u8; 28] = b"Spa:Enum:VideoInterlaceMode\0";
pub const SPA_TYPE_INFO_VIDEO_INTERLACE_MODE_BASE: &[u8; 29] = b"Spa:Enum:VideoInterlaceMode:\0";
pub const SPA_TYPE_INFO_Format: &[u8; 28] = b"Spa:Pod:Object:Param:Format\0";
pub const SPA_TYPE_INFO_FORMAT_BASE: &[u8; 29] = b"Spa:Pod:Object:Param:Format:\0";
pub const SPA_TYPE_INFO_MediaType: &[u8; 19] = b"Spa:Enum:MediaType\0";
pub const SPA_TYPE_INFO_MEDIA_TYPE_BASE: &[u8; 20] = b"Spa:Enum:MediaType:\0";
pub const SPA_TYPE_INFO_MediaSubtype: &[u8; 22] = b"Spa:Enum:MediaSubtype\0";
pub const SPA_TYPE_INFO_MEDIA_SUBTYPE_BASE: &[u8; 23] = b"Spa:Enum:MediaSubtype:\0";
pub const SPA_TYPE_INFO_FormatAudio: &[u8; 34] = b"Spa:Pod:Object:Param:Format:Audio\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_BASE: &[u8; 35] = b"Spa:Pod:Object:Param:Format:Audio:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AAC: &[u8; 38] = b"Spa:Pod:Object:Param:Format:Audio:AAC\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AAC_BASE: &[u8; 39] =
    b"Spa:Pod:Object:Param:Format:Audio:AAC:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_WMA: &[u8; 38] = b"Spa:Pod:Object:Param:Format:Audio:WMA\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_WMA_BASE: &[u8; 39] =
    b"Spa:Pod:Object:Param:Format:Audio:WMA:\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AMR: &[u8; 38] = b"Spa:Pod:Object:Param:Format:Audio:AMR\0";
pub const SPA_TYPE_INFO_FORMAT_AUDIO_AMR_BASE: &[u8; 39] =
    b"Spa:Pod:Object:Param:Format:Audio:AMR:\0";
pub const SPA_TYPE_INFO_FormatVideo: &[u8; 34] = b"Spa:Pod:Object:Param:Format:Video\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_BASE: &[u8; 35] = b"Spa:Pod:Object:Param:Format:Video:\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_H264: &[u8; 39] = b"Spa:Pod:Object:Param:Format:Video:H264\0";
pub const SPA_TYPE_INFO_FORMAT_VIDEO_H264_BASE: &[u8; 40] =
    b"Spa:Pod:Object:Param:Format:Video:H264:\0";
pub const SPA_TYPE_INFO_FormatControl: &[u8; 36] = b"Spa:Pod:Object:Param:Format:Control\0";
pub const SPA_TYPE_INFO_FORMAT_CONTROL_BASE: &[u8; 37] = b"Spa:Pod:Object:Param:Format:Control:\0";
pub const SPA_TYPE_INFO_PARAM_Latency: &[u8; 29] = b"Spa:Pod:Object:Param:Latency\0";
pub const SPA_TYPE_INFO_PARAM_LATENCY_BASE: &[u8; 30] = b"Spa:Pod:Object:Param:Latency:\0";
pub const SPA_TYPE_INFO_PARAM_ProcessLatency: &[u8; 36] = b"Spa:Pod:Object:Param:ProcessLatency\0";
pub const SPA_TYPE_INFO_PARAM_PROCESS_LATENCY_BASE: &[u8; 37] =
    b"Spa:Pod:Object:Param:ProcessLatency:\0";
pub const SPA_TYPE_INFO_ParamPortConfigMode: &[u8; 29] = b"Spa:Enum:ParamPortConfigMode\0";
pub const SPA_TYPE_INFO_PARAM_PORT_CONFIG_MODE_BASE: &[u8; 30] = b"Spa:Enum:ParamPortConfigMode:\0";
pub const SPA_TYPE_INFO_PARAM_PortConfig: &[u8; 32] = b"Spa:Pod:Object:Param:PortConfig\0";
pub const SPA_TYPE_INFO_PARAM_PORT_CONFIG_BASE: &[u8; 33] = b"Spa:Pod:Object:Param:PortConfig:\0";
pub const SPA_TYPE_INFO_Profiler: &[u8; 24] = b"Spa:Pod:Object:Profiler\0";
pub const SPA_TYPE_INFO_PROFILER_BASE: &[u8; 25] = b"Spa:Pod:Object:Profiler:\0";
pub const SPA_TYPE_INFO_PARAM_Profile: &[u8; 29] = b"Spa:Pod:Object:Param:Profile\0";
pub const SPA_TYPE_INFO_PARAM_PROFILE_BASE: &[u8; 30] = b"Spa:Pod:Object:Param:Profile:\0";
pub const SPA_TYPE_INFO_PARAM_Route: &[u8; 27] = b"Spa:Pod:Object:Param:Route\0";
pub const SPA_TYPE_INFO_PARAM_ROUTE_BASE: &[u8; 28] = b"Spa:Pod:Object:Param:Route:\0";
pub const SPA_TYPE_INFO_PARAM_Tag: &[u8; 25] = b"Spa:Pod:Object:Param:Tag\0";
pub const SPA_TYPE_INFO_PARAM_TAG_BASE: &[u8; 26] = b"Spa:Pod:Object:Param:Tag:\0";
pub const SPA_DICT_FLAG_SORTED: u32 = 1;
pub const SPA_TYPE_INTERFACE_Node: &[u8; 27] = b"Spa:Pointer:Interface:Node\0";
pub const SPA_VERSION_NODE: u32 = 0;
pub const SPA_NODE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_NODE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_NODE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_NODE_FLAG_RT: u32 = 1;
pub const SPA_NODE_FLAG_IN_DYNAMIC_PORTS: u32 = 2;
pub const SPA_NODE_FLAG_OUT_DYNAMIC_PORTS: u32 = 4;
pub const SPA_NODE_FLAG_IN_PORT_CONFIG: u32 = 8;
pub const SPA_NODE_FLAG_OUT_PORT_CONFIG: u32 = 16;
pub const SPA_NODE_FLAG_NEED_CONFIGURE: u32 = 32;
pub const SPA_NODE_FLAG_ASYNC: u32 = 64;
pub const SPA_PORT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_PORT_CHANGE_MASK_RATE: u32 = 2;
pub const SPA_PORT_CHANGE_MASK_PROPS: u32 = 4;
pub const SPA_PORT_CHANGE_MASK_PARAMS: u32 = 8;
pub const SPA_PORT_FLAG_REMOVABLE: u32 = 1;
pub const SPA_PORT_FLAG_OPTIONAL: u32 = 2;
pub const SPA_PORT_FLAG_CAN_ALLOC_BUFFERS: u32 = 4;
pub const SPA_PORT_FLAG_IN_PLACE: u32 = 8;
pub const SPA_PORT_FLAG_NO_REF: u32 = 16;
pub const SPA_PORT_FLAG_LIVE: u32 = 32;
pub const SPA_PORT_FLAG_PHYSICAL: u32 = 64;
pub const SPA_PORT_FLAG_TERMINAL: u32 = 128;
pub const SPA_PORT_FLAG_DYNAMIC_DATA: u32 = 256;
pub const SPA_RESULT_TYPE_NODE_ERROR: u32 = 1;
pub const SPA_RESULT_TYPE_NODE_PARAMS: u32 = 2;
pub const SPA_NODE_EVENT_INFO: u32 = 0;
pub const SPA_NODE_EVENT_PORT_INFO: u32 = 1;
pub const SPA_NODE_EVENT_RESULT: u32 = 2;
pub const SPA_NODE_EVENT_EVENT: u32 = 3;
pub const SPA_NODE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_NODE_EVENTS: u32 = 0;
pub const SPA_NODE_CALLBACK_READY: u32 = 0;
pub const SPA_NODE_CALLBACK_REUSE_BUFFER: u32 = 1;
pub const SPA_NODE_CALLBACK_XRUN: u32 = 2;
pub const SPA_NODE_CALLBACK_NUM: u32 = 3;
pub const SPA_VERSION_NODE_CALLBACKS: u32 = 0;
pub const SPA_NODE_PARAM_FLAG_TEST_ONLY: u32 = 1;
pub const SPA_NODE_PARAM_FLAG_FIXATE: u32 = 2;
pub const SPA_NODE_PARAM_FLAG_NEAREST: u32 = 4;
pub const SPA_NODE_BUFFERS_FLAG_ALLOC: u32 = 1;
pub const SPA_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_NODE_METHOD_SET_CALLBACKS: u32 = 1;
pub const SPA_NODE_METHOD_SYNC: u32 = 2;
pub const SPA_NODE_METHOD_ENUM_PARAMS: u32 = 3;
pub const SPA_NODE_METHOD_SET_PARAM: u32 = 4;
pub const SPA_NODE_METHOD_SET_IO: u32 = 5;
pub const SPA_NODE_METHOD_SEND_COMMAND: u32 = 6;
pub const SPA_NODE_METHOD_ADD_PORT: u32 = 7;
pub const SPA_NODE_METHOD_REMOVE_PORT: u32 = 8;
pub const SPA_NODE_METHOD_PORT_ENUM_PARAMS: u32 = 9;
pub const SPA_NODE_METHOD_PORT_SET_PARAM: u32 = 10;
pub const SPA_NODE_METHOD_PORT_USE_BUFFERS: u32 = 11;
pub const SPA_NODE_METHOD_PORT_SET_IO: u32 = 12;
pub const SPA_NODE_METHOD_PORT_REUSE_BUFFER: u32 = 13;
pub const SPA_NODE_METHOD_PROCESS: u32 = 14;
pub const SPA_NODE_METHOD_NUM: u32 = 15;
pub const SPA_VERSION_NODE_METHODS: u32 = 0;
pub const SPA_VERSION_GRAPH_NODE_CALLBACKS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Device: &[u8; 29] = b"Spa:Pointer:Interface:Device\0";
pub const SPA_VERSION_DEVICE: u32 = 0;
pub const SPA_VERSION_DEVICE_INFO: u32 = 0;
pub const SPA_DEVICE_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_DEVICE_CHANGE_MASK_PARAMS: u32 = 4;
pub const SPA_VERSION_DEVICE_OBJECT_INFO: u32 = 0;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_FLAGS: u32 = 1;
pub const SPA_DEVICE_OBJECT_CHANGE_MASK_PROPS: u32 = 2;
pub const SPA_RESULT_TYPE_DEVICE_PARAMS: u32 = 1;
pub const SPA_DEVICE_EVENT_INFO: u32 = 0;
pub const SPA_DEVICE_EVENT_RESULT: u32 = 1;
pub const SPA_DEVICE_EVENT_EVENT: u32 = 2;
pub const SPA_DEVICE_EVENT_OBJECT_INFO: u32 = 3;
pub const SPA_DEVICE_EVENT_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_EVENTS: u32 = 0;
pub const SPA_DEVICE_METHOD_ADD_LISTENER: u32 = 0;
pub const SPA_DEVICE_METHOD_SYNC: u32 = 1;
pub const SPA_DEVICE_METHOD_ENUM_PARAMS: u32 = 2;
pub const SPA_DEVICE_METHOD_SET_PARAM: u32 = 3;
pub const SPA_DEVICE_METHOD_NUM: u32 = 4;
pub const SPA_VERSION_DEVICE_METHODS: u32 = 0;
pub const SPA_KEY_DEVICE_ENUM_API: &[u8; 16] = b"device.enum.api\0";
pub const SPA_KEY_DEVICE_API: &[u8; 11] = b"device.api\0";
pub const SPA_KEY_DEVICE_NAME: &[u8; 12] = b"device.name\0";
pub const SPA_KEY_DEVICE_ALIAS: &[u8; 13] = b"device.alias\0";
pub const SPA_KEY_DEVICE_NICK: &[u8; 12] = b"device.nick\0";
pub const SPA_KEY_DEVICE_DESCRIPTION: &[u8; 19] = b"device.description\0";
pub const SPA_KEY_DEVICE_ICON: &[u8; 12] = b"device.icon\0";
pub const SPA_KEY_DEVICE_ICON_NAME: &[u8; 17] = b"device.icon-name\0";
pub const SPA_KEY_DEVICE_PLUGGED_USEC: &[u8; 20] = b"device.plugged.usec\0";
pub const SPA_KEY_DEVICE_BUS_ID: &[u8; 14] = b"device.bus-id\0";
pub const SPA_KEY_DEVICE_BUS_PATH: &[u8; 16] = b"device.bus-path\0";
pub const SPA_KEY_DEVICE_BUS: &[u8; 11] = b"device.bus\0";
pub const SPA_KEY_DEVICE_SUBSYSTEM: &[u8; 17] = b"device.subsystem\0";
pub const SPA_KEY_DEVICE_SYSFS_PATH: &[u8; 18] = b"device.sysfs.path\0";
pub const SPA_KEY_DEVICE_VENDOR_ID: &[u8; 17] = b"device.vendor.id\0";
pub const SPA_KEY_DEVICE_VENDOR_NAME: &[u8; 19] = b"device.vendor.name\0";
pub const SPA_KEY_DEVICE_PRODUCT_ID: &[u8; 18] = b"device.product.id\0";
pub const SPA_KEY_DEVICE_PRODUCT_NAME: &[u8; 20] = b"device.product.name\0";
pub const SPA_KEY_DEVICE_SERIAL: &[u8; 14] = b"device.serial\0";
pub const SPA_KEY_DEVICE_CLASS: &[u8; 13] = b"device.class\0";
pub const SPA_KEY_DEVICE_CAPABILITIES: &[u8; 20] = b"device.capabilities\0";
pub const SPA_KEY_DEVICE_FORM_FACTOR: &[u8; 19] = b"device.form-factor\0";
pub const SPA_KEY_DEVICE_PROFILE: &[u8; 15] = b"device.profile\0";
pub const SPA_KEY_DEVICE_PROFILE_SET: &[u8; 19] = b"device.profile-set\0";
pub const SPA_KEY_DEVICE_STRING: &[u8; 14] = b"device.string\0";
pub const SPA_KEY_DEVICE_DEVIDS: &[u8; 14] = b"device.devids\0";
pub const SPA_POD_BUILDER_FLAG_BODY: u32 = 1;
pub const SPA_POD_BUILDER_FLAG_FIRST: u32 = 2;
pub const SPA_VERSION_POD_BUILDER_CALLBACKS: u32 = 0;
pub const SPA_KEY_NODE_NAME: &[u8; 10] = b"node.name\0";
pub const SPA_KEY_NODE_DESCRIPTION: &[u8; 17] = b"node.description\0";
pub const SPA_KEY_NODE_LATENCY: &[u8; 13] = b"node.latency\0";
pub const SPA_KEY_NODE_MAX_LATENCY: &[u8; 17] = b"node.max-latency\0";
pub const SPA_KEY_NODE_DRIVER: &[u8; 12] = b"node.driver\0";
pub const SPA_KEY_NODE_ALWAYS_PROCESS: &[u8; 20] = b"node.always-process\0";
pub const SPA_KEY_NODE_PAUSE_ON_IDLE: &[u8; 19] = b"node.pause-on-idle\0";
pub const SPA_KEY_NODE_MONITOR: &[u8; 13] = b"node.monitor\0";
pub const SPA_KEY_PORT_NAME: &[u8; 10] = b"port.name\0";
pub const SPA_KEY_PORT_ALIAS: &[u8; 11] = b"port.alias\0";
pub const SPA_KEY_PORT_MONITOR: &[u8; 13] = b"port.monitor\0";
pub const SPA_KEY_PORT_IGNORE_LATENCY: &[u8; 20] = b"port.ignore-latency\0";
pub const SPA_KEY_PORT_GROUP: &[u8; 11] = b"port.group\0";
pub const SPA_AUDIO_DSD_FLAG_NONE: u32 = 0;
pub const SPA_TYPE_INTERFACE_CPU: &[u8; 26] = b"Spa:Pointer:Interface:CPU\0";
pub const SPA_VERSION_CPU: u32 = 0;
pub const SPA_CPU_FLAG_MMX: u32 = 1;
pub const SPA_CPU_FLAG_MMXEXT: u32 = 2;
pub const SPA_CPU_FLAG_3DNOW: u32 = 4;
pub const SPA_CPU_FLAG_SSE: u32 = 8;
pub const SPA_CPU_FLAG_SSE2: u32 = 16;
pub const SPA_CPU_FLAG_3DNOWEXT: u32 = 32;
pub const SPA_CPU_FLAG_SSE3: u32 = 64;
pub const SPA_CPU_FLAG_SSSE3: u32 = 128;
pub const SPA_CPU_FLAG_SSE41: u32 = 256;
pub const SPA_CPU_FLAG_SSE42: u32 = 512;
pub const SPA_CPU_FLAG_AESNI: u32 = 1024;
pub const SPA_CPU_FLAG_AVX: u32 = 2048;
pub const SPA_CPU_FLAG_XOP: u32 = 4096;
pub const SPA_CPU_FLAG_FMA4: u32 = 8192;
pub const SPA_CPU_FLAG_CMOV: u32 = 16384;
pub const SPA_CPU_FLAG_AVX2: u32 = 32768;
pub const SPA_CPU_FLAG_FMA3: u32 = 65536;
pub const SPA_CPU_FLAG_BMI1: u32 = 131072;
pub const SPA_CPU_FLAG_BMI2: u32 = 262144;
pub const SPA_CPU_FLAG_AVX512: u32 = 524288;
pub const SPA_CPU_FLAG_SLOW_UNALIGNED: u32 = 1048576;
pub const SPA_CPU_FLAG_ALTIVEC: u32 = 1;
pub const SPA_CPU_FLAG_VSX: u32 = 2;
pub const SPA_CPU_FLAG_POWER8: u32 = 4;
pub const SPA_CPU_FLAG_ARMV5TE: u32 = 1;
pub const SPA_CPU_FLAG_ARMV6: u32 = 2;
pub const SPA_CPU_FLAG_ARMV6T2: u32 = 4;
pub const SPA_CPU_FLAG_VFP: u32 = 8;
pub const SPA_CPU_FLAG_VFPV3: u32 = 16;
pub const SPA_CPU_FLAG_NEON: u32 = 32;
pub const SPA_CPU_FLAG_ARMV8: u32 = 64;
pub const SPA_CPU_FLAG_RISCV_V: u32 = 1;
pub const SPA_CPU_VM_NONE: u32 = 0;
pub const SPA_CPU_VM_OTHER: u32 = 1;
pub const SPA_CPU_VM_KVM: u32 = 2;
pub const SPA_CPU_VM_QEMU: u32 = 4;
pub const SPA_CPU_VM_BOCHS: u32 = 8;
pub const SPA_CPU_VM_XEN: u32 = 16;
pub const SPA_CPU_VM_UML: u32 = 32;
pub const SPA_CPU_VM_VMWARE: u32 = 64;
pub const SPA_CPU_VM_ORACLE: u32 = 128;
pub const SPA_CPU_VM_MICROSOFT: u32 = 256;
pub const SPA_CPU_VM_ZVM: u32 = 512;
pub const SPA_CPU_VM_PARALLELS: u32 = 1024;
pub const SPA_CPU_VM_BHYVE: u32 = 2048;
pub const SPA_CPU_VM_QNX: u32 = 4096;
pub const SPA_CPU_VM_ACRN: u32 = 8192;
pub const SPA_CPU_VM_POWERVM: u32 = 16384;
pub const SPA_VERSION_CPU_METHODS: u32 = 2;
pub const SPA_KEY_CPU_FORCE: &[u8; 10] = b"cpu.force\0";
pub const SPA_KEY_CPU_VM_TYPE: &[u8; 12] = b"cpu.vm.type\0";
pub const SPA_KEY_CPU_ZERO_DENORMALS: &[u8; 19] = b"cpu.zero.denormals\0";
pub const SPA_TYPE_INTERFACE_System: &[u8; 29] = b"Spa:Pointer:Interface:System\0";
pub const SPA_TYPE_INTERFACE_DataSystem: &[u8; 33] = b"Spa:Pointer:Interface:DataSystem\0";
pub const SPA_VERSION_SYSTEM: u32 = 0;
pub const SPA_IO_IN: u32 = 1;
pub const SPA_IO_OUT: u32 = 4;
pub const SPA_IO_ERR: u32 = 8;
pub const SPA_IO_HUP: u32 = 16;
pub const SPA_FD_CLOEXEC: u32 = 1;
pub const SPA_FD_NONBLOCK: u32 = 2;
pub const SPA_FD_EVENT_SEMAPHORE: u32 = 4;
pub const SPA_FD_TIMER_ABSTIME: u32 = 8;
pub const SPA_FD_TIMER_CANCEL_ON_SET: u32 = 16;
pub const SPA_VERSION_SYSTEM_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Loop: &[u8; 27] = b"Spa:Pointer:Interface:Loop\0";
pub const SPA_TYPE_INTERFACE_DataLoop: &[u8; 31] = b"Spa:Pointer:Interface:DataLoop\0";
pub const SPA_VERSION_LOOP: u32 = 0;
pub const SPA_TYPE_INTERFACE_LoopControl: &[u8; 34] = b"Spa:Pointer:Interface:LoopControl\0";
pub const SPA_VERSION_LOOP_CONTROL: u32 = 1;
pub const SPA_TYPE_INTERFACE_LoopUtils: &[u8; 32] = b"Spa:Pointer:Interface:LoopUtils\0";
pub const SPA_VERSION_LOOP_UTILS: u32 = 0;
pub const SPA_VERSION_LOOP_METHODS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_HOOKS: u32 = 0;
pub const SPA_VERSION_LOOP_CONTROL_METHODS: u32 = 1;
pub const SPA_VERSION_LOOP_UTILS_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_DBus: &[u8; 27] = b"Spa:Pointer:Interface:DBus\0";
pub const SPA_VERSION_DBUS: u32 = 0;
pub const SPA_DBUS_CONNECTION_EVENT_DESTROY: u32 = 0;
pub const SPA_DBUS_CONNECTION_EVENT_DISCONNECTED: u32 = 1;
pub const SPA_DBUS_CONNECTION_EVENT_NUM: u32 = 2;
pub const SPA_VERSION_DBUS_CONNECTION_EVENTS: u32 = 0;
pub const SPA_VERSION_DBUS_CONNECTION: u32 = 1;
pub const SPA_VERSION_DBUS_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_I18N: &[u8; 27] = b"Spa:Pointer:Interface:I18N\0";
pub const SPA_VERSION_I18N: u32 = 0;
pub const SPA_VERSION_I18N_METHODS: u32 = 0;
pub const SPA_TYPE_INTERFACE_Log: &[u8; 26] = b"Spa:Pointer:Interface:Log\0";
pub const SPA_VERSION_LOG: u32 = 0;
pub const SPA_VERSION_LOG_TOPIC: u32 = 0;
pub const SPA_VERSION_LOG_TOPIC_ENUM: u32 = 0;
pub const SPA_VERSION_LOG_METHODS: u32 = 1;
pub const SPA_LOG_TOPIC_ENUM_NAME: &[u8; 19] = b"spa_log_topic_enum\0";
pub const SPA_KEY_LOG_LEVEL: &[u8; 10] = b"log.level\0";
pub const SPA_KEY_LOG_COLORS: &[u8; 11] = b"log.colors\0";
pub const SPA_KEY_LOG_FILE: &[u8; 9] = b"log.file\0";
pub const SPA_KEY_LOG_TIMESTAMP: &[u8; 14] = b"log.timestamp\0";
pub const SPA_KEY_LOG_LINE: &[u8; 9] = b"log.line\0";
pub const SPA_KEY_LOG_PATTERNS: &[u8; 13] = b"log.patterns\0";
pub const SPA_TYPE_INTERFACE_PluginLoader: &[u8; 35] = b"Spa:Pointer:Interface:PluginLoader\0";
pub const SPA_VERSION_PLUGIN_LOADER: u32 = 0;
pub const SPA_VERSION_PLUGIN_LOADER_METHODS: u32 = 0;
pub const SPA_VERSION_HANDLE: u32 = 0;
pub const SPA_VERSION_HANDLE_FACTORY: u32 = 1;
pub const SPA_HANDLE_FACTORY_ENUM_FUNC_NAME: &[u8; 24] = b"spa_handle_factory_enum\0";
pub const SPA_KEY_FACTORY_NAME: &[u8; 13] = b"factory.name\0";
pub const SPA_KEY_FACTORY_AUTHOR: &[u8; 15] = b"factory.author\0";
pub const SPA_KEY_FACTORY_DESCRIPTION: &[u8; 20] = b"factory.description\0";
pub const SPA_KEY_FACTORY_USAGE: &[u8; 14] = b"factory.usage\0";
pub const SPA_KEY_LIBRARY_NAME: &[u8; 13] = b"library.name\0";
pub const SPA_TYPE_INFO_Thread: &[u8; 19] = b"Spa:Pointer:Thread\0";
pub const SPA_TYPE_INTERFACE_ThreadUtils: &[u8; 34] = b"Spa:Pointer:Interface:ThreadUtils\0";
pub const SPA_VERSION_THREAD_UTILS: u32 = 0;
pub const SPA_VERSION_THREAD_UTILS_METHODS: u32 = 0;
pub const SPA_KEY_THREAD_NAME: &[u8; 12] = b"thread.name\0";
pub const SPA_KEY_THREAD_STACK_SIZE: &[u8; 18] = b"thread.stack-size\0";
pub const SPA_KEY_THREAD_AFFINITY: &[u8; 16] = b"thread.affinity\0";
pub const SPA_KEY_THREAD_CREATOR: &[u8; 15] = b"thread.creator\0";
pub const SPA_ANSI_RESET: &[u8; 5] = b"\x1B[0m\0";
pub const SPA_ANSI_BOLD: &[u8; 5] = b"\x1B[1m\0";
pub const SPA_ANSI_ITALIC: &[u8; 5] = b"\x1B[3m\0";
pub const SPA_ANSI_UNDERLINE: &[u8; 5] = b"\x1B[4m\0";
pub const SPA_ANSI_BLACK: &[u8; 8] = b"\x1B[0;30m\0";
pub const SPA_ANSI_RED: &[u8; 8] = b"\x1B[0;31m\0";
pub const SPA_ANSI_GREEN: &[u8; 8] = b"\x1B[0;32m\0";
pub const SPA_ANSI_YELLOW: &[u8; 8] = b"\x1B[0;33m\0";
pub const SPA_ANSI_BLUE: &[u8; 8] = b"\x1B[0;34m\0";
pub const SPA_ANSI_MAGENTA: &[u8; 8] = b"\x1B[0;35m\0";
pub const SPA_ANSI_CYAN: &[u8; 8] = b"\x1B[0;36m\0";
pub const SPA_ANSI_WHITE: &[u8; 8] = b"\x1B[0;37m\0";
pub const SPA_ANSI_BRIGHT_BLACK: &[u8; 6] = b"\x1B[90m\0";
pub const SPA_ANSI_BRIGHT_RED: &[u8; 6] = b"\x1B[91m\0";
pub const SPA_ANSI_BRIGHT_GREEN: &[u8; 6] = b"\x1B[92m\0";
pub const SPA_ANSI_BRIGHT_YELLOW: &[u8; 6] = b"\x1B[93m\0";
pub const SPA_ANSI_BRIGHT_BLUE: &[u8; 6] = b"\x1B[94m\0";
pub const SPA_ANSI_BRIGHT_MAGENTA: &[u8; 6] = b"\x1B[95m\0";
pub const SPA_ANSI_BRIGHT_CYAN: &[u8; 6] = b"\x1B[96m\0";
pub const SPA_ANSI_BRIGHT_WHITE: &[u8; 6] = b"\x1B[97m\0";
pub const SPA_ANSI_BOLD_BLACK: &[u8; 8] = b"\x1B[1;30m\0";
pub const SPA_ANSI_BOLD_RED: &[u8; 8] = b"\x1B[1;31m\0";
pub const SPA_ANSI_BOLD_GREEN: &[u8; 8] = b"\x1B[1;32m\0";
pub const SPA_ANSI_BOLD_YELLOW: &[u8; 8] = b"\x1B[1;33m\0";
pub const SPA_ANSI_BOLD_BLUE: &[u8; 8] = b"\x1B[1;34m\0";
pub const SPA_ANSI_BOLD_MAGENTA: &[u8; 8] = b"\x1B[1;35m\0";
pub const SPA_ANSI_BOLD_CYAN: &[u8; 8] = b"\x1B[1;36m\0";
pub const SPA_ANSI_BOLD_WHITE: &[u8; 8] = b"\x1B[1;37m\0";
pub const SPA_ANSI_DARK_BLACK: &[u8; 8] = b"\x1B[2;30m\0";
pub const SPA_ANSI_DARK_RED: &[u8; 8] = b"\x1B[2;31m\0";
pub const SPA_ANSI_DARK_GREEN: &[u8; 8] = b"\x1B[2;32m\0";
pub const SPA_ANSI_DARK_YELLOW: &[u8; 8] = b"\x1B[2;33m\0";
pub const SPA_ANSI_DARK_BLUE: &[u8; 8] = b"\x1B[2;34m\0";
pub const SPA_ANSI_DARK_MAGENTA: &[u8; 8] = b"\x1B[2;35m\0";
pub const SPA_ANSI_DARK_CYAN: &[u8; 8] = b"\x1B[2;36m\0";
pub const SPA_ANSI_DARK_WHITE: &[u8; 8] = b"\x1B[2;37m\0";
pub const SPA_ANSI_BG_BLACK: &[u8; 8] = b"\x1B[0;40m\0";
pub const SPA_ANSI_BG_RED: &[u8; 8] = b"\x1B[0;41m\0";
pub const SPA_ANSI_BG_GREEN: &[u8; 8] = b"\x1B[0;42m\0";
pub const SPA_ANSI_BG_YELLOW: &[u8; 8] = b"\x1B[0;43m\0";
pub const SPA_ANSI_BG_BLUE: &[u8; 8] = b"\x1B[0;44m\0";
pub const SPA_ANSI_BG_MAGENTA: &[u8; 8] = b"\x1B[0;45m\0";
pub const SPA_ANSI_BG_CYAN: &[u8; 8] = b"\x1B[0;46m\0";
pub const SPA_ANSI_BG_WHITE: &[u8; 8] = b"\x1B[0;47m\0";
pub const SPA_ANSI_BG_BRIGHT_BLACK: &[u8; 7] = b"\x1B[100m\0";
pub const SPA_ANSI_BG_BRIGHT_RED: &[u8; 7] = b"\x1B[101m\0";
pub const SPA_ANSI_BG_BRIGHT_GREEN: &[u8; 7] = b"\x1B[102m\0";
pub const SPA_ANSI_BG_BRIGHT_YELLOW: &[u8; 7] = b"\x1B[103m\0";
pub const SPA_ANSI_BG_BRIGHT_BLUE: &[u8; 7] = b"\x1B[104m\0";
pub const SPA_ANSI_BG_BRIGHT_MAGENTA: &[u8; 7] = b"\x1B[105m\0";
pub const SPA_ANSI_BG_BRIGHT_CYAN: &[u8; 7] = b"\x1B[106m\0";
pub const SPA_ANSI_BG_BRIGHT_WHITE: &[u8; 7] = b"\x1B[107m\0";
pub const SPA_JSON_ERROR_FLAG: u32 = 256;
pub const SPA_KEY_OBJECT_PATH: &[u8; 12] = b"object.path\0";
pub const SPA_KEY_MEDIA_CLASS: &[u8; 12] = b"media.class\0";
pub const SPA_KEY_MEDIA_ROLE: &[u8; 11] = b"media.role\0";
pub const SPA_KEY_API_UDEV: &[u8; 9] = b"api.udev\0";
pub const SPA_KEY_API_UDEV_MATCH: &[u8; 15] = b"api.udev.match\0";
pub const SPA_KEY_API_ALSA: &[u8; 9] = b"api.alsa\0";
pub const SPA_KEY_API_ALSA_PATH: &[u8; 14] = b"api.alsa.path\0";
pub const SPA_KEY_API_ALSA_CARD: &[u8; 14] = b"api.alsa.card\0";
pub const SPA_KEY_API_ALSA_USE_UCM: &[u8; 17] = b"api.alsa.use-ucm\0";
pub const SPA_KEY_API_ALSA_IGNORE_DB: &[u8; 19] = b"api.alsa.ignore-dB\0";
pub const SPA_KEY_API_ALSA_OPEN_UCM: &[u8; 18] = b"api.alsa.open.ucm\0";
pub const SPA_KEY_API_ALSA_DISABLE_LONGNAME: &[u8; 26] = b"api.alsa.disable-longname\0";
pub const SPA_KEY_API_ALSA_BIND_CTLS: &[u8; 19] = b"api.alsa.bind-ctls\0";
pub const SPA_KEY_API_ALSA_SPLIT_ENABLE: &[u8; 22] = b"api.alsa.split-enable\0";
pub const SPA_KEY_API_ALSA_SPLIT_PARENT: &[u8; 22] = b"api.alsa.split.parent\0";
pub const SPA_KEY_API_ALSA_CARD_ID: &[u8; 17] = b"api.alsa.card.id\0";
pub const SPA_KEY_API_ALSA_CARD_COMPONENTS: &[u8; 25] = b"api.alsa.card.components\0";
pub const SPA_KEY_API_ALSA_CARD_DRIVER: &[u8; 21] = b"api.alsa.card.driver\0";
pub const SPA_KEY_API_ALSA_CARD_NAME: &[u8; 19] = b"api.alsa.card.name\0";
pub const SPA_KEY_API_ALSA_CARD_LONGNAME: &[u8; 23] = b"api.alsa.card.longname\0";
pub const SPA_KEY_API_ALSA_CARD_MIXERNAME: &[u8; 24] = b"api.alsa.card.mixername\0";
pub const SPA_KEY_API_ALSA_PCM_ID: &[u8; 16] = b"api.alsa.pcm.id\0";
pub const SPA_KEY_API_ALSA_PCM_CARD: &[u8; 18] = b"api.alsa.pcm.card\0";
pub const SPA_KEY_API_ALSA_PCM_NAME: &[u8; 18] = b"api.alsa.pcm.name\0";
pub const SPA_KEY_API_ALSA_PCM_SUBNAME: &[u8; 21] = b"api.alsa.pcm.subname\0";
pub const SPA_KEY_API_ALSA_PCM_STREAM: &[u8; 20] = b"api.alsa.pcm.stream\0";
pub const SPA_KEY_API_ALSA_PCM_CLASS: &[u8; 19] = b"api.alsa.pcm.class\0";
pub const SPA_KEY_API_ALSA_PCM_DEVICE: &[u8; 20] = b"api.alsa.pcm.device\0";
pub const SPA_KEY_API_ALSA_PCM_SUBDEVICE: &[u8; 23] = b"api.alsa.pcm.subdevice\0";
pub const SPA_KEY_API_ALSA_PCM_SUBCLASS: &[u8; 22] = b"api.alsa.pcm.subclass\0";
pub const SPA_KEY_API_ALSA_PCM_SYNC_ID: &[u8; 21] = b"api.alsa.pcm.sync-id\0";
pub const SPA_KEY_API_ALSA_SPLIT_POSITION: &[u8; 24] = b"api.alsa.split.position\0";
pub const SPA_KEY_API_ALSA_SPLIT_HW_POSITION: &[u8; 27] = b"api.alsa.split.hw-position\0";
pub const SPA_KEY_API_V4L2: &[u8; 9] = b"api.v4l2\0";
pub const SPA_KEY_API_V4L2_PATH: &[u8; 14] = b"api.v4l2.path\0";
pub const SPA_KEY_API_LIBCAMERA: &[u8; 14] = b"api.libcamera\0";
pub const SPA_KEY_API_LIBCAMERA_PATH: &[u8; 19] = b"api.libcamera.path\0";
pub const SPA_KEY_API_LIBCAMERA_LOCATION: &[u8; 23] = b"api.libcamera.location\0";
pub const SPA_KEY_API_LIBCAMERA_ROTATION: &[u8; 23] = b"api.libcamera.rotation\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_DRIVER: &[u8; 25] = b"api.libcamera.cap.driver\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_CARD: &[u8; 23] = b"api.libcamera.cap.card\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_BUS_INFO: &[u8; 27] = b"api.libcamera.cap.bus_info\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_VERSION: &[u8; 26] = b"api.libcamera.cap.version\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_CAPABILITIES: &[u8; 31] = b"api.libcamera.cap.capabilities\0";
pub const SPA_KEY_API_LIBCAMERA_CAP_DEVICE_CAPS: &[u8; 30] = b"api.libcamera.cap.device-caps\0";
pub const SPA_KEY_API_V4L2_CAP_DRIVER: &[u8; 20] = b"api.v4l2.cap.driver\0";
pub const SPA_KEY_API_V4L2_CAP_CARD: &[u8; 18] = b"api.v4l2.cap.card\0";
pub const SPA_KEY_API_V4L2_CAP_BUS_INFO: &[u8; 22] = b"api.v4l2.cap.bus_info\0";
pub const SPA_KEY_API_V4L2_CAP_VERSION: &[u8; 21] = b"api.v4l2.cap.version\0";
pub const SPA_KEY_API_V4L2_CAP_CAPABILITIES: &[u8; 26] = b"api.v4l2.cap.capabilities\0";
pub const SPA_KEY_API_V4L2_CAP_DEVICE_CAPS: &[u8; 25] = b"api.v4l2.cap.device-caps\0";
pub const SPA_KEY_API_BLUEZ5: &[u8; 11] = b"api.bluez5\0";
pub const SPA_KEY_API_BLUEZ5_PATH: &[u8; 16] = b"api.bluez5.path\0";
pub const SPA_KEY_API_BLUEZ5_DEVICE: &[u8; 18] = b"api.bluez5.device\0";
pub const SPA_KEY_API_BLUEZ5_CONNECTION: &[u8; 22] = b"api.bluez5.connection\0";
pub const SPA_KEY_API_BLUEZ5_TRANSPORT: &[u8; 21] = b"api.bluez5.transport\0";
pub const SPA_KEY_API_BLUEZ5_PROFILE: &[u8; 19] = b"api.bluez5.profile\0";
pub const SPA_KEY_API_BLUEZ5_ADDRESS: &[u8; 19] = b"api.bluez5.address\0";
pub const SPA_KEY_API_BLUEZ5_CODEC: &[u8; 17] = b"api.bluez5.codec\0";
pub const SPA_KEY_API_BLUEZ5_CLASS: &[u8; 17] = b"api.bluez5.class\0";
pub const SPA_KEY_API_BLUEZ5_ICON: &[u8; 16] = b"api.bluez5.icon\0";
pub const SPA_KEY_API_BLUEZ5_ROLE: &[u8; 16] = b"api.bluez5.role\0";
pub const SPA_KEY_API_JACK: &[u8; 9] = b"api.jack\0";
pub const SPA_KEY_API_JACK_SERVER: &[u8; 16] = b"api.jack.server\0";
pub const SPA_KEY_API_JACK_CLIENT: &[u8; 16] = b"api.jack.client\0";
pub const SPA_KEY_API_GLIB_MAINLOOP: &[u8; 18] = b"api.glib.mainloop\0";
pub const SPA_NAME_SUPPORT_CPU: &[u8; 12] = b"support.cpu\0";
pub const SPA_NAME_SUPPORT_DBUS: &[u8; 13] = b"support.dbus\0";
pub const SPA_NAME_SUPPORT_LOG: &[u8; 12] = b"support.log\0";
pub const SPA_NAME_SUPPORT_LOOP: &[u8; 13] = b"support.loop\0";
pub const SPA_NAME_SUPPORT_SYSTEM: &[u8; 15] = b"support.system\0";
pub const SPA_NAME_SUPPORT_NODE_DRIVER: &[u8; 20] = b"support.node.driver\0";
pub const SPA_NAME_CONTROL_MIXER: &[u8; 14] = b"control.mixer\0";
pub const SPA_NAME_AUDIO_MIXER: &[u8; 12] = b"audio.mixer\0";
pub const SPA_NAME_AUDIO_MIXER_DSP: &[u8; 16] = b"audio.mixer.dsp\0";
pub const SPA_NAME_AUDIO_PROCESS_FORMAT: &[u8; 21] = b"audio.process.format\0";
pub const SPA_NAME_AUDIO_PROCESS_CHANNELMIX: &[u8; 25] = b"audio.process.channelmix\0";
pub const SPA_NAME_AUDIO_PROCESS_RESAMPLE: &[u8; 23] = b"audio.process.resample\0";
pub const SPA_NAME_AUDIO_PROCESS_DEINTERLEAVE: &[u8; 27] = b"audio.process.deinterleave\0";
pub const SPA_NAME_AUDIO_PROCESS_INTERLEAVE: &[u8; 25] = b"audio.process.interleave\0";
pub const SPA_NAME_AUDIO_CONVERT: &[u8; 14] = b"audio.convert\0";
pub const SPA_NAME_AUDIO_ADAPT: &[u8; 12] = b"audio.adapt\0";
pub const SPA_NAME_AEC: &[u8; 10] = b"audio.aec\0";
pub const SPA_NAME_VIDEO_PROCESS_FORMAT: &[u8; 21] = b"video.process.format\0";
pub const SPA_NAME_VIDEO_PROCESS_SCALE: &[u8; 20] = b"video.process.scale\0";
pub const SPA_NAME_VIDEO_CONVERT: &[u8; 14] = b"video.convert\0";
pub const SPA_NAME_VIDEO_CONVERT_DUMMY: &[u8; 20] = b"video.convert.dummy\0";
pub const SPA_NAME_VIDEO_ADAPT: &[u8; 12] = b"video.adapt\0";
pub const SPA_NAME_API_ALSA_ENUM_UDEV: &[u8; 19] = b"api.alsa.enum.udev\0";
pub const SPA_NAME_API_ALSA_PCM_DEVICE: &[u8; 20] = b"api.alsa.pcm.device\0";
pub const SPA_NAME_API_ALSA_PCM_SOURCE: &[u8; 20] = b"api.alsa.pcm.source\0";
pub const SPA_NAME_API_ALSA_PCM_SINK: &[u8; 18] = b"api.alsa.pcm.sink\0";
pub const SPA_NAME_API_ALSA_SEQ_DEVICE: &[u8; 20] = b"api.alsa.seq.device\0";
pub const SPA_NAME_API_ALSA_SEQ_SOURCE: &[u8; 20] = b"api.alsa.seq.source\0";
pub const SPA_NAME_API_ALSA_SEQ_SINK: &[u8; 18] = b"api.alsa.seq.sink\0";
pub const SPA_NAME_API_ALSA_SEQ_BRIDGE: &[u8; 20] = b"api.alsa.seq.bridge\0";
pub const SPA_NAME_API_ALSA_ACP_DEVICE: &[u8; 20] = b"api.alsa.acp.device\0";
pub const SPA_NAME_API_ALSA_COMPRESS_OFFLOAD_DEVICE: &[u8; 33] =
    b"api.alsa.compress.offload.device\0";
pub const SPA_NAME_API_ALSA_COMPRESS_OFFLOAD_SINK: &[u8; 31] = b"api.alsa.compress.offload.sink\0";
pub const SPA_NAME_API_BLUEZ5_ENUM_DBUS: &[u8; 21] = b"api.bluez5.enum.dbus\0";
pub const SPA_NAME_API_BLUEZ5_DEVICE: &[u8; 18] = b"api.bluez5.device\0";
pub const SPA_NAME_API_BLUEZ5_MEDIA_SINK: &[u8; 22] = b"api.bluez5.media.sink\0";
pub const SPA_NAME_API_BLUEZ5_MEDIA_SOURCE: &[u8; 24] = b"api.bluez5.media.source\0";
pub const SPA_NAME_API_BLUEZ5_A2DP_SINK: &[u8; 21] = b"api.bluez5.a2dp.sink\0";
pub const SPA_NAME_API_BLUEZ5_A2DP_SOURCE: &[u8; 23] = b"api.bluez5.a2dp.source\0";
pub const SPA_NAME_API_BLUEZ5_SCO_SINK: &[u8; 20] = b"api.bluez5.sco.sink\0";
pub const SPA_NAME_API_BLUEZ5_SCO_SOURCE: &[u8; 22] = b"api.bluez5.sco.source\0";
pub const SPA_NAME_API_BLUEZ5_MIDI_ENUM: &[u8; 21] = b"api.bluez5.midi.enum\0";
pub const SPA_NAME_API_BLUEZ5_MIDI_NODE: &[u8; 21] = b"api.bluez5.midi.node\0";
pub const SPA_NAME_API_CODEC_BLUEZ5_MEDIA: &[u8; 23] = b"api.codec.bluez5.media\0";
pub const SPA_NAME_API_V4L2_ENUM_UDEV: &[u8; 19] = b"api.v4l2.enum.udev\0";
pub const SPA_NAME_API_V4L2_DEVICE: &[u8; 16] = b"api.v4l2.device\0";
pub const SPA_NAME_API_V4L2_SOURCE: &[u8; 16] = b"api.v4l2.source\0";
pub const SPA_NAME_API_LIBCAMERA_ENUM_CLIENT: &[u8; 26] = b"api.libcamera.enum.client\0";
pub const SPA_NAME_API_LIBCAMERA_ENUM_MANAGER: &[u8; 27] = b"api.libcamera.enum.manager\0";
pub const SPA_NAME_API_LIBCAMERA_DEVICE: &[u8; 21] = b"api.libcamera.device\0";
pub const SPA_NAME_API_LIBCAMERA_SOURCE: &[u8; 21] = b"api.libcamera.source\0";
pub const SPA_NAME_API_JACK_DEVICE: &[u8; 16] = b"api.jack.device\0";
pub const SPA_NAME_API_JACK_SOURCE: &[u8; 16] = b"api.jack.source\0";
pub const SPA_NAME_API_JACK_SINK: &[u8; 14] = b"api.jack.sink\0";
pub const SPA_NAME_API_VULKAN_COMPUTE_SOURCE: &[u8; 26] = b"api.vulkan.compute.source\0";
pub const SPA_NAME_API_VULKAN_COMPUTE_FILTER: &[u8; 26] = b"api.vulkan.compute.filter\0";
pub const SPA_NAME_API_VULKAN_BLIT_FILTER: &[u8; 23] = b"api.vulkan.blit.filter\0";
pub const SPA_NAME_API_VULKAN_BLIT_DSP_FILTER: &[u8; 27] = b"api.vulkan.blit.dsp-filter\0";
pub const SPA_ASYNC_BIT: u32 = 1073741824;
pub const SPA_ASYNC_SEQ_MASK: u32 = 1073741823;
pub const SPA_ASYNC_MASK: i32 = -1073741824;
pub type __off_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type off_t = __off_t;
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __gnuc_va_list;
pub const SPA_DIRECTION_INPUT: spa_direction = 0;
pub const SPA_DIRECTION_OUTPUT: spa_direction = 1;
pub type spa_direction = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_rectangle {
    pub width: u32,
    pub height: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_rectangle"][::std::mem::size_of::<spa_rectangle>() - 8usize];
    ["Alignment of spa_rectangle"][::std::mem::align_of::<spa_rectangle>() - 4usize];
    ["Offset of field: spa_rectangle::width"]
        [::std::mem::offset_of!(spa_rectangle, width) - 0usize];
    ["Offset of field: spa_rectangle::height"]
        [::std::mem::offset_of!(spa_rectangle, height) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_point {
    pub x: i32,
    pub y: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_point"][::std::mem::size_of::<spa_point>() - 8usize];
    ["Alignment of spa_point"][::std::mem::align_of::<spa_point>() - 4usize];
    ["Offset of field: spa_point::x"][::std::mem::offset_of!(spa_point, x) - 0usize];
    ["Offset of field: spa_point::y"][::std::mem::offset_of!(spa_point, y) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_region {
    pub position: spa_point,
    pub size: spa_rectangle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_region"][::std::mem::size_of::<spa_region>() - 16usize];
    ["Alignment of spa_region"][::std::mem::align_of::<spa_region>() - 4usize];
    ["Offset of field: spa_region::position"]
        [::std::mem::offset_of!(spa_region, position) - 0usize];
    ["Offset of field: spa_region::size"][::std::mem::offset_of!(spa_region, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_fraction {
    pub num: u32,
    pub denom: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_fraction"][::std::mem::size_of::<spa_fraction>() - 8usize];
    ["Alignment of spa_fraction"][::std::mem::align_of::<spa_fraction>() - 4usize];
    ["Offset of field: spa_fraction::num"][::std::mem::offset_of!(spa_fraction, num) - 0usize];
    ["Offset of field: spa_fraction::denom"][::std::mem::offset_of!(spa_fraction, denom) - 4usize];
};
unsafe extern "C" {
    #[link_name = "spa_ptrinside_libspa_rs"]
    pub fn spa_ptrinside(
        p1: *const ::std::os::raw::c_void,
        s1: usize,
        p2: *const ::std::os::raw::c_void,
        s2: usize,
        remaining: *mut usize,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_ptr_inside_and_aligned_libspa_rs"]
    pub fn spa_ptr_inside_and_aligned(
        p1: *const ::std::os::raw::c_void,
        s1: usize,
        p2: *const ::std::os::raw::c_void,
        s2: usize,
        align: usize,
        remaining: *mut usize,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_error_location {
    pub line: ::std::os::raw::c_int,
    pub col: ::std::os::raw::c_int,
    pub len: usize,
    pub location: *const ::std::os::raw::c_char,
    pub reason: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_error_location"][::std::mem::size_of::<spa_error_location>() - 32usize];
    ["Alignment of spa_error_location"][::std::mem::align_of::<spa_error_location>() - 8usize];
    ["Offset of field: spa_error_location::line"]
        [::std::mem::offset_of!(spa_error_location, line) - 0usize];
    ["Offset of field: spa_error_location::col"]
        [::std::mem::offset_of!(spa_error_location, col) - 4usize];
    ["Offset of field: spa_error_location::len"]
        [::std::mem::offset_of!(spa_error_location, len) - 8usize];
    ["Offset of field: spa_error_location::location"]
        [::std::mem::offset_of!(spa_error_location, location) - 16usize];
    ["Offset of field: spa_error_location::reason"]
        [::std::mem::offset_of!(spa_error_location, reason) - 24usize];
};
unsafe extern "C" {
    #[doc = " \\return true if the two strings are equal, false otherwise\n\n If both \\a a and \\a b are NULL, the two are considered equal.\n"]
    #[link_name = "spa_streq_libspa_rs"]
    pub fn spa_streq(s1: *const ::std::os::raw::c_char, s2: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " \\return true if the two strings are equal, false otherwise\n\n If both \\a a and \\a b are NULL, the two are considered equal."]
    #[link_name = "spa_strneq_libspa_rs"]
    pub fn spa_strneq(
        s1: *const ::std::os::raw::c_char,
        s2: *const ::std::os::raw::c_char,
        len: usize,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " \\return true if \\a s starts with the \\a prefix or false otherwise.\n A \\a s is NULL, it never starts with the given \\a prefix. A \\a prefix of\n NULL is a bug in the caller."]
    #[link_name = "spa_strstartswith_libspa_rs"]
    pub fn spa_strstartswith(
        s: *const ::std::os::raw::c_char,
        prefix: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " \\return true if \\a s ends with the \\a suffix or false otherwise.\n A \\a s is NULL, it never ends with the given \\a suffix. A \\a suffix of\n NULL is a bug in the caller."]
    #[link_name = "spa_strendswith_libspa_rs"]
    pub fn spa_strendswith(
        s: *const ::std::os::raw::c_char,
        suffix: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to an int32_t with the given \\a base and store the\n result in \\a val.\n\n On failure, the value of \\a val is unmodified.\n\n \\return true on success, false otherwise"]
    #[link_name = "spa_atoi32_libspa_rs"]
    pub fn spa_atoi32(
        str_: *const ::std::os::raw::c_char,
        val: *mut i32,
        base: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to an uint32_t with the given \\a base and store the\n result in \\a val.\n\n On failure, the value of \\a val is unmodified.\n\n \\return true on success, false otherwise"]
    #[link_name = "spa_atou32_libspa_rs"]
    pub fn spa_atou32(
        str_: *const ::std::os::raw::c_char,
        val: *mut u32,
        base: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to an int64_t with the given \\a base and store the\n result in \\a val.\n\n On failure, the value of \\a val is unmodified.\n\n \\return true on success, false otherwise"]
    #[link_name = "spa_atoi64_libspa_rs"]
    pub fn spa_atoi64(
        str_: *const ::std::os::raw::c_char,
        val: *mut i64,
        base: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to an uint64_t with the given \\a base and store the\n result in \\a val.\n\n On failure, the value of \\a val is unmodified.\n\n \\return true on success, false otherwise"]
    #[link_name = "spa_atou64_libspa_rs"]
    pub fn spa_atou64(
        str_: *const ::std::os::raw::c_char,
        val: *mut u64,
        base: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to a boolean. Allowed boolean values are \"true\" and a\n literal \"1\", anything else is false.\n\n \\return true on success, false otherwise"]
    #[link_name = "spa_atob_libspa_rs"]
    pub fn spa_atob(str_: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " \"Safe\" version of vsnprintf. Exactly the same as vsnprintf but the\n returned value is clipped to `size - 1` and a negative or zero size\n will abort() the program.\n\n \\return The number of bytes printed, capped to `size-1`, or a negative\n number on error."]
    #[link_name = "spa_vscnprintf_libspa_rs"]
    pub fn spa_vscnprintf(
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to a float in the C locale.\n\n If \\a endptr is not NULL, a pointer to the character after the last character\n used in the conversion is stored in the location referenced by endptr.\n\n \\return the result float."]
    #[link_name = "spa_strtof_libspa_rs"]
    pub fn spa_strtof(
        str_: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to a float and store the result in \\a val.\n\n On failure, the value of \\a val is unmodified.\n\n \\return true on success, false otherwise"]
    #[link_name = "spa_atof_libspa_rs"]
    pub fn spa_atof(str_: *const ::std::os::raw::c_char, val: *mut f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to a double in the C locale.\n\n If \\a endptr is not NULL, a pointer to the character after the last character\n used in the conversion is stored in the location referenced by endptr.\n\n \\return the result float."]
    #[link_name = "spa_strtod_libspa_rs"]
    pub fn spa_strtod(
        str_: *const ::std::os::raw::c_char,
        endptr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
unsafe extern "C" {
    #[doc = " Convert \\a str to a double and store the result in \\a val.\n\n On failure, the value of \\a val is unmodified.\n\n \\return true on success, false otherwise"]
    #[link_name = "spa_atod_libspa_rs"]
    pub fn spa_atod(str_: *const ::std::os::raw::c_char, val: *mut f64) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_dtoa_libspa_rs"]
    pub fn spa_dtoa(
        str_: *mut ::std::os::raw::c_char,
        size: usize,
        val: f64,
    ) -> *mut ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_strbuf {
    pub buffer: *mut ::std::os::raw::c_char,
    pub maxsize: usize,
    pub pos: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_strbuf"][::std::mem::size_of::<spa_strbuf>() - 24usize];
    ["Alignment of spa_strbuf"][::std::mem::align_of::<spa_strbuf>() - 8usize];
    ["Offset of field: spa_strbuf::buffer"][::std::mem::offset_of!(spa_strbuf, buffer) - 0usize];
    ["Offset of field: spa_strbuf::maxsize"][::std::mem::offset_of!(spa_strbuf, maxsize) - 8usize];
    ["Offset of field: spa_strbuf::pos"][::std::mem::offset_of!(spa_strbuf, pos) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_strbuf_init_libspa_rs"]
    pub fn spa_strbuf_init(
        buf: *mut spa_strbuf,
        buffer: *mut ::std::os::raw::c_char,
        maxsize: usize,
    );
}
pub const SPA_TYPE_START: _bindgen_ty_10 = 0;
pub const SPA_TYPE_None: _bindgen_ty_10 = 1;
pub const SPA_TYPE_Bool: _bindgen_ty_10 = 2;
pub const SPA_TYPE_Id: _bindgen_ty_10 = 3;
pub const SPA_TYPE_Int: _bindgen_ty_10 = 4;
pub const SPA_TYPE_Long: _bindgen_ty_10 = 5;
pub const SPA_TYPE_Float: _bindgen_ty_10 = 6;
pub const SPA_TYPE_Double: _bindgen_ty_10 = 7;
pub const SPA_TYPE_String: _bindgen_ty_10 = 8;
pub const SPA_TYPE_Bytes: _bindgen_ty_10 = 9;
pub const SPA_TYPE_Rectangle: _bindgen_ty_10 = 10;
pub const SPA_TYPE_Fraction: _bindgen_ty_10 = 11;
pub const SPA_TYPE_Bitmap: _bindgen_ty_10 = 12;
pub const SPA_TYPE_Array: _bindgen_ty_10 = 13;
pub const SPA_TYPE_Struct: _bindgen_ty_10 = 14;
pub const SPA_TYPE_Object: _bindgen_ty_10 = 15;
pub const SPA_TYPE_Sequence: _bindgen_ty_10 = 16;
pub const SPA_TYPE_Pointer: _bindgen_ty_10 = 17;
pub const SPA_TYPE_Fd: _bindgen_ty_10 = 18;
pub const SPA_TYPE_Choice: _bindgen_ty_10 = 19;
pub const SPA_TYPE_Pod: _bindgen_ty_10 = 20;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_LAST: _bindgen_ty_10 = 21;
pub const SPA_TYPE_POINTER_START: _bindgen_ty_10 = 65536;
pub const SPA_TYPE_POINTER_Buffer: _bindgen_ty_10 = 65537;
pub const SPA_TYPE_POINTER_Meta: _bindgen_ty_10 = 65538;
pub const SPA_TYPE_POINTER_Dict: _bindgen_ty_10 = 65539;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_POINTER_LAST: _bindgen_ty_10 = 65540;
pub const SPA_TYPE_EVENT_START: _bindgen_ty_10 = 131072;
pub const SPA_TYPE_EVENT_Device: _bindgen_ty_10 = 131073;
pub const SPA_TYPE_EVENT_Node: _bindgen_ty_10 = 131074;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_EVENT_LAST: _bindgen_ty_10 = 131075;
pub const SPA_TYPE_COMMAND_START: _bindgen_ty_10 = 196608;
pub const SPA_TYPE_COMMAND_Device: _bindgen_ty_10 = 196609;
pub const SPA_TYPE_COMMAND_Node: _bindgen_ty_10 = 196610;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_COMMAND_LAST: _bindgen_ty_10 = 196611;
pub const SPA_TYPE_OBJECT_START: _bindgen_ty_10 = 262144;
pub const SPA_TYPE_OBJECT_PropInfo: _bindgen_ty_10 = 262145;
pub const SPA_TYPE_OBJECT_Props: _bindgen_ty_10 = 262146;
pub const SPA_TYPE_OBJECT_Format: _bindgen_ty_10 = 262147;
pub const SPA_TYPE_OBJECT_ParamBuffers: _bindgen_ty_10 = 262148;
pub const SPA_TYPE_OBJECT_ParamMeta: _bindgen_ty_10 = 262149;
pub const SPA_TYPE_OBJECT_ParamIO: _bindgen_ty_10 = 262150;
pub const SPA_TYPE_OBJECT_ParamProfile: _bindgen_ty_10 = 262151;
pub const SPA_TYPE_OBJECT_ParamPortConfig: _bindgen_ty_10 = 262152;
pub const SPA_TYPE_OBJECT_ParamRoute: _bindgen_ty_10 = 262153;
pub const SPA_TYPE_OBJECT_Profiler: _bindgen_ty_10 = 262154;
pub const SPA_TYPE_OBJECT_ParamLatency: _bindgen_ty_10 = 262155;
pub const SPA_TYPE_OBJECT_ParamProcessLatency: _bindgen_ty_10 = 262156;
pub const SPA_TYPE_OBJECT_ParamTag: _bindgen_ty_10 = 262157;
#[doc = "< not part of ABI"]
pub const _SPA_TYPE_OBJECT_LAST: _bindgen_ty_10 = 262158;
pub const SPA_TYPE_VENDOR_PipeWire: _bindgen_ty_10 = 33554432;
pub const SPA_TYPE_VENDOR_Other: _bindgen_ty_10 = 2130706432;
#[doc = " \\addtogroup spa_types\n \\{"]
pub type _bindgen_ty_10 = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_type_info {
    pub type_: u32,
    pub parent: u32,
    pub name: *const ::std::os::raw::c_char,
    pub values: *const spa_type_info,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_type_info"][::std::mem::size_of::<spa_type_info>() - 24usize];
    ["Alignment of spa_type_info"][::std::mem::align_of::<spa_type_info>() - 8usize];
    ["Offset of field: spa_type_info::type_"]
        [::std::mem::offset_of!(spa_type_info, type_) - 0usize];
    ["Offset of field: spa_type_info::parent"]
        [::std::mem::offset_of!(spa_type_info, parent) - 4usize];
    ["Offset of field: spa_type_info::name"][::std::mem::offset_of!(spa_type_info, name) - 8usize];
    ["Offset of field: spa_type_info::values"]
        [::std::mem::offset_of!(spa_type_info, values) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_type_is_a_libspa_rs"]
    pub fn spa_type_is_a(
        type_: *const ::std::os::raw::c_char,
        parent: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_type_short_name_libspa_rs"]
    pub fn spa_type_short_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_type_from_short_name_libspa_rs"]
    pub fn spa_type_from_short_name(
        name: *const ::std::os::raw::c_char,
        info: *const spa_type_info,
        unknown: u32,
    ) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_type_to_name_libspa_rs"]
    pub fn spa_type_to_name(
        type_: u32,
        info: *const spa_type_info,
        unknown: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_type_to_short_name_libspa_rs"]
    pub fn spa_type_to_short_name(
        type_: u32,
        info: *const spa_type_info,
        unknown: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod {
    pub size: u32,
    pub type_: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod"][::std::mem::size_of::<spa_pod>() - 8usize];
    ["Alignment of spa_pod"][::std::mem::align_of::<spa_pod>() - 4usize];
    ["Offset of field: spa_pod::size"][::std::mem::offset_of!(spa_pod, size) - 0usize];
    ["Offset of field: spa_pod::type_"][::std::mem::offset_of!(spa_pod, type_) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_bool {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bool"][::std::mem::size_of::<spa_pod_bool>() - 16usize];
    ["Alignment of spa_pod_bool"][::std::mem::align_of::<spa_pod_bool>() - 4usize];
    ["Offset of field: spa_pod_bool::pod"][::std::mem::offset_of!(spa_pod_bool, pod) - 0usize];
    ["Offset of field: spa_pod_bool::value"][::std::mem::offset_of!(spa_pod_bool, value) - 8usize];
    ["Offset of field: spa_pod_bool::_padding"]
        [::std::mem::offset_of!(spa_pod_bool, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_id {
    pub pod: spa_pod,
    pub value: u32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_id"][::std::mem::size_of::<spa_pod_id>() - 16usize];
    ["Alignment of spa_pod_id"][::std::mem::align_of::<spa_pod_id>() - 4usize];
    ["Offset of field: spa_pod_id::pod"][::std::mem::offset_of!(spa_pod_id, pod) - 0usize];
    ["Offset of field: spa_pod_id::value"][::std::mem::offset_of!(spa_pod_id, value) - 8usize];
    ["Offset of field: spa_pod_id::_padding"]
        [::std::mem::offset_of!(spa_pod_id, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_int {
    pub pod: spa_pod,
    pub value: i32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_int"][::std::mem::size_of::<spa_pod_int>() - 16usize];
    ["Alignment of spa_pod_int"][::std::mem::align_of::<spa_pod_int>() - 4usize];
    ["Offset of field: spa_pod_int::pod"][::std::mem::offset_of!(spa_pod_int, pod) - 0usize];
    ["Offset of field: spa_pod_int::value"][::std::mem::offset_of!(spa_pod_int, value) - 8usize];
    ["Offset of field: spa_pod_int::_padding"]
        [::std::mem::offset_of!(spa_pod_int, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_long {
    pub pod: spa_pod,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_long"][::std::mem::size_of::<spa_pod_long>() - 16usize];
    ["Alignment of spa_pod_long"][::std::mem::align_of::<spa_pod_long>() - 8usize];
    ["Offset of field: spa_pod_long::pod"][::std::mem::offset_of!(spa_pod_long, pod) - 0usize];
    ["Offset of field: spa_pod_long::value"][::std::mem::offset_of!(spa_pod_long, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_pod_float {
    pub pod: spa_pod,
    pub value: f32,
    pub _padding: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_float"][::std::mem::size_of::<spa_pod_float>() - 16usize];
    ["Alignment of spa_pod_float"][::std::mem::align_of::<spa_pod_float>() - 4usize];
    ["Offset of field: spa_pod_float::pod"][::std::mem::offset_of!(spa_pod_float, pod) - 0usize];
    ["Offset of field: spa_pod_float::value"]
        [::std::mem::offset_of!(spa_pod_float, value) - 8usize];
    ["Offset of field: spa_pod_float::_padding"]
        [::std::mem::offset_of!(spa_pod_float, _padding) - 12usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_pod_double {
    pub pod: spa_pod,
    pub value: f64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_double"][::std::mem::size_of::<spa_pod_double>() - 16usize];
    ["Alignment of spa_pod_double"][::std::mem::align_of::<spa_pod_double>() - 8usize];
    ["Offset of field: spa_pod_double::pod"][::std::mem::offset_of!(spa_pod_double, pod) - 0usize];
    ["Offset of field: spa_pod_double::value"]
        [::std::mem::offset_of!(spa_pod_double, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_string {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_string"][::std::mem::size_of::<spa_pod_string>() - 8usize];
    ["Alignment of spa_pod_string"][::std::mem::align_of::<spa_pod_string>() - 4usize];
    ["Offset of field: spa_pod_string::pod"][::std::mem::offset_of!(spa_pod_string, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_bytes {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bytes"][::std::mem::size_of::<spa_pod_bytes>() - 8usize];
    ["Alignment of spa_pod_bytes"][::std::mem::align_of::<spa_pod_bytes>() - 4usize];
    ["Offset of field: spa_pod_bytes::pod"][::std::mem::offset_of!(spa_pod_bytes, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_rectangle {
    pub pod: spa_pod,
    pub value: spa_rectangle,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_rectangle"][::std::mem::size_of::<spa_pod_rectangle>() - 16usize];
    ["Alignment of spa_pod_rectangle"][::std::mem::align_of::<spa_pod_rectangle>() - 4usize];
    ["Offset of field: spa_pod_rectangle::pod"]
        [::std::mem::offset_of!(spa_pod_rectangle, pod) - 0usize];
    ["Offset of field: spa_pod_rectangle::value"]
        [::std::mem::offset_of!(spa_pod_rectangle, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_fraction {
    pub pod: spa_pod,
    pub value: spa_fraction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_fraction"][::std::mem::size_of::<spa_pod_fraction>() - 16usize];
    ["Alignment of spa_pod_fraction"][::std::mem::align_of::<spa_pod_fraction>() - 4usize];
    ["Offset of field: spa_pod_fraction::pod"]
        [::std::mem::offset_of!(spa_pod_fraction, pod) - 0usize];
    ["Offset of field: spa_pod_fraction::value"]
        [::std::mem::offset_of!(spa_pod_fraction, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_bitmap {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_bitmap"][::std::mem::size_of::<spa_pod_bitmap>() - 8usize];
    ["Alignment of spa_pod_bitmap"][::std::mem::align_of::<spa_pod_bitmap>() - 4usize];
    ["Offset of field: spa_pod_bitmap::pod"][::std::mem::offset_of!(spa_pod_bitmap, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_array_body {
    pub child: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_array_body"][::std::mem::size_of::<spa_pod_array_body>() - 8usize];
    ["Alignment of spa_pod_array_body"][::std::mem::align_of::<spa_pod_array_body>() - 4usize];
    ["Offset of field: spa_pod_array_body::child"]
        [::std::mem::offset_of!(spa_pod_array_body, child) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_array {
    pub pod: spa_pod,
    pub body: spa_pod_array_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_array"][::std::mem::size_of::<spa_pod_array>() - 16usize];
    ["Alignment of spa_pod_array"][::std::mem::align_of::<spa_pod_array>() - 4usize];
    ["Offset of field: spa_pod_array::pod"][::std::mem::offset_of!(spa_pod_array, pod) - 0usize];
    ["Offset of field: spa_pod_array::body"][::std::mem::offset_of!(spa_pod_array, body) - 8usize];
};
#[doc = "< no choice, first value is current"]
pub const SPA_CHOICE_None: spa_choice_type = 0;
#[doc = "< range: default, min, max"]
pub const SPA_CHOICE_Range: spa_choice_type = 1;
#[doc = "< range with step: default, min, max, step"]
pub const SPA_CHOICE_Step: spa_choice_type = 2;
#[doc = "< list: default, alternative,..."]
pub const SPA_CHOICE_Enum: spa_choice_type = 3;
#[doc = "< flags: default, possible flags,..."]
pub const SPA_CHOICE_Flags: spa_choice_type = 4;
pub type spa_choice_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_choice_body {
    #[doc = "< type of choice, one of enum spa_choice_type"]
    pub type_: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    pub child: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_choice_body"][::std::mem::size_of::<spa_pod_choice_body>() - 16usize];
    ["Alignment of spa_pod_choice_body"][::std::mem::align_of::<spa_pod_choice_body>() - 4usize];
    ["Offset of field: spa_pod_choice_body::type_"]
        [::std::mem::offset_of!(spa_pod_choice_body, type_) - 0usize];
    ["Offset of field: spa_pod_choice_body::flags"]
        [::std::mem::offset_of!(spa_pod_choice_body, flags) - 4usize];
    ["Offset of field: spa_pod_choice_body::child"]
        [::std::mem::offset_of!(spa_pod_choice_body, child) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_choice {
    pub pod: spa_pod,
    pub body: spa_pod_choice_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_choice"][::std::mem::size_of::<spa_pod_choice>() - 24usize];
    ["Alignment of spa_pod_choice"][::std::mem::align_of::<spa_pod_choice>() - 4usize];
    ["Offset of field: spa_pod_choice::pod"][::std::mem::offset_of!(spa_pod_choice, pod) - 0usize];
    ["Offset of field: spa_pod_choice::body"]
        [::std::mem::offset_of!(spa_pod_choice, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_struct {
    pub pod: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_struct"][::std::mem::size_of::<spa_pod_struct>() - 8usize];
    ["Alignment of spa_pod_struct"][::std::mem::align_of::<spa_pod_struct>() - 4usize];
    ["Offset of field: spa_pod_struct::pod"][::std::mem::offset_of!(spa_pod_struct, pod) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_object_body {
    #[doc = "< one of enum spa_type"]
    pub type_: u32,
    #[doc = "< id of the object, depends on the object type"]
    pub id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_object_body"][::std::mem::size_of::<spa_pod_object_body>() - 8usize];
    ["Alignment of spa_pod_object_body"][::std::mem::align_of::<spa_pod_object_body>() - 4usize];
    ["Offset of field: spa_pod_object_body::type_"]
        [::std::mem::offset_of!(spa_pod_object_body, type_) - 0usize];
    ["Offset of field: spa_pod_object_body::id"]
        [::std::mem::offset_of!(spa_pod_object_body, id) - 4usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_object {
    pub pod: spa_pod,
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_object"][::std::mem::size_of::<spa_pod_object>() - 16usize];
    ["Alignment of spa_pod_object"][::std::mem::align_of::<spa_pod_object>() - 4usize];
    ["Offset of field: spa_pod_object::pod"][::std::mem::offset_of!(spa_pod_object, pod) - 0usize];
    ["Offset of field: spa_pod_object::body"]
        [::std::mem::offset_of!(spa_pod_object, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_pointer_body {
    #[doc = "< pointer id, one of enum spa_type"]
    pub type_: u32,
    pub _padding: u32,
    pub value: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_pointer_body"][::std::mem::size_of::<spa_pod_pointer_body>() - 16usize];
    ["Alignment of spa_pod_pointer_body"][::std::mem::align_of::<spa_pod_pointer_body>() - 8usize];
    ["Offset of field: spa_pod_pointer_body::type_"]
        [::std::mem::offset_of!(spa_pod_pointer_body, type_) - 0usize];
    ["Offset of field: spa_pod_pointer_body::_padding"]
        [::std::mem::offset_of!(spa_pod_pointer_body, _padding) - 4usize];
    ["Offset of field: spa_pod_pointer_body::value"]
        [::std::mem::offset_of!(spa_pod_pointer_body, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_pointer {
    pub pod: spa_pod,
    pub body: spa_pod_pointer_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_pointer"][::std::mem::size_of::<spa_pod_pointer>() - 24usize];
    ["Alignment of spa_pod_pointer"][::std::mem::align_of::<spa_pod_pointer>() - 8usize];
    ["Offset of field: spa_pod_pointer::pod"]
        [::std::mem::offset_of!(spa_pod_pointer, pod) - 0usize];
    ["Offset of field: spa_pod_pointer::body"]
        [::std::mem::offset_of!(spa_pod_pointer, body) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_fd {
    pub pod: spa_pod,
    pub value: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_fd"][::std::mem::size_of::<spa_pod_fd>() - 16usize];
    ["Alignment of spa_pod_fd"][::std::mem::align_of::<spa_pod_fd>() - 8usize];
    ["Offset of field: spa_pod_fd::pod"][::std::mem::offset_of!(spa_pod_fd, pod) - 0usize];
    ["Offset of field: spa_pod_fd::value"][::std::mem::offset_of!(spa_pod_fd, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_prop {
    #[doc = "< key of property, list of valid keys depends on the\n  object type"]
    pub key: u32,
    #[doc = "< flags for property"]
    pub flags: u32,
    pub value: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_prop"][::std::mem::size_of::<spa_pod_prop>() - 16usize];
    ["Alignment of spa_pod_prop"][::std::mem::align_of::<spa_pod_prop>() - 4usize];
    ["Offset of field: spa_pod_prop::key"][::std::mem::offset_of!(spa_pod_prop, key) - 0usize];
    ["Offset of field: spa_pod_prop::flags"][::std::mem::offset_of!(spa_pod_prop, flags) - 4usize];
    ["Offset of field: spa_pod_prop::value"][::std::mem::offset_of!(spa_pod_prop, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_control {
    #[doc = "< media offset"]
    pub offset: u32,
    #[doc = "< type of control, enum spa_control_type"]
    pub type_: u32,
    #[doc = "< control value, depends on type"]
    pub value: spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_control"][::std::mem::size_of::<spa_pod_control>() - 16usize];
    ["Alignment of spa_pod_control"][::std::mem::align_of::<spa_pod_control>() - 4usize];
    ["Offset of field: spa_pod_control::offset"]
        [::std::mem::offset_of!(spa_pod_control, offset) - 0usize];
    ["Offset of field: spa_pod_control::type_"]
        [::std::mem::offset_of!(spa_pod_control, type_) - 4usize];
    ["Offset of field: spa_pod_control::value"]
        [::std::mem::offset_of!(spa_pod_control, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_sequence_body {
    pub unit: u32,
    pub pad: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_sequence_body"][::std::mem::size_of::<spa_pod_sequence_body>() - 8usize];
    ["Alignment of spa_pod_sequence_body"]
        [::std::mem::align_of::<spa_pod_sequence_body>() - 4usize];
    ["Offset of field: spa_pod_sequence_body::unit"]
        [::std::mem::offset_of!(spa_pod_sequence_body, unit) - 0usize];
    ["Offset of field: spa_pod_sequence_body::pad"]
        [::std::mem::offset_of!(spa_pod_sequence_body, pad) - 4usize];
};
#[doc = " a sequence of timed controls"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_sequence {
    pub pod: spa_pod,
    pub body: spa_pod_sequence_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_sequence"][::std::mem::size_of::<spa_pod_sequence>() - 16usize];
    ["Alignment of spa_pod_sequence"][::std::mem::align_of::<spa_pod_sequence>() - 4usize];
    ["Offset of field: spa_pod_sequence::pod"]
        [::std::mem::offset_of!(spa_pod_sequence, pod) - 0usize];
    ["Offset of field: spa_pod_sequence::body"]
        [::std::mem::offset_of!(spa_pod_sequence, body) - 8usize];
};
pub const SPA_META_Invalid: spa_meta_type = 0;
#[doc = "< struct spa_meta_header"]
pub const SPA_META_Header: spa_meta_type = 1;
#[doc = "< struct spa_meta_region with cropping data"]
pub const SPA_META_VideoCrop: spa_meta_type = 2;
#[doc = "< array of struct spa_meta_region with damage, where an invalid entry or end-of-array marks the end."]
pub const SPA_META_VideoDamage: spa_meta_type = 3;
#[doc = "< struct spa_meta_bitmap"]
pub const SPA_META_Bitmap: spa_meta_type = 4;
#[doc = "< struct spa_meta_cursor"]
pub const SPA_META_Cursor: spa_meta_type = 5;
#[doc = "< metadata contains a spa_meta_control\n  associated with the data"]
pub const SPA_META_Control: spa_meta_type = 6;
#[doc = "< don't write to buffer when count > 0"]
pub const SPA_META_Busy: spa_meta_type = 7;
#[doc = "< struct spa_meta_transform"]
pub const SPA_META_VideoTransform: spa_meta_type = 8;
#[doc = "< struct spa_meta_sync_timeline"]
pub const SPA_META_SyncTimeline: spa_meta_type = 9;
#[doc = "< not part of ABI/API"]
pub const _SPA_META_LAST: spa_meta_type = 10;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_meta_type = ::std::os::raw::c_uint;
#[doc = " A metadata element.\n\n This structure is available on the buffer structure and contains\n the type of the metadata and a pointer/size to the actual metadata\n itself."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta {
    #[doc = "< metadata type, one of enum spa_meta_type"]
    pub type_: u32,
    #[doc = "< size of metadata"]
    pub size: u32,
    #[doc = "< pointer to metadata"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta"][::std::mem::size_of::<spa_meta>() - 16usize];
    ["Alignment of spa_meta"][::std::mem::align_of::<spa_meta>() - 8usize];
    ["Offset of field: spa_meta::type_"][::std::mem::offset_of!(spa_meta, type_) - 0usize];
    ["Offset of field: spa_meta::size"][::std::mem::offset_of!(spa_meta, size) - 4usize];
    ["Offset of field: spa_meta::data"][::std::mem::offset_of!(spa_meta, data) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_meta_first_libspa_rs"]
    pub fn spa_meta_first(m: *const spa_meta) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "spa_meta_end_libspa_rs"]
    pub fn spa_meta_end(m: *const spa_meta) -> *mut ::std::os::raw::c_void;
}
#[doc = " Describes essential buffer header metadata such as flags and\n timestamps."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_header {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in current cycle"]
    pub offset: u32,
    #[doc = "< presentation timestamp in nanoseconds"]
    pub pts: i64,
    #[doc = "< decoding timestamp as a difference with pts"]
    pub dts_offset: i64,
    #[doc = "< sequence number, increments with a\n  media specific frequency"]
    pub seq: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_header"][::std::mem::size_of::<spa_meta_header>() - 32usize];
    ["Alignment of spa_meta_header"][::std::mem::align_of::<spa_meta_header>() - 8usize];
    ["Offset of field: spa_meta_header::flags"]
        [::std::mem::offset_of!(spa_meta_header, flags) - 0usize];
    ["Offset of field: spa_meta_header::offset"]
        [::std::mem::offset_of!(spa_meta_header, offset) - 4usize];
    ["Offset of field: spa_meta_header::pts"]
        [::std::mem::offset_of!(spa_meta_header, pts) - 8usize];
    ["Offset of field: spa_meta_header::dts_offset"]
        [::std::mem::offset_of!(spa_meta_header, dts_offset) - 16usize];
    ["Offset of field: spa_meta_header::seq"]
        [::std::mem::offset_of!(spa_meta_header, seq) - 24usize];
};
#[doc = " metadata structure for Region or an array of these for RegionArray"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_region {
    pub region: spa_region,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_region"][::std::mem::size_of::<spa_meta_region>() - 16usize];
    ["Alignment of spa_meta_region"][::std::mem::align_of::<spa_meta_region>() - 4usize];
    ["Offset of field: spa_meta_region::region"]
        [::std::mem::offset_of!(spa_meta_region, region) - 0usize];
};
unsafe extern "C" {
    #[link_name = "spa_meta_region_is_valid_libspa_rs"]
    pub fn spa_meta_region_is_valid(m: *const spa_meta_region) -> bool;
}
#[doc = " Bitmap information\n\n This metadata contains a bitmap image in the given format and size.\n It is typically used for cursor images or other small images that are\n better transferred inline."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_bitmap {
    #[doc = "< bitmap video format, one of enum spa_video_format. 0 is\n  and invalid format and should be handled as if there is\n  no new bitmap information."]
    pub format: u32,
    #[doc = "< width and height of bitmap"]
    pub size: spa_rectangle,
    #[doc = "< stride of bitmap data"]
    pub stride: i32,
    #[doc = "< offset of bitmap data in this structure. An offset of\n  0 means no image data (invisible), an offset >=\n  sizeof(struct spa_meta_bitmap) contains valid bitmap\n  info."]
    pub offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_bitmap"][::std::mem::size_of::<spa_meta_bitmap>() - 20usize];
    ["Alignment of spa_meta_bitmap"][::std::mem::align_of::<spa_meta_bitmap>() - 4usize];
    ["Offset of field: spa_meta_bitmap::format"]
        [::std::mem::offset_of!(spa_meta_bitmap, format) - 0usize];
    ["Offset of field: spa_meta_bitmap::size"]
        [::std::mem::offset_of!(spa_meta_bitmap, size) - 4usize];
    ["Offset of field: spa_meta_bitmap::stride"]
        [::std::mem::offset_of!(spa_meta_bitmap, stride) - 12usize];
    ["Offset of field: spa_meta_bitmap::offset"]
        [::std::mem::offset_of!(spa_meta_bitmap, offset) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_meta_bitmap_is_valid_libspa_rs"]
    pub fn spa_meta_bitmap_is_valid(m: *const spa_meta_bitmap) -> bool;
}
#[doc = " Cursor information\n\n Metadata to describe the position and appearance of a pointing device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_cursor {
    #[doc = "< cursor id. an id of 0 is an invalid id and means that\n  there is no new cursor data"]
    pub id: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< position on screen"]
    pub position: spa_point,
    #[doc = "< offsets for hotspot in bitmap, this field has no meaning\n  when there is no valid bitmap (see below)"]
    pub hotspot: spa_point,
    #[doc = "< offset of bitmap meta in this structure. When the offset\n  is 0, there is no new bitmap information. When the offset is\n  >= sizeof(struct spa_meta_cursor) there is a\n  struct spa_meta_bitmap at the offset."]
    pub bitmap_offset: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_cursor"][::std::mem::size_of::<spa_meta_cursor>() - 28usize];
    ["Alignment of spa_meta_cursor"][::std::mem::align_of::<spa_meta_cursor>() - 4usize];
    ["Offset of field: spa_meta_cursor::id"][::std::mem::offset_of!(spa_meta_cursor, id) - 0usize];
    ["Offset of field: spa_meta_cursor::flags"]
        [::std::mem::offset_of!(spa_meta_cursor, flags) - 4usize];
    ["Offset of field: spa_meta_cursor::position"]
        [::std::mem::offset_of!(spa_meta_cursor, position) - 8usize];
    ["Offset of field: spa_meta_cursor::hotspot"]
        [::std::mem::offset_of!(spa_meta_cursor, hotspot) - 16usize];
    ["Offset of field: spa_meta_cursor::bitmap_offset"]
        [::std::mem::offset_of!(spa_meta_cursor, bitmap_offset) - 24usize];
};
unsafe extern "C" {
    #[link_name = "spa_meta_cursor_is_valid_libspa_rs"]
    pub fn spa_meta_cursor_is_valid(m: *const spa_meta_cursor) -> bool;
}
#[doc = " a timed set of events associated with the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_control {
    pub sequence: spa_pod_sequence,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_control"][::std::mem::size_of::<spa_meta_control>() - 16usize];
    ["Alignment of spa_meta_control"][::std::mem::align_of::<spa_meta_control>() - 4usize];
    ["Offset of field: spa_meta_control::sequence"]
        [::std::mem::offset_of!(spa_meta_control, sequence) - 0usize];
};
#[doc = " a busy counter for the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_busy {
    pub flags: u32,
    #[doc = "< number of users busy with the buffer"]
    pub count: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_busy"][::std::mem::size_of::<spa_meta_busy>() - 8usize];
    ["Alignment of spa_meta_busy"][::std::mem::align_of::<spa_meta_busy>() - 4usize];
    ["Offset of field: spa_meta_busy::flags"]
        [::std::mem::offset_of!(spa_meta_busy, flags) - 0usize];
    ["Offset of field: spa_meta_busy::count"]
        [::std::mem::offset_of!(spa_meta_busy, count) - 4usize];
};
#[doc = "< no transform"]
pub const SPA_META_TRANSFORMATION_None: spa_meta_videotransform_value = 0;
#[doc = "< 90 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_90: spa_meta_videotransform_value = 1;
#[doc = "< 180 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_180: spa_meta_videotransform_value = 2;
#[doc = "< 270 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_270: spa_meta_videotransform_value = 3;
#[doc = "< 180 degree flipped around the vertical axis. Equivalent\n to a reflexion through the vertical line splitting the\n buffer in two equal sized parts"]
pub const SPA_META_TRANSFORMATION_Flipped: spa_meta_videotransform_value = 4;
#[doc = "< flip then rotate around 90 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_Flipped90: spa_meta_videotransform_value = 5;
#[doc = "< flip then rotate around 180 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_Flipped180: spa_meta_videotransform_value = 6;
#[doc = "< flip then rotate around 270 degree counter-clockwise"]
pub const SPA_META_TRANSFORMATION_Flipped270: spa_meta_videotransform_value = 7;
pub type spa_meta_videotransform_value = ::std::os::raw::c_uint;
#[doc = " a transformation of the buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_videotransform {
    #[doc = "< orientation transformation that was applied to the buffer,\n  one of enum spa_meta_videotransform_value"]
    pub transform: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_videotransform"][::std::mem::size_of::<spa_meta_videotransform>() - 4usize];
    ["Alignment of spa_meta_videotransform"]
        [::std::mem::align_of::<spa_meta_videotransform>() - 4usize];
    ["Offset of field: spa_meta_videotransform::transform"]
        [::std::mem::offset_of!(spa_meta_videotransform, transform) - 0usize];
};
#[doc = " A timeline point for explicit sync\n\n Metadata to describe the time on the timeline when the buffer\n can be acquired and when it can be reused.\n\n This metadata will require negotiation of 2 extra fds for the acquire\n and release timelines respectively.  One way to achieve this is to place\n this metadata as SPA_PARAM_BUFFERS_metaType when negotiating a buffer\n layout with 2 extra fds."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_meta_sync_timeline {
    pub flags: u32,
    pub padding: u32,
    #[doc = "< the timeline acquire point, this is when the data\n  can be accessed."]
    pub acquire_point: u64,
    #[doc = "< the timeline release point, this timeline point should\n  be signaled when the data is no longer accessed."]
    pub release_point: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_meta_sync_timeline"][::std::mem::size_of::<spa_meta_sync_timeline>() - 24usize];
    ["Alignment of spa_meta_sync_timeline"]
        [::std::mem::align_of::<spa_meta_sync_timeline>() - 8usize];
    ["Offset of field: spa_meta_sync_timeline::flags"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, flags) - 0usize];
    ["Offset of field: spa_meta_sync_timeline::padding"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, padding) - 4usize];
    ["Offset of field: spa_meta_sync_timeline::acquire_point"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, acquire_point) - 8usize];
    ["Offset of field: spa_meta_sync_timeline::release_point"]
        [::std::mem::offset_of!(spa_meta_sync_timeline, release_point) - 16usize];
};
pub const SPA_DATA_Invalid: spa_data_type = 0;
#[doc = "< pointer to memory, the data field in\n  struct spa_data is set."]
pub const SPA_DATA_MemPtr: spa_data_type = 1;
#[doc = "< memfd, mmap to get to memory."]
pub const SPA_DATA_MemFd: spa_data_type = 2;
#[doc = "< fd to dmabuf memory. This might not be readily\n  mappable (unless the MAPPABLE flag is set) and should\n  normally be handled with DMABUF apis."]
pub const SPA_DATA_DmaBuf: spa_data_type = 3;
#[doc = "< memory is identified with an id. The actual memory\n  can be obtained in some other way and can be identified\n  with this id."]
pub const SPA_DATA_MemId: spa_data_type = 4;
#[doc = "< a syncobj, usually requires a spa_meta_sync_timeline metadata\n  with timeline points."]
pub const SPA_DATA_SyncObj: spa_data_type = 5;
#[doc = "< not part of ABI"]
pub const _SPA_DATA_LAST: spa_data_type = 6;
#[doc = " \\addtogroup spa_buffer\n \\{"]
pub type spa_data_type = ::std::os::raw::c_uint;
#[doc = " Chunk of memory, can change for each buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_chunk {
    #[doc = "< offset of valid data. Should be taken\n  modulo the data maxsize to get the offset\n  in the data memory."]
    pub offset: u32,
    #[doc = "< size of valid data. Should be clamped to\n  maxsize."]
    pub size: u32,
    #[doc = "< stride of valid data"]
    pub stride: i32,
    #[doc = "< chunk flags"]
    pub flags: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_chunk"][::std::mem::size_of::<spa_chunk>() - 16usize];
    ["Alignment of spa_chunk"][::std::mem::align_of::<spa_chunk>() - 4usize];
    ["Offset of field: spa_chunk::offset"][::std::mem::offset_of!(spa_chunk, offset) - 0usize];
    ["Offset of field: spa_chunk::size"][::std::mem::offset_of!(spa_chunk, size) - 4usize];
    ["Offset of field: spa_chunk::stride"][::std::mem::offset_of!(spa_chunk, stride) - 8usize];
    ["Offset of field: spa_chunk::flags"][::std::mem::offset_of!(spa_chunk, flags) - 12usize];
};
#[doc = " Data for a buffer this stays constant for a buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_data {
    #[doc = "< memory type, one of enum spa_data_type, when\n  allocating memory, the type contains a bitmask\n  of allowed types. SPA_ID_INVALID is a special\n  value for the allocator to indicate that the\n  other side did not explicitly specify any\n  supported data types. It should probably use\n  a memory type that does not require special\n  handling in addition to simple mmap/munmap."]
    pub type_: u32,
    #[doc = "< data flags"]
    pub flags: u32,
    #[doc = "< optional fd for data"]
    pub fd: i64,
    #[doc = "< offset to map fd at, this is page aligned"]
    pub mapoffset: u32,
    #[doc = "< max size of data"]
    pub maxsize: u32,
    #[doc = "< optional data pointer"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< valid chunk of memory"]
    pub chunk: *mut spa_chunk,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_data"][::std::mem::size_of::<spa_data>() - 40usize];
    ["Alignment of spa_data"][::std::mem::align_of::<spa_data>() - 8usize];
    ["Offset of field: spa_data::type_"][::std::mem::offset_of!(spa_data, type_) - 0usize];
    ["Offset of field: spa_data::flags"][::std::mem::offset_of!(spa_data, flags) - 4usize];
    ["Offset of field: spa_data::fd"][::std::mem::offset_of!(spa_data, fd) - 8usize];
    ["Offset of field: spa_data::mapoffset"][::std::mem::offset_of!(spa_data, mapoffset) - 16usize];
    ["Offset of field: spa_data::maxsize"][::std::mem::offset_of!(spa_data, maxsize) - 20usize];
    ["Offset of field: spa_data::data"][::std::mem::offset_of!(spa_data, data) - 24usize];
    ["Offset of field: spa_data::chunk"][::std::mem::offset_of!(spa_data, chunk) - 32usize];
};
#[doc = " A Buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_buffer {
    #[doc = "< number of metadata"]
    pub n_metas: u32,
    #[doc = "< number of data members"]
    pub n_datas: u32,
    #[doc = "< array of metadata"]
    pub metas: *mut spa_meta,
    #[doc = "< array of data members"]
    pub datas: *mut spa_data,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_buffer"][::std::mem::size_of::<spa_buffer>() - 24usize];
    ["Alignment of spa_buffer"][::std::mem::align_of::<spa_buffer>() - 8usize];
    ["Offset of field: spa_buffer::n_metas"][::std::mem::offset_of!(spa_buffer, n_metas) - 0usize];
    ["Offset of field: spa_buffer::n_datas"][::std::mem::offset_of!(spa_buffer, n_datas) - 4usize];
    ["Offset of field: spa_buffer::metas"][::std::mem::offset_of!(spa_buffer, metas) - 8usize];
    ["Offset of field: spa_buffer::datas"][::std::mem::offset_of!(spa_buffer, datas) - 16usize];
};
unsafe extern "C" {
    #[doc = " Find metadata in a buffer"]
    #[link_name = "spa_buffer_find_meta_libspa_rs"]
    pub fn spa_buffer_find_meta(b: *const spa_buffer, type_: u32) -> *mut spa_meta;
}
unsafe extern "C" {
    #[link_name = "spa_buffer_find_meta_data_libspa_rs"]
    pub fn spa_buffer_find_meta_data(
        b: *const spa_buffer,
        type_: u32,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " information about the buffer layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_buffer_alloc_info {
    pub flags: u32,
    #[doc = "< max of all alignments"]
    pub max_align: u32,
    pub n_metas: u32,
    pub n_datas: u32,
    pub metas: *mut spa_meta,
    pub datas: *mut spa_data,
    pub data_aligns: *mut u32,
    #[doc = "< size of the struct spa_buffer and inlined meta/chunk/data"]
    pub skel_size: usize,
    #[doc = "< size of the meta if not inlined"]
    pub meta_size: usize,
    #[doc = "< size of the chunk if not inlined"]
    pub chunk_size: usize,
    #[doc = "< size of the data if not inlined"]
    pub data_size: usize,
    #[doc = "< size of the total memory if not inlined"]
    pub mem_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_buffer_alloc_info"][::std::mem::size_of::<spa_buffer_alloc_info>() - 80usize];
    ["Alignment of spa_buffer_alloc_info"]
        [::std::mem::align_of::<spa_buffer_alloc_info>() - 8usize];
    ["Offset of field: spa_buffer_alloc_info::flags"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, flags) - 0usize];
    ["Offset of field: spa_buffer_alloc_info::max_align"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, max_align) - 4usize];
    ["Offset of field: spa_buffer_alloc_info::n_metas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, n_metas) - 8usize];
    ["Offset of field: spa_buffer_alloc_info::n_datas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, n_datas) - 12usize];
    ["Offset of field: spa_buffer_alloc_info::metas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, metas) - 16usize];
    ["Offset of field: spa_buffer_alloc_info::datas"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, datas) - 24usize];
    ["Offset of field: spa_buffer_alloc_info::data_aligns"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, data_aligns) - 32usize];
    ["Offset of field: spa_buffer_alloc_info::skel_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, skel_size) - 40usize];
    ["Offset of field: spa_buffer_alloc_info::meta_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, meta_size) - 48usize];
    ["Offset of field: spa_buffer_alloc_info::chunk_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, chunk_size) - 56usize];
    ["Offset of field: spa_buffer_alloc_info::data_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, data_size) - 64usize];
    ["Offset of field: spa_buffer_alloc_info::mem_size"]
        [::std::mem::offset_of!(spa_buffer_alloc_info, mem_size) - 72usize];
};
unsafe extern "C" {
    #[doc = " Fill buffer allocation information\n\n Fill \\a info with allocation information needed to allocate buffers\n with the given number of metadata and data members.\n\n The required size of the skeleton (the struct spa_buffer) information\n and the memory (for the metadata, chunk and buffer memory) will be\n calculated.\n\n The flags member in \\a info should be configured before calling this\n functions.\n\n \\param info the information to fill\n \\param n_metas the number of metadatas for the buffer\n \\param metas an array of metadata items\n \\param n_datas the number of datas for the buffer\n \\param datas an array of \\a n_datas items\n \\param data_aligns \\a n_datas alignments\n \\return 0 on success."]
    #[link_name = "spa_buffer_alloc_fill_info_libspa_rs"]
    pub fn spa_buffer_alloc_fill_info(
        info: *mut spa_buffer_alloc_info,
        n_metas: u32,
        metas: *mut spa_meta,
        n_datas: u32,
        datas: *mut spa_data,
        data_aligns: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fill skeleton and data according to the allocation info\n\n Use the allocation info to create a struct \\ref spa_buffer into\n \\a skel_mem and \\a data_mem.\n\n Depending on the flags given when calling \\ref\n spa_buffer_alloc_fill_info(), the buffer meta, chunk and memory\n will be referenced in either skel_mem or data_mem.\n\n \\param info an allocation info\n \\param skel_mem memory to hold the struct \\ref spa_buffer and the\n  pointers to meta, chunk and memory.\n \\param data_mem memory to hold the meta, chunk and memory\n \\return a struct \\ref spa_buffer in \\a skel_mem"]
    #[link_name = "spa_buffer_alloc_layout_libspa_rs"]
    pub fn spa_buffer_alloc_layout(
        info: *mut spa_buffer_alloc_info,
        skel_mem: *mut ::std::os::raw::c_void,
        data_mem: *mut ::std::os::raw::c_void,
    ) -> *mut spa_buffer;
}
unsafe extern "C" {
    #[doc = " Layout an array of buffers\n\n Use the allocation info to layout the memory of an array of buffers.\n\n \\a skel_mem should point to at least info->skel_size * \\a n_buffers bytes\n of memory.\n \\a data_mem should point to at least info->mem_size * \\a n_buffers bytes\n of memory.\n\n \\param info the allocation info for one buffer\n \\param n_buffers the number of buffers to create\n \\param buffers a array with space to hold \\a n_buffers pointers to buffers\n \\param skel_mem memory for the struct \\ref spa_buffer\n \\param data_mem memory for the meta, chunk, memory of the buffer if not\n\t\tinlined in the skeleton.\n \\return 0 on success.\n"]
    #[link_name = "spa_buffer_alloc_layout_array_libspa_rs"]
    pub fn spa_buffer_alloc_layout_array(
        info: *mut spa_buffer_alloc_info,
        n_buffers: u32,
        buffers: *mut *mut spa_buffer,
        skel_mem: *mut ::std::os::raw::c_void,
        data_mem: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Allocate an array of buffers\n\n Allocate \\a n_buffers with the given metadata, memory and alignment\n information.\n\n The buffer array, structures, data and metadata will all be allocated\n in one block of memory with the proper requested alignment.\n\n \\param n_buffers the number of buffers to create\n \\param flags extra flags\n \\param n_metas number of metadatas\n \\param metas \\a n_metas metadata specification\n \\param n_datas number of datas\n \\param datas \\a n_datas memory specification\n \\param data_aligns \\a n_datas alignment specifications\n \\returns an array of \\a n_buffers pointers to struct \\ref spa_buffer\n     with the given metadata, data and alignment or NULL when\n     allocation failed.\n"]
    #[link_name = "spa_buffer_alloc_array_libspa_rs"]
    pub fn spa_buffer_alloc_array(
        n_buffers: u32,
        flags: u32,
        n_metas: u32,
        metas: *mut spa_meta,
        n_datas: u32,
        datas: *mut spa_data,
        data_aligns: *mut u32,
    ) -> *mut *mut spa_buffer;
}
pub const SPA_CONTROL_Invalid: spa_control_type = 0;
#[doc = "< SPA_TYPE_OBJECT_Props"]
pub const SPA_CONTROL_Properties: spa_control_type = 1;
#[doc = "< spa_pod_bytes with raw midi data (deprecated, use SPA_CONTROL_UMP)"]
pub const SPA_CONTROL_Midi: spa_control_type = 2;
#[doc = "< spa_pod_bytes with an OSC packet"]
pub const SPA_CONTROL_OSC: spa_control_type = 3;
#[doc = "< spa_pod_bytes with raw UMP (universal MIDI packet)\n  data. The UMP 32 bit words are stored in native endian\n  format."]
pub const SPA_CONTROL_UMP: spa_control_type = 4;
#[doc = "< not part of ABI"]
pub const _SPA_CONTROL_LAST: spa_control_type = 5;
#[doc = " Different Control types"]
pub type spa_control_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_debug_context {
    pub log: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut spa_debug_context, fmt: *const ::std::os::raw::c_char, ...),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_debug_context"][::std::mem::size_of::<spa_debug_context>() - 8usize];
    ["Alignment of spa_debug_context"][::std::mem::align_of::<spa_debug_context>() - 8usize];
    ["Offset of field: spa_debug_context::log"]
        [::std::mem::offset_of!(spa_debug_context, log) - 0usize];
};
unsafe extern "C" {
    #[link_name = "spa_debugc_error_location_libspa_rs"]
    pub fn spa_debugc_error_location(c: *mut spa_debug_context, loc: *mut spa_error_location);
}
unsafe extern "C" {
    #[link_name = "spa_debugc_mem_libspa_rs"]
    pub fn spa_debugc_mem(
        ctx: *mut spa_debug_context,
        indent: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_mem_libspa_rs"]
    pub fn spa_debug_mem(
        indent: ::std::os::raw::c_int,
        data: *const ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_event_body {
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_event_body"][::std::mem::size_of::<spa_event_body>() - 8usize];
    ["Alignment of spa_event_body"][::std::mem::align_of::<spa_event_body>() - 4usize];
    ["Offset of field: spa_event_body::body"]
        [::std::mem::offset_of!(spa_event_body, body) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_event {
    pub pod: spa_pod,
    pub body: spa_event_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_event"][::std::mem::size_of::<spa_event>() - 16usize];
    ["Alignment of spa_event"][::std::mem::align_of::<spa_event>() - 4usize];
    ["Offset of field: spa_event::pod"][::std::mem::offset_of!(spa_event, pod) - 0usize];
    ["Offset of field: spa_event::body"][::std::mem::offset_of!(spa_event, body) - 8usize];
};
pub const SPA_DEVICE_EVENT_ObjectConfig: spa_device_event = 0;
#[doc = " \\addtogroup spa_device\n \\{"]
pub type spa_device_event = ::std::os::raw::c_uint;
pub const SPA_EVENT_DEVICE_START: spa_event_device = 0;
pub const SPA_EVENT_DEVICE_Object: spa_event_device = 1;
pub const SPA_EVENT_DEVICE_Props: spa_event_device = 2;
pub type spa_event_device = ::std::os::raw::c_uint;
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_command_body {
    pub body: spa_pod_object_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_command_body"][::std::mem::size_of::<spa_command_body>() - 8usize];
    ["Alignment of spa_command_body"][::std::mem::align_of::<spa_command_body>() - 4usize];
    ["Offset of field: spa_command_body::body"]
        [::std::mem::offset_of!(spa_command_body, body) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_command {
    pub pod: spa_pod,
    pub body: spa_command_body,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_command"][::std::mem::size_of::<spa_command>() - 16usize];
    ["Alignment of spa_command"][::std::mem::align_of::<spa_command>() - 4usize];
    ["Offset of field: spa_command::pod"][::std::mem::offset_of!(spa_command, pod) - 0usize];
    ["Offset of field: spa_command::body"][::std::mem::offset_of!(spa_command, body) - 8usize];
};
#[doc = "< suspend a node, this removes all configured\n formats and closes any devices"]
pub const SPA_NODE_COMMAND_Suspend: spa_node_command = 0;
#[doc = "< pause a node. this makes it stop emitting\n  scheduling events"]
pub const SPA_NODE_COMMAND_Pause: spa_node_command = 1;
#[doc = "< start a node, this makes it start emitting\n  scheduling events"]
pub const SPA_NODE_COMMAND_Start: spa_node_command = 2;
pub const SPA_NODE_COMMAND_Enable: spa_node_command = 3;
pub const SPA_NODE_COMMAND_Disable: spa_node_command = 4;
pub const SPA_NODE_COMMAND_Flush: spa_node_command = 5;
pub const SPA_NODE_COMMAND_Drain: spa_node_command = 6;
pub const SPA_NODE_COMMAND_Marker: spa_node_command = 7;
#[doc = "< begin a set of parameter enumerations or\n  configuration that require the device to\n  remain opened, like query formats and then\n  set a format"]
pub const SPA_NODE_COMMAND_ParamBegin: spa_node_command = 8;
#[doc = "< end a transaction"]
pub const SPA_NODE_COMMAND_ParamEnd: spa_node_command = 9;
#[doc = "< Sent to a driver when some other node emitted\n  the RequestProcess event."]
pub const SPA_NODE_COMMAND_RequestProcess: spa_node_command = 10;
pub type spa_node_command = ::std::os::raw::c_uint;
pub const SPA_NODE_EVENT_Error: spa_node_event = 0;
pub const SPA_NODE_EVENT_Buffering: spa_node_event = 1;
pub const SPA_NODE_EVENT_RequestRefresh: spa_node_event = 2;
pub const SPA_NODE_EVENT_RequestProcess: spa_node_event = 3;
pub type spa_node_event = ::std::os::raw::c_uint;
pub const SPA_EVENT_NODE_START: spa_event_node = 0;
pub type spa_event_node = ::std::os::raw::c_uint;
pub const SPA_IO_Invalid: spa_io_type = 0;
#[doc = "< area to exchange buffers, struct spa_io_buffers"]
pub const SPA_IO_Buffers: spa_io_type = 1;
#[doc = "< expected byte range, struct spa_io_range (currently not used in PipeWire)"]
pub const SPA_IO_Range: spa_io_type = 2;
#[doc = "< area to update clock information, struct spa_io_clock"]
pub const SPA_IO_Clock: spa_io_type = 3;
#[doc = "< latency reporting, struct spa_io_latency (currently not used in\n PipeWire). \\see spa_param_latency"]
pub const SPA_IO_Latency: spa_io_type = 4;
#[doc = "< area for control messages, struct spa_io_sequence"]
pub const SPA_IO_Control: spa_io_type = 5;
#[doc = "< area for notify messages, struct spa_io_sequence"]
pub const SPA_IO_Notify: spa_io_type = 6;
#[doc = "< position information in the graph, struct spa_io_position"]
pub const SPA_IO_Position: spa_io_type = 7;
#[doc = "< rate matching between nodes, struct spa_io_rate_match"]
pub const SPA_IO_RateMatch: spa_io_type = 8;
#[doc = "< memory pointer, struct spa_io_memory (currently not used in PipeWire)"]
pub const SPA_IO_Memory: spa_io_type = 9;
#[doc = "< async area to exchange buffers, struct spa_io_async_buffers"]
pub const SPA_IO_AsyncBuffers: spa_io_type = 10;
#[doc = " Different IO area types"]
pub type spa_io_type = ::std::os::raw::c_uint;
#[doc = " IO area to exchange buffers.\n\n A set of buffers should first be configured on the node/port.\n Further references to those buffers will be made by using the\n id of the buffer.\n\n If status is SPA_STATUS_OK, the host should ignore\n the io area.\n\n If status is SPA_STATUS_NEED_DATA, the host should:\n 1) recycle the buffer in buffer_id, if possible\n 2) prepare a new buffer and place the id in buffer_id.\n\n If status is SPA_STATUS_HAVE_DATA, the host should consume\n the buffer in buffer_id and set the state to\n SPA_STATUS_NEED_DATA when new data is requested.\n\n If status is SPA_STATUS_STOPPED, some error occurred on the\n port.\n\n If status is SPA_STATUS_DRAINED, data from the io area was\n used to drain.\n\n Status can also be a negative errno value to indicate errors.\n such as:\n -EINVAL: buffer_id is invalid\n -EPIPE: no more buffers available"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_buffers {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< a buffer id"]
    pub buffer_id: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_buffers"][::std::mem::size_of::<spa_io_buffers>() - 8usize];
    ["Alignment of spa_io_buffers"][::std::mem::align_of::<spa_io_buffers>() - 4usize];
    ["Offset of field: spa_io_buffers::status"]
        [::std::mem::offset_of!(spa_io_buffers, status) - 0usize];
    ["Offset of field: spa_io_buffers::buffer_id"]
        [::std::mem::offset_of!(spa_io_buffers, buffer_id) - 4usize];
};
#[doc = " IO area to exchange a memory region"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_memory {
    #[doc = "< the status code"]
    pub status: i32,
    #[doc = "< the size of \\a data"]
    pub size: u32,
    #[doc = "< a memory pointer"]
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_memory"][::std::mem::size_of::<spa_io_memory>() - 16usize];
    ["Alignment of spa_io_memory"][::std::mem::align_of::<spa_io_memory>() - 8usize];
    ["Offset of field: spa_io_memory::status"]
        [::std::mem::offset_of!(spa_io_memory, status) - 0usize];
    ["Offset of field: spa_io_memory::size"][::std::mem::offset_of!(spa_io_memory, size) - 4usize];
    ["Offset of field: spa_io_memory::data"][::std::mem::offset_of!(spa_io_memory, data) - 8usize];
};
#[doc = " A range, suitable for input ports that can suggest a range to output ports"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_range {
    #[doc = "< offset in range"]
    pub offset: u64,
    #[doc = "< minimum size of data"]
    pub min_size: u32,
    #[doc = "< maximum size of data"]
    pub max_size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_range"][::std::mem::size_of::<spa_io_range>() - 16usize];
    ["Alignment of spa_io_range"][::std::mem::align_of::<spa_io_range>() - 8usize];
    ["Offset of field: spa_io_range::offset"]
        [::std::mem::offset_of!(spa_io_range, offset) - 0usize];
    ["Offset of field: spa_io_range::min_size"]
        [::std::mem::offset_of!(spa_io_range, min_size) - 8usize];
    ["Offset of field: spa_io_range::max_size"]
        [::std::mem::offset_of!(spa_io_range, max_size) - 12usize];
};
#[doc = " Absolute time reporting.\n\n Nodes that can report clocking information will receive this io block.\n The application sets the id. This is usually set as part of the\n position information but can also be set separately.\n\n The clock counts the elapsed time according to the clock provider\n since the provider was last started.\n\n Driver nodes are supposed to update the contents of \\ref SPA_IO_Clock before\n signaling the start of a graph cycle.  These updated clock values become\n visible to other nodes in \\ref SPA_IO_Position. Non-driver nodes do\n not need to update the contents of their \\ref SPA_IO_Clock.\n\n The host generally gives each node a separate \\ref spa_io_clock in \\ref\n SPA_IO_Clock, so that updates made by the driver are not visible in the\n contents of \\ref SPA_IO_Clock of other nodes. Instead, \\ref SPA_IO_Position\n is used to look up the current graph time.\n\n A node is a driver when \\ref spa_io_clock.id in \\ref SPA_IO_Clock and\n \\ref spa_io_position.clock.id in \\ref SPA_IO_Position are the same."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_clock {
    #[doc = "< Clock flags"]
    pub flags: u32,
    #[doc = "< Unique clock id, set by host application"]
    pub id: u32,
    #[doc = "< Clock name prefixed with API, set by node when it receives\n  \\ref SPA_IO_Clock. The clock name is unique per clock and\n  can be used to check if nodes share the same clock."]
    pub name: [::std::os::raw::c_char; 64usize],
    #[doc = "< Time in nanoseconds against monotonic clock\n (CLOCK_MONOTONIC). This fields reflects a real time instant\n in the past. The value may have jitter."]
    pub nsec: u64,
    #[doc = "< Rate for position/duration/delay/xrun"]
    pub rate: spa_fraction,
    #[doc = "< Current position, in samples @ \\ref rate"]
    pub position: u64,
    #[doc = "< Duration of current cycle, in samples @ \\ref rate"]
    pub duration: u64,
    #[doc = "< Delay between position and hardware, in samples @ \\ref rate"]
    pub delay: i64,
    #[doc = "< Rate difference between clock and monotonic time, as a ratio of\n  clock speeds."]
    pub rate_diff: f64,
    #[doc = "< Estimated next wakeup time in nanoseconds.\n  This time is a logical start time of the next cycle, and\n  is not necessarily in the future."]
    pub next_nsec: u64,
    #[doc = "< Target rate of next cycle"]
    pub target_rate: spa_fraction,
    #[doc = "< Target duration of next cycle"]
    pub target_duration: u64,
    #[doc = "< Seq counter. must be equal at start and\n  end of read and lower bit must be 0"]
    pub target_seq: u32,
    #[doc = "< incremented each time the graph is started"]
    pub cycle: u32,
    #[doc = "< Estimated accumulated xrun duration"]
    pub xrun: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_clock"][::std::mem::size_of::<spa_io_clock>() - 160usize];
    ["Alignment of spa_io_clock"][::std::mem::align_of::<spa_io_clock>() - 8usize];
    ["Offset of field: spa_io_clock::flags"][::std::mem::offset_of!(spa_io_clock, flags) - 0usize];
    ["Offset of field: spa_io_clock::id"][::std::mem::offset_of!(spa_io_clock, id) - 4usize];
    ["Offset of field: spa_io_clock::name"][::std::mem::offset_of!(spa_io_clock, name) - 8usize];
    ["Offset of field: spa_io_clock::nsec"][::std::mem::offset_of!(spa_io_clock, nsec) - 72usize];
    ["Offset of field: spa_io_clock::rate"][::std::mem::offset_of!(spa_io_clock, rate) - 80usize];
    ["Offset of field: spa_io_clock::position"]
        [::std::mem::offset_of!(spa_io_clock, position) - 88usize];
    ["Offset of field: spa_io_clock::duration"]
        [::std::mem::offset_of!(spa_io_clock, duration) - 96usize];
    ["Offset of field: spa_io_clock::delay"]
        [::std::mem::offset_of!(spa_io_clock, delay) - 104usize];
    ["Offset of field: spa_io_clock::rate_diff"]
        [::std::mem::offset_of!(spa_io_clock, rate_diff) - 112usize];
    ["Offset of field: spa_io_clock::next_nsec"]
        [::std::mem::offset_of!(spa_io_clock, next_nsec) - 120usize];
    ["Offset of field: spa_io_clock::target_rate"]
        [::std::mem::offset_of!(spa_io_clock, target_rate) - 128usize];
    ["Offset of field: spa_io_clock::target_duration"]
        [::std::mem::offset_of!(spa_io_clock, target_duration) - 136usize];
    ["Offset of field: spa_io_clock::target_seq"]
        [::std::mem::offset_of!(spa_io_clock, target_seq) - 144usize];
    ["Offset of field: spa_io_clock::cycle"]
        [::std::mem::offset_of!(spa_io_clock, cycle) - 148usize];
    ["Offset of field: spa_io_clock::xrun"][::std::mem::offset_of!(spa_io_clock, xrun) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_video_size {
    #[doc = "< optional flags"]
    pub flags: u32,
    #[doc = "< video stride in bytes"]
    pub stride: u32,
    #[doc = "< the video size"]
    pub size: spa_rectangle,
    #[doc = "< the minimum framerate, the cycle duration is\n  always smaller to ensure there is only one\n  video frame per cycle."]
    pub framerate: spa_fraction,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_video_size"][::std::mem::size_of::<spa_io_video_size>() - 40usize];
    ["Alignment of spa_io_video_size"][::std::mem::align_of::<spa_io_video_size>() - 4usize];
    ["Offset of field: spa_io_video_size::flags"]
        [::std::mem::offset_of!(spa_io_video_size, flags) - 0usize];
    ["Offset of field: spa_io_video_size::stride"]
        [::std::mem::offset_of!(spa_io_video_size, stride) - 4usize];
    ["Offset of field: spa_io_video_size::size"]
        [::std::mem::offset_of!(spa_io_video_size, size) - 8usize];
    ["Offset of field: spa_io_video_size::framerate"]
        [::std::mem::offset_of!(spa_io_video_size, framerate) - 16usize];
    ["Offset of field: spa_io_video_size::padding"]
        [::std::mem::offset_of!(spa_io_video_size, padding) - 24usize];
};
#[doc = " Latency reporting\n\n Currently not used in PipeWire. Instead, \\see spa_param_latency"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_latency {
    #[doc = "< rate for min/max"]
    pub rate: spa_fraction,
    #[doc = "< min latency"]
    pub min: u64,
    #[doc = "< max latency"]
    pub max: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_latency"][::std::mem::size_of::<spa_io_latency>() - 24usize];
    ["Alignment of spa_io_latency"][::std::mem::align_of::<spa_io_latency>() - 8usize];
    ["Offset of field: spa_io_latency::rate"]
        [::std::mem::offset_of!(spa_io_latency, rate) - 0usize];
    ["Offset of field: spa_io_latency::min"][::std::mem::offset_of!(spa_io_latency, min) - 8usize];
    ["Offset of field: spa_io_latency::max"][::std::mem::offset_of!(spa_io_latency, max) - 16usize];
};
#[doc = " control stream, io area for SPA_IO_Control and SPA_IO_Notify"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_sequence {
    #[doc = "< sequence of timed events"]
    pub sequence: spa_pod_sequence,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_sequence"][::std::mem::size_of::<spa_io_sequence>() - 16usize];
    ["Alignment of spa_io_sequence"][::std::mem::align_of::<spa_io_sequence>() - 4usize];
    ["Offset of field: spa_io_sequence::sequence"]
        [::std::mem::offset_of!(spa_io_sequence, sequence) - 0usize];
};
#[doc = " bar and beat segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_segment_bar {
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< offset in segment of this beat"]
    pub offset: u32,
    #[doc = "< time signature numerator"]
    pub signature_num: f32,
    #[doc = "< time signature denominator"]
    pub signature_denom: f32,
    #[doc = "< beats per minute"]
    pub bpm: f64,
    #[doc = "< current beat in segment"]
    pub beat: f64,
    pub bar_start_tick: f64,
    pub ticks_per_beat: f64,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment_bar"][::std::mem::size_of::<spa_io_segment_bar>() - 64usize];
    ["Alignment of spa_io_segment_bar"][::std::mem::align_of::<spa_io_segment_bar>() - 8usize];
    ["Offset of field: spa_io_segment_bar::flags"]
        [::std::mem::offset_of!(spa_io_segment_bar, flags) - 0usize];
    ["Offset of field: spa_io_segment_bar::offset"]
        [::std::mem::offset_of!(spa_io_segment_bar, offset) - 4usize];
    ["Offset of field: spa_io_segment_bar::signature_num"]
        [::std::mem::offset_of!(spa_io_segment_bar, signature_num) - 8usize];
    ["Offset of field: spa_io_segment_bar::signature_denom"]
        [::std::mem::offset_of!(spa_io_segment_bar, signature_denom) - 12usize];
    ["Offset of field: spa_io_segment_bar::bpm"]
        [::std::mem::offset_of!(spa_io_segment_bar, bpm) - 16usize];
    ["Offset of field: spa_io_segment_bar::beat"]
        [::std::mem::offset_of!(spa_io_segment_bar, beat) - 24usize];
    ["Offset of field: spa_io_segment_bar::bar_start_tick"]
        [::std::mem::offset_of!(spa_io_segment_bar, bar_start_tick) - 32usize];
    ["Offset of field: spa_io_segment_bar::ticks_per_beat"]
        [::std::mem::offset_of!(spa_io_segment_bar, ticks_per_beat) - 40usize];
    ["Offset of field: spa_io_segment_bar::padding"]
        [::std::mem::offset_of!(spa_io_segment_bar, padding) - 48usize];
};
#[doc = " video frame segment"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_segment_video {
    #[doc = "< flags"]
    pub flags: u32,
    #[doc = "< offset in segment"]
    pub offset: u32,
    pub framerate: spa_fraction,
    pub hours: u32,
    pub minutes: u32,
    pub seconds: u32,
    pub frames: u32,
    #[doc = "< 0 for progressive, 1 and 2 for interlaced"]
    pub field_count: u32,
    pub padding: [u32; 11usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment_video"][::std::mem::size_of::<spa_io_segment_video>() - 80usize];
    ["Alignment of spa_io_segment_video"][::std::mem::align_of::<spa_io_segment_video>() - 4usize];
    ["Offset of field: spa_io_segment_video::flags"]
        [::std::mem::offset_of!(spa_io_segment_video, flags) - 0usize];
    ["Offset of field: spa_io_segment_video::offset"]
        [::std::mem::offset_of!(spa_io_segment_video, offset) - 4usize];
    ["Offset of field: spa_io_segment_video::framerate"]
        [::std::mem::offset_of!(spa_io_segment_video, framerate) - 8usize];
    ["Offset of field: spa_io_segment_video::hours"]
        [::std::mem::offset_of!(spa_io_segment_video, hours) - 16usize];
    ["Offset of field: spa_io_segment_video::minutes"]
        [::std::mem::offset_of!(spa_io_segment_video, minutes) - 20usize];
    ["Offset of field: spa_io_segment_video::seconds"]
        [::std::mem::offset_of!(spa_io_segment_video, seconds) - 24usize];
    ["Offset of field: spa_io_segment_video::frames"]
        [::std::mem::offset_of!(spa_io_segment_video, frames) - 28usize];
    ["Offset of field: spa_io_segment_video::field_count"]
        [::std::mem::offset_of!(spa_io_segment_video, field_count) - 32usize];
    ["Offset of field: spa_io_segment_video::padding"]
        [::std::mem::offset_of!(spa_io_segment_video, padding) - 36usize];
};
#[doc = " A segment converts a running time to a segment (stream) position.\n\n The segment position is valid when the current running time is between\n start and start + duration. The position is then\n calculated as:\n\n   (running time - start) * rate + position;\n\n Support for looping is done by specifying the LOOPING flags with a\n non-zero duration. When the running time reaches start + duration,\n duration is added to start and the loop repeats.\n\n Care has to be taken when the running time + clock.duration extends\n past the start + duration from the segment; the user should correctly\n wrap around and partially repeat the loop in the current cycle.\n\n Extra information can be placed in the segment by setting the valid flags\n and filling up the corresponding structures."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_segment {
    pub version: u32,
    #[doc = "< extra flags"]
    pub flags: u32,
    #[doc = "< value of running time when this\n  info is active. Can be in the future for\n  pending changes. It does not have to be in\n  exact multiples of the clock duration."]
    pub start: u64,
    #[doc = "< duration when this info becomes invalid expressed\n  in running time. If the duration is 0, this\n  segment extends to the next segment. If the\n  segment becomes invalid and the looping flag is\n  set, the segment repeats."]
    pub duration: u64,
    #[doc = "< overall rate of the segment, can be negative for\n  backwards time reporting."]
    pub rate: f64,
    #[doc = "< The position when the running time == start.\n  can be invalid when the owner of the extra segment\n  information has not yet made the mapping."]
    pub position: u64,
    pub bar: spa_io_segment_bar,
    pub video: spa_io_segment_video,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_segment"][::std::mem::size_of::<spa_io_segment>() - 184usize];
    ["Alignment of spa_io_segment"][::std::mem::align_of::<spa_io_segment>() - 8usize];
    ["Offset of field: spa_io_segment::version"]
        [::std::mem::offset_of!(spa_io_segment, version) - 0usize];
    ["Offset of field: spa_io_segment::flags"]
        [::std::mem::offset_of!(spa_io_segment, flags) - 4usize];
    ["Offset of field: spa_io_segment::start"]
        [::std::mem::offset_of!(spa_io_segment, start) - 8usize];
    ["Offset of field: spa_io_segment::duration"]
        [::std::mem::offset_of!(spa_io_segment, duration) - 16usize];
    ["Offset of field: spa_io_segment::rate"]
        [::std::mem::offset_of!(spa_io_segment, rate) - 24usize];
    ["Offset of field: spa_io_segment::position"]
        [::std::mem::offset_of!(spa_io_segment, position) - 32usize];
    ["Offset of field: spa_io_segment::bar"][::std::mem::offset_of!(spa_io_segment, bar) - 40usize];
    ["Offset of field: spa_io_segment::video"]
        [::std::mem::offset_of!(spa_io_segment, video) - 104usize];
};
pub const SPA_IO_POSITION_STATE_STOPPED: spa_io_position_state = 0;
pub const SPA_IO_POSITION_STATE_STARTING: spa_io_position_state = 1;
pub const SPA_IO_POSITION_STATE_RUNNING: spa_io_position_state = 2;
pub type spa_io_position_state = ::std::os::raw::c_uint;
#[doc = " The position information adds extra meaning to the raw clock times.\n\n It is set on all nodes in \\ref SPA_IO_Position, and the contents of \\ref\n spa_io_position.clock contain the clock updates made by the driving node in\n the graph in its \\ref SPA_IO_Clock.  Also, \\ref spa_io_position.clock.id\n will contain the clock id of the driving node in the graph.\n\n The position clock indicates the logical start time of the current graph\n cycle.\n\n The position information contains 1 or more segments that convert the\n raw clock times to a stream time. They are sorted based on their\n start times, and thus the order in which they will activate in\n the future. This makes it possible to look ahead in the scheduled\n segments and anticipate the changes in the timeline."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_position {
    #[doc = "< clock position of driver, always valid and\n  read only"]
    pub clock: spa_io_clock,
    #[doc = "< size of the video in the current cycle"]
    pub video: spa_io_video_size,
    #[doc = "< an offset to subtract from the clock position\n  to get a running time. This is the time that\n  the state has been in the RUNNING state and the\n  time that should be used to compare the segment\n  start values against."]
    pub offset: i64,
    #[doc = "< one of enum spa_io_position_state"]
    pub state: u32,
    #[doc = "< number of segments"]
    pub n_segments: u32,
    #[doc = "< segments"]
    pub segments: [spa_io_segment; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_position"][::std::mem::size_of::<spa_io_position>() - 1688usize];
    ["Alignment of spa_io_position"][::std::mem::align_of::<spa_io_position>() - 8usize];
    ["Offset of field: spa_io_position::clock"]
        [::std::mem::offset_of!(spa_io_position, clock) - 0usize];
    ["Offset of field: spa_io_position::video"]
        [::std::mem::offset_of!(spa_io_position, video) - 160usize];
    ["Offset of field: spa_io_position::offset"]
        [::std::mem::offset_of!(spa_io_position, offset) - 200usize];
    ["Offset of field: spa_io_position::state"]
        [::std::mem::offset_of!(spa_io_position, state) - 208usize];
    ["Offset of field: spa_io_position::n_segments"]
        [::std::mem::offset_of!(spa_io_position, n_segments) - 212usize];
    ["Offset of field: spa_io_position::segments"]
        [::std::mem::offset_of!(spa_io_position, segments) - 216usize];
};
#[doc = " Rate matching.\n\n It is usually set on the nodes that process resampled data, by\n the component (audioadapter) that handles resampling between graph\n and node rates. The \\a flags and \\a rate fields may be modified by the node.\n\n The node can request a correction to the resampling rate in its process(), by setting\n \\ref SPA_IO_RATE_MATCH_ACTIVE on \\a flags, and setting \\a rate to the desired rate\n correction.  Usually the rate is obtained from DLL or other adaptive mechanism that\n e.g. drives the node buffer fill level toward a specific value.\n\n When resampling to (graph->node) direction, the number of samples produced\n by the resampler varies on each cycle, as the rates are not commensurate.\n\n When resampling to (node->graph) direction, the number of samples consumed by the\n resampler varies. Node output ports in process() should produce \\a size number of\n samples to match what the resampler needs to produce one graph quantum of output\n samples.\n\n Resampling filters introduce processing delay, given by \\a delay and \\a delay_frac, in\n samples at node rate. The delay varies on each cycle e.g. when resampling between\n noncommensurate rates.\n\n The first sample output (graph->node) or consumed (node->graph) by the resampler is\n offset by \\a delay + \\a delay_frac / 1e9 node samples relative to the nominal graph\n cycle start position:\n\n \\code{.unparsed}\n first_resampled_sample_nsec =\n\tfirst_original_sample_nsec\n\t- (rate_match->delay * SPA_NSEC_PER_SEC + rate_match->delay_frac) / node_rate\n \\endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_io_rate_match {
    #[doc = "< resampling delay, in samples at\n node rate"]
    pub delay: u32,
    #[doc = "< requested input size for resampler"]
    pub size: u32,
    #[doc = "< rate for resampler (set by node)"]
    pub rate: f64,
    #[doc = "< extra flags (set by node)"]
    pub flags: u32,
    #[doc = "< resampling delay fractional part,\n in units of nanosamples (1/10^9 sample) at node rate"]
    pub delay_frac: i32,
    pub padding: [u32; 6usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_rate_match"][::std::mem::size_of::<spa_io_rate_match>() - 48usize];
    ["Alignment of spa_io_rate_match"][::std::mem::align_of::<spa_io_rate_match>() - 8usize];
    ["Offset of field: spa_io_rate_match::delay"]
        [::std::mem::offset_of!(spa_io_rate_match, delay) - 0usize];
    ["Offset of field: spa_io_rate_match::size"]
        [::std::mem::offset_of!(spa_io_rate_match, size) - 4usize];
    ["Offset of field: spa_io_rate_match::rate"]
        [::std::mem::offset_of!(spa_io_rate_match, rate) - 8usize];
    ["Offset of field: spa_io_rate_match::flags"]
        [::std::mem::offset_of!(spa_io_rate_match, flags) - 16usize];
    ["Offset of field: spa_io_rate_match::delay_frac"]
        [::std::mem::offset_of!(spa_io_rate_match, delay_frac) - 20usize];
    ["Offset of field: spa_io_rate_match::padding"]
        [::std::mem::offset_of!(spa_io_rate_match, padding) - 24usize];
};
#[doc = " async buffers"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_io_async_buffers {
    #[doc = "< async buffers, writers write to current (cycle+1)&1,\n  readers read from (cycle)&1"]
    pub buffers: [spa_io_buffers; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_io_async_buffers"][::std::mem::size_of::<spa_io_async_buffers>() - 16usize];
    ["Alignment of spa_io_async_buffers"][::std::mem::align_of::<spa_io_async_buffers>() - 4usize];
    ["Offset of field: spa_io_async_buffers::buffers"]
        [::std::mem::offset_of!(spa_io_async_buffers, buffers) - 0usize];
};
#[doc = "< invalid"]
pub const SPA_PARAM_Invalid: spa_param_type = 0;
#[doc = "< property information as SPA_TYPE_OBJECT_PropInfo"]
pub const SPA_PARAM_PropInfo: spa_param_type = 1;
#[doc = "< properties as SPA_TYPE_OBJECT_Props"]
pub const SPA_PARAM_Props: spa_param_type = 2;
#[doc = "< available formats as SPA_TYPE_OBJECT_Format"]
pub const SPA_PARAM_EnumFormat: spa_param_type = 3;
#[doc = "< configured format as SPA_TYPE_OBJECT_Format"]
pub const SPA_PARAM_Format: spa_param_type = 4;
#[doc = "< buffer configurations as SPA_TYPE_OBJECT_ParamBuffers"]
pub const SPA_PARAM_Buffers: spa_param_type = 5;
#[doc = "< allowed metadata for buffers as SPA_TYPE_OBJECT_ParamMeta"]
pub const SPA_PARAM_Meta: spa_param_type = 6;
#[doc = "< configurable IO areas as SPA_TYPE_OBJECT_ParamIO"]
pub const SPA_PARAM_IO: spa_param_type = 7;
#[doc = "< profile enumeration as SPA_TYPE_OBJECT_ParamProfile"]
pub const SPA_PARAM_EnumProfile: spa_param_type = 8;
#[doc = "< profile configuration as SPA_TYPE_OBJECT_ParamProfile"]
pub const SPA_PARAM_Profile: spa_param_type = 9;
#[doc = "< port configuration enumeration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const SPA_PARAM_EnumPortConfig: spa_param_type = 10;
#[doc = "< port configuration as SPA_TYPE_OBJECT_ParamPortConfig"]
pub const SPA_PARAM_PortConfig: spa_param_type = 11;
#[doc = "< routing enumeration as SPA_TYPE_OBJECT_ParamRoute"]
pub const SPA_PARAM_EnumRoute: spa_param_type = 12;
#[doc = "< routing configuration as SPA_TYPE_OBJECT_ParamRoute"]
pub const SPA_PARAM_Route: spa_param_type = 13;
#[doc = "< Control parameter, a SPA_TYPE_Sequence"]
pub const SPA_PARAM_Control: spa_param_type = 14;
#[doc = "< latency reporting, a SPA_TYPE_OBJECT_ParamLatency"]
pub const SPA_PARAM_Latency: spa_param_type = 15;
#[doc = "< processing latency, a SPA_TYPE_OBJECT_ParamProcessLatency"]
pub const SPA_PARAM_ProcessLatency: spa_param_type = 16;
#[doc = "< tag reporting, a SPA_TYPE_OBJECT_ParamTag. Since 0.3.79"]
pub const SPA_PARAM_Tag: spa_param_type = 17;
#[doc = " different parameter types that can be queried"]
pub type spa_param_type = ::std::os::raw::c_uint;
#[doc = " information about a parameter"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_param_info {
    #[doc = "< enum spa_param_type"]
    pub id: u32,
    pub flags: u32,
    #[doc = "< private user field. You can use this to keep\n  state."]
    pub user: u32,
    #[doc = "< private seq field. You can use this to keep\n  state of a pending update."]
    pub seq: i32,
    pub padding: [u32; 4usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_param_info"][::std::mem::size_of::<spa_param_info>() - 32usize];
    ["Alignment of spa_param_info"][::std::mem::align_of::<spa_param_info>() - 4usize];
    ["Offset of field: spa_param_info::id"][::std::mem::offset_of!(spa_param_info, id) - 0usize];
    ["Offset of field: spa_param_info::flags"]
        [::std::mem::offset_of!(spa_param_info, flags) - 4usize];
    ["Offset of field: spa_param_info::user"]
        [::std::mem::offset_of!(spa_param_info, user) - 8usize];
    ["Offset of field: spa_param_info::seq"][::std::mem::offset_of!(spa_param_info, seq) - 12usize];
    ["Offset of field: spa_param_info::padding"]
        [::std::mem::offset_of!(spa_param_info, padding) - 16usize];
};
#[doc = "< unknown bitorder"]
pub const SPA_PARAM_BITORDER_unknown: spa_param_bitorder = 0;
#[doc = "< most significant bit"]
pub const SPA_PARAM_BITORDER_msb: spa_param_bitorder = 1;
#[doc = "< least significant bit"]
pub const SPA_PARAM_BITORDER_lsb: spa_param_bitorder = 2;
pub type spa_param_bitorder = ::std::os::raw::c_uint;
#[doc = "< unknown availability"]
pub const SPA_PARAM_AVAILABILITY_unknown: spa_param_availability = 0;
#[doc = "< not available"]
pub const SPA_PARAM_AVAILABILITY_no: spa_param_availability = 1;
#[doc = "< available"]
pub const SPA_PARAM_AVAILABILITY_yes: spa_param_availability = 2;
pub type spa_param_availability = ::std::os::raw::c_uint;
pub const SPA_PARAM_BUFFERS_START: spa_param_buffers = 0;
#[doc = "< number of buffers (Int)"]
pub const SPA_PARAM_BUFFERS_buffers: spa_param_buffers = 1;
#[doc = "< number of data blocks per buffer (Int)"]
pub const SPA_PARAM_BUFFERS_blocks: spa_param_buffers = 2;
#[doc = "< size of a data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_size: spa_param_buffers = 3;
#[doc = "< stride of data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_stride: spa_param_buffers = 4;
#[doc = "< alignment of data block memory (Int)"]
pub const SPA_PARAM_BUFFERS_align: spa_param_buffers = 5;
#[doc = "< possible memory types (flags choice Int, mask of enum spa_data_type)"]
pub const SPA_PARAM_BUFFERS_dataType: spa_param_buffers = 6;
#[doc = "< required meta data types (Int, mask of enum spa_meta_type)"]
pub const SPA_PARAM_BUFFERS_metaType: spa_param_buffers = 7;
#[doc = " properties for SPA_TYPE_OBJECT_ParamBuffers"]
pub type spa_param_buffers = ::std::os::raw::c_uint;
pub const SPA_PARAM_META_START: spa_param_meta = 0;
#[doc = "< the metadata, one of enum spa_meta_type (Id enum spa_meta_type)"]
pub const SPA_PARAM_META_type: spa_param_meta = 1;
#[doc = "< the expected maximum size the meta (Int)"]
pub const SPA_PARAM_META_size: spa_param_meta = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamMeta"]
pub type spa_param_meta = ::std::os::raw::c_uint;
pub const SPA_PARAM_IO_START: spa_param_io = 0;
#[doc = "< type ID, uniquely identifies the io area (Id enum spa_io_type)"]
pub const SPA_PARAM_IO_id: spa_param_io = 1;
#[doc = "< size of the io area (Int)"]
pub const SPA_PARAM_IO_size: spa_param_io = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamIO"]
pub type spa_param_io = ::std::os::raw::c_uint;
pub const SPA_PARAM_PROFILE_START: spa_param_profile = 0;
#[doc = "< profile index (Int)"]
pub const SPA_PARAM_PROFILE_index: spa_param_profile = 1;
#[doc = "< profile name (String)"]
pub const SPA_PARAM_PROFILE_name: spa_param_profile = 2;
#[doc = "< profile description (String)"]
pub const SPA_PARAM_PROFILE_description: spa_param_profile = 3;
#[doc = "< profile priority (Int)"]
pub const SPA_PARAM_PROFILE_priority: spa_param_profile = 4;
#[doc = "< availability of the profile\n  (Id enum spa_param_availability)"]
pub const SPA_PARAM_PROFILE_available: spa_param_profile = 5;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const SPA_PARAM_PROFILE_info: spa_param_profile = 6;
#[doc = "< node classes provided by this profile\n  (Struct(\n\t   Int : number of items following\n        Struct(\n           String : class name (eg. \"Audio/Source\"),\n           Int : number of nodes\n           String : property (eg. \"card.profile.devices\"),\n           Array of Int: device indexes\n         )*))"]
pub const SPA_PARAM_PROFILE_classes: spa_param_profile = 7;
#[doc = "< If profile should be saved (Bool)"]
pub const SPA_PARAM_PROFILE_save: spa_param_profile = 8;
#[doc = " properties for SPA_TYPE_OBJECT_ParamProfile"]
pub type spa_param_profile = ::std::os::raw::c_uint;
#[doc = "< no configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_none: spa_param_port_config_mode = 0;
#[doc = "< passthrough configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_passthrough: spa_param_port_config_mode = 1;
#[doc = "< convert configuration"]
pub const SPA_PARAM_PORT_CONFIG_MODE_convert: spa_param_port_config_mode = 2;
#[doc = "< dsp configuration, depending on the external\n  format. For audio, ports will be configured for\n  the given number of channels with F32 format."]
pub const SPA_PARAM_PORT_CONFIG_MODE_dsp: spa_param_port_config_mode = 3;
pub type spa_param_port_config_mode = ::std::os::raw::c_uint;
pub const SPA_PARAM_PORT_CONFIG_START: spa_param_port_config = 0;
#[doc = "< (Id enum spa_direction) direction"]
pub const SPA_PARAM_PORT_CONFIG_direction: spa_param_port_config = 1;
#[doc = "< (Id enum spa_param_port_config_mode) mode"]
pub const SPA_PARAM_PORT_CONFIG_mode: spa_param_port_config = 2;
#[doc = "< (Bool) enable monitor output ports on input ports"]
pub const SPA_PARAM_PORT_CONFIG_monitor: spa_param_port_config = 3;
#[doc = "< (Bool) enable control ports"]
pub const SPA_PARAM_PORT_CONFIG_control: spa_param_port_config = 4;
#[doc = "< (Object) format filter"]
pub const SPA_PARAM_PORT_CONFIG_format: spa_param_port_config = 5;
#[doc = " properties for SPA_TYPE_OBJECT_ParamPortConfig"]
pub type spa_param_port_config = ::std::os::raw::c_uint;
pub const SPA_PARAM_ROUTE_START: spa_param_route = 0;
#[doc = "< index of the routing destination (Int)"]
pub const SPA_PARAM_ROUTE_index: spa_param_route = 1;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const SPA_PARAM_ROUTE_direction: spa_param_route = 2;
#[doc = "< device id (Int)"]
pub const SPA_PARAM_ROUTE_device: spa_param_route = 3;
#[doc = "< name of the routing destination (String)"]
pub const SPA_PARAM_ROUTE_name: spa_param_route = 4;
#[doc = "< description of the destination (String)"]
pub const SPA_PARAM_ROUTE_description: spa_param_route = 5;
#[doc = "< priority of the destination (Int)"]
pub const SPA_PARAM_ROUTE_priority: spa_param_route = 6;
#[doc = "< availability of the destination\n  (Id enum spa_param_availability)"]
pub const SPA_PARAM_ROUTE_available: spa_param_route = 7;
#[doc = "< info (Struct(\n\t\t  Int : n_items,\n\t\t  (String : key,\n\t\t   String : value)*))"]
pub const SPA_PARAM_ROUTE_info: spa_param_route = 8;
#[doc = "< associated profile indexes (Array of Int)"]
pub const SPA_PARAM_ROUTE_profiles: spa_param_route = 9;
#[doc = "< properties SPA_TYPE_OBJECT_Props"]
pub const SPA_PARAM_ROUTE_props: spa_param_route = 10;
#[doc = "< associated device indexes (Array of Int)"]
pub const SPA_PARAM_ROUTE_devices: spa_param_route = 11;
#[doc = "< profile id (Int)"]
pub const SPA_PARAM_ROUTE_profile: spa_param_route = 12;
#[doc = "< If route should be saved (Bool)"]
pub const SPA_PARAM_ROUTE_save: spa_param_route = 13;
#[doc = " properties for SPA_TYPE_OBJECT_ParamRoute"]
pub type spa_param_route = ::std::os::raw::c_uint;
pub const SPA_PROP_INFO_START: spa_prop_info = 0;
#[doc = "< associated id of the property"]
pub const SPA_PROP_INFO_id: spa_prop_info = 1;
#[doc = "< name of the property"]
pub const SPA_PROP_INFO_name: spa_prop_info = 2;
#[doc = "< type and range/enums of property"]
pub const SPA_PROP_INFO_type: spa_prop_info = 3;
#[doc = "< labels of property if any, this is a\n  struct with pairs of values, the first one\n  is of the type of the property, the second\n  one is a string with a user readable label\n  for the value."]
pub const SPA_PROP_INFO_labels: spa_prop_info = 4;
#[doc = "< type of container if any (Id)"]
pub const SPA_PROP_INFO_container: spa_prop_info = 5;
#[doc = "< is part of params property (Bool)"]
pub const SPA_PROP_INFO_params: spa_prop_info = 6;
#[doc = "< User readable description"]
pub const SPA_PROP_INFO_description: spa_prop_info = 7;
#[doc = " properties of SPA_TYPE_OBJECT_PropInfo"]
pub type spa_prop_info = ::std::os::raw::c_uint;
pub const SPA_PROP_START: spa_prop = 0;
#[doc = "< an unknown property"]
pub const SPA_PROP_unknown: spa_prop = 1;
#[doc = "< device related properties"]
pub const SPA_PROP_START_Device: spa_prop = 256;
pub const SPA_PROP_device: spa_prop = 257;
pub const SPA_PROP_deviceName: spa_prop = 258;
pub const SPA_PROP_deviceFd: spa_prop = 259;
pub const SPA_PROP_card: spa_prop = 260;
pub const SPA_PROP_cardName: spa_prop = 261;
pub const SPA_PROP_minLatency: spa_prop = 262;
pub const SPA_PROP_maxLatency: spa_prop = 263;
pub const SPA_PROP_periods: spa_prop = 264;
pub const SPA_PROP_periodSize: spa_prop = 265;
pub const SPA_PROP_periodEvent: spa_prop = 266;
pub const SPA_PROP_live: spa_prop = 267;
pub const SPA_PROP_rate: spa_prop = 268;
pub const SPA_PROP_quality: spa_prop = 269;
pub const SPA_PROP_bluetoothAudioCodec: spa_prop = 270;
pub const SPA_PROP_bluetoothOffloadActive: spa_prop = 271;
#[doc = "< audio related properties"]
pub const SPA_PROP_START_Audio: spa_prop = 65536;
pub const SPA_PROP_waveType: spa_prop = 65537;
pub const SPA_PROP_frequency: spa_prop = 65538;
#[doc = "< a volume (Float), 0.0 silence, 1.0 no attenutation"]
pub const SPA_PROP_volume: spa_prop = 65539;
#[doc = "< mute (Bool)"]
pub const SPA_PROP_mute: spa_prop = 65540;
pub const SPA_PROP_patternType: spa_prop = 65541;
pub const SPA_PROP_ditherType: spa_prop = 65542;
pub const SPA_PROP_truncate: spa_prop = 65543;
#[doc = "< a volume array, one (linear) volume per channel\n (Array of Float). 0.0 is silence, 1.0 is\n  without attenuation. This is the effective\n  volume that is applied. It can result\n  in a hardware volume and software volume\n  (see softVolumes)"]
pub const SPA_PROP_channelVolumes: spa_prop = 65544;
#[doc = "< a volume base (Float)"]
pub const SPA_PROP_volumeBase: spa_prop = 65545;
#[doc = "< a volume step (Float)"]
pub const SPA_PROP_volumeStep: spa_prop = 65546;
#[doc = "< a channelmap array\n (Array (Id enum spa_audio_channel))"]
pub const SPA_PROP_channelMap: spa_prop = 65547;
#[doc = "< mute (Bool)"]
pub const SPA_PROP_monitorMute: spa_prop = 65548;
#[doc = "< a volume array, one (linear) volume per\n  channel (Array of Float)"]
pub const SPA_PROP_monitorVolumes: spa_prop = 65549;
#[doc = "< delay adjustment"]
pub const SPA_PROP_latencyOffsetNsec: spa_prop = 65550;
#[doc = "< mute (Bool) applied in software"]
pub const SPA_PROP_softMute: spa_prop = 65551;
#[doc = "< a volume array, one (linear) volume per channel\n (Array of Float). 0.0 is silence, 1.0 is without\n attenuation. This is the volume applied in\n software, there might be a part applied in\n hardware."]
pub const SPA_PROP_softVolumes: spa_prop = 65552;
#[doc = "< enabled IEC958 (S/PDIF) codecs,\n  (Array (Id enum spa_audio_iec958_codec)"]
pub const SPA_PROP_iec958Codecs: spa_prop = 65553;
#[doc = "< Samples to ramp the volume over"]
pub const SPA_PROP_volumeRampSamples: spa_prop = 65554;
#[doc = "< Step or incremental Samples to ramp\n  the volume over"]
pub const SPA_PROP_volumeRampStepSamples: spa_prop = 65555;
#[doc = "< Time in millisec to ramp the volume over"]
pub const SPA_PROP_volumeRampTime: spa_prop = 65556;
#[doc = "< Step or incremental Time in nano seconds\n  to ramp the"]
pub const SPA_PROP_volumeRampStepTime: spa_prop = 65557;
#[doc = "< the scale or graph to used to ramp the\n  volume"]
pub const SPA_PROP_volumeRampScale: spa_prop = 65558;
#[doc = "< video related properties"]
pub const SPA_PROP_START_Video: spa_prop = 131072;
pub const SPA_PROP_brightness: spa_prop = 131073;
pub const SPA_PROP_contrast: spa_prop = 131074;
pub const SPA_PROP_saturation: spa_prop = 131075;
pub const SPA_PROP_hue: spa_prop = 131076;
pub const SPA_PROP_gamma: spa_prop = 131077;
pub const SPA_PROP_exposure: spa_prop = 131078;
pub const SPA_PROP_gain: spa_prop = 131079;
pub const SPA_PROP_sharpness: spa_prop = 131080;
#[doc = "< other properties"]
pub const SPA_PROP_START_Other: spa_prop = 524288;
#[doc = "< simple control params\n    (Struct(\n\t  (String : key,\n\t   Pod    : value)*))"]
pub const SPA_PROP_params: spa_prop = 524289;
pub const SPA_PROP_START_CUSTOM: spa_prop = 16777216;
#[doc = " predefined properties for SPA_TYPE_OBJECT_Props"]
pub type spa_prop = ::std::os::raw::c_uint;
pub const SPA_MEDIA_TYPE_unknown: spa_media_type = 0;
pub const SPA_MEDIA_TYPE_audio: spa_media_type = 1;
pub const SPA_MEDIA_TYPE_video: spa_media_type = 2;
pub const SPA_MEDIA_TYPE_image: spa_media_type = 3;
pub const SPA_MEDIA_TYPE_binary: spa_media_type = 4;
pub const SPA_MEDIA_TYPE_stream: spa_media_type = 5;
pub const SPA_MEDIA_TYPE_application: spa_media_type = 6;
#[doc = " media type for SPA_TYPE_OBJECT_Format"]
pub type spa_media_type = ::std::os::raw::c_uint;
pub const SPA_MEDIA_SUBTYPE_unknown: spa_media_subtype = 0;
pub const SPA_MEDIA_SUBTYPE_raw: spa_media_subtype = 1;
pub const SPA_MEDIA_SUBTYPE_dsp: spa_media_subtype = 2;
pub const SPA_MEDIA_SUBTYPE_iec958: spa_media_subtype = 3;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_dsd: spa_media_subtype = 4;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_START_Audio: spa_media_subtype = 65536;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_mp3: spa_media_subtype = 65537;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_aac: spa_media_subtype = 65538;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_vorbis: spa_media_subtype = 65539;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_wma: spa_media_subtype = 65540;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_ra: spa_media_subtype = 65541;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_sbc: spa_media_subtype = 65542;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_adpcm: spa_media_subtype = 65543;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_g723: spa_media_subtype = 65544;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_g726: spa_media_subtype = 65545;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_g729: spa_media_subtype = 65546;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_amr: spa_media_subtype = 65547;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_gsm: spa_media_subtype = 65548;
#[doc = " S/PDIF"]
pub const SPA_MEDIA_SUBTYPE_alac: spa_media_subtype = 65549;
#[doc = " since 0.3.65"]
pub const SPA_MEDIA_SUBTYPE_flac: spa_media_subtype = 65550;
#[doc = " since 0.3.65"]
pub const SPA_MEDIA_SUBTYPE_ape: spa_media_subtype = 65551;
#[doc = " since 0.3.65"]
pub const SPA_MEDIA_SUBTYPE_opus: spa_media_subtype = 65552;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Video: spa_media_subtype = 131072;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_h264: spa_media_subtype = 131073;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mjpg: spa_media_subtype = 131074;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_dv: spa_media_subtype = 131075;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpegts: spa_media_subtype = 131076;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_h263: spa_media_subtype = 131077;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpeg1: spa_media_subtype = 131078;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpeg2: spa_media_subtype = 131079;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_mpeg4: spa_media_subtype = 131080;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_xvid: spa_media_subtype = 131081;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_vc1: spa_media_subtype = 131082;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_vp8: spa_media_subtype = 131083;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_vp9: spa_media_subtype = 131084;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_bayer: spa_media_subtype = 131085;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Image: spa_media_subtype = 196608;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_jpeg: spa_media_subtype = 196609;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Binary: spa_media_subtype = 262144;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Stream: spa_media_subtype = 327680;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_midi: spa_media_subtype = 327681;
#[doc = " since 0.3.68"]
pub const SPA_MEDIA_SUBTYPE_START_Application: spa_media_subtype = 393216;
#[doc = "< control stream, data contains\n  spa_pod_sequence with control info."]
pub const SPA_MEDIA_SUBTYPE_control: spa_media_subtype = 393217;
#[doc = " media subtype for SPA_TYPE_OBJECT_Format"]
pub type spa_media_subtype = ::std::os::raw::c_uint;
pub const SPA_FORMAT_START: spa_format = 0;
#[doc = "< media type (Id enum spa_media_type)"]
pub const SPA_FORMAT_mediaType: spa_format = 1;
#[doc = "< media subtype (Id enum spa_media_subtype)"]
pub const SPA_FORMAT_mediaSubtype: spa_format = 2;
pub const SPA_FORMAT_START_Audio: spa_format = 65536;
#[doc = "< audio format, (Id enum spa_audio_format)"]
pub const SPA_FORMAT_AUDIO_format: spa_format = 65537;
#[doc = "< optional flags (Int)"]
pub const SPA_FORMAT_AUDIO_flags: spa_format = 65538;
#[doc = "< sample rate (Int)"]
pub const SPA_FORMAT_AUDIO_rate: spa_format = 65539;
#[doc = "< number of audio channels (Int)"]
pub const SPA_FORMAT_AUDIO_channels: spa_format = 65540;
#[doc = "< channel positions (Id enum spa_audio_position)"]
pub const SPA_FORMAT_AUDIO_position: spa_format = 65541;
#[doc = "< codec used (IEC958) (Id enum spa_audio_iec958_codec)"]
pub const SPA_FORMAT_AUDIO_iec958Codec: spa_format = 65542;
#[doc = "< bit order (Id enum spa_param_bitorder)"]
pub const SPA_FORMAT_AUDIO_bitorder: spa_format = 65543;
#[doc = "< Interleave bytes (Int)"]
pub const SPA_FORMAT_AUDIO_interleave: spa_format = 65544;
#[doc = "< bit rate (Int)"]
pub const SPA_FORMAT_AUDIO_bitrate: spa_format = 65545;
#[doc = "< audio data block alignment (Int)"]
pub const SPA_FORMAT_AUDIO_blockAlign: spa_format = 65546;
#[doc = "< AAC stream format, (Id enum spa_audio_aac_stream_format)"]
pub const SPA_FORMAT_AUDIO_AAC_streamFormat: spa_format = 65547;
#[doc = "< WMA profile (Id enum spa_audio_wma_profile)"]
pub const SPA_FORMAT_AUDIO_WMA_profile: spa_format = 65548;
#[doc = "< AMR band mode (Id enum spa_audio_amr_band_mode)"]
pub const SPA_FORMAT_AUDIO_AMR_bandMode: spa_format = 65549;
pub const SPA_FORMAT_START_Video: spa_format = 131072;
#[doc = "< video format (Id enum spa_video_format)"]
pub const SPA_FORMAT_VIDEO_format: spa_format = 131073;
#[doc = "< format modifier (Long)\n use only with DMA-BUF and omit for other buffer types"]
pub const SPA_FORMAT_VIDEO_modifier: spa_format = 131074;
#[doc = "< size (Rectangle)"]
pub const SPA_FORMAT_VIDEO_size: spa_format = 131075;
#[doc = "< frame rate (Fraction)"]
pub const SPA_FORMAT_VIDEO_framerate: spa_format = 131076;
#[doc = "< maximum frame rate (Fraction)"]
pub const SPA_FORMAT_VIDEO_maxFramerate: spa_format = 131077;
#[doc = "< number of views (Int)"]
pub const SPA_FORMAT_VIDEO_views: spa_format = 131078;
#[doc = "< (Id enum spa_video_interlace_mode)"]
pub const SPA_FORMAT_VIDEO_interlaceMode: spa_format = 131079;
#[doc = "< (Rectangle)"]
pub const SPA_FORMAT_VIDEO_pixelAspectRatio: spa_format = 131080;
#[doc = "< (Id enum spa_video_multiview_mode)"]
pub const SPA_FORMAT_VIDEO_multiviewMode: spa_format = 131081;
#[doc = "< (Id enum spa_video_multiview_flags)"]
pub const SPA_FORMAT_VIDEO_multiviewFlags: spa_format = 131082;
#[doc = "< /Id enum spa_video_chroma_site)"]
pub const SPA_FORMAT_VIDEO_chromaSite: spa_format = 131083;
#[doc = "< /Id enum spa_video_color_range)"]
pub const SPA_FORMAT_VIDEO_colorRange: spa_format = 131084;
#[doc = "< /Id enum spa_video_color_matrix)"]
pub const SPA_FORMAT_VIDEO_colorMatrix: spa_format = 131085;
#[doc = "< /Id enum spa_video_transfer_function)"]
pub const SPA_FORMAT_VIDEO_transferFunction: spa_format = 131086;
#[doc = "< /Id enum spa_video_color_primaries)"]
pub const SPA_FORMAT_VIDEO_colorPrimaries: spa_format = 131087;
#[doc = "< (Int)"]
pub const SPA_FORMAT_VIDEO_profile: spa_format = 131088;
#[doc = "< (Int)"]
pub const SPA_FORMAT_VIDEO_level: spa_format = 131089;
#[doc = "< (Id enum spa_h264_stream_format)"]
pub const SPA_FORMAT_VIDEO_H264_streamFormat: spa_format = 131090;
#[doc = "< (Id enum spa_h264_alignment)"]
pub const SPA_FORMAT_VIDEO_H264_alignment: spa_format = 131091;
pub const SPA_FORMAT_START_Image: spa_format = 196608;
pub const SPA_FORMAT_START_Binary: spa_format = 262144;
pub const SPA_FORMAT_START_Stream: spa_format = 327680;
pub const SPA_FORMAT_START_Application: spa_format = 393216;
#[doc = "< possible control types (flags choice Int,\n  mask of enum spa_control_type)"]
pub const SPA_FORMAT_CONTROL_types: spa_format = 393217;
#[doc = " properties for audio SPA_TYPE_OBJECT_Format"]
pub type spa_format = ::std::os::raw::c_uint;
pub const SPA_AUDIO_FORMAT_UNKNOWN: spa_audio_format = 0;
pub const SPA_AUDIO_FORMAT_ENCODED: spa_audio_format = 1;
pub const SPA_AUDIO_FORMAT_START_Interleaved: spa_audio_format = 256;
pub const SPA_AUDIO_FORMAT_S8: spa_audio_format = 257;
pub const SPA_AUDIO_FORMAT_U8: spa_audio_format = 258;
pub const SPA_AUDIO_FORMAT_S16_LE: spa_audio_format = 259;
pub const SPA_AUDIO_FORMAT_S16_BE: spa_audio_format = 260;
pub const SPA_AUDIO_FORMAT_U16_LE: spa_audio_format = 261;
pub const SPA_AUDIO_FORMAT_U16_BE: spa_audio_format = 262;
pub const SPA_AUDIO_FORMAT_S24_32_LE: spa_audio_format = 263;
pub const SPA_AUDIO_FORMAT_S24_32_BE: spa_audio_format = 264;
pub const SPA_AUDIO_FORMAT_U24_32_LE: spa_audio_format = 265;
pub const SPA_AUDIO_FORMAT_U24_32_BE: spa_audio_format = 266;
pub const SPA_AUDIO_FORMAT_S32_LE: spa_audio_format = 267;
pub const SPA_AUDIO_FORMAT_S32_BE: spa_audio_format = 268;
pub const SPA_AUDIO_FORMAT_U32_LE: spa_audio_format = 269;
pub const SPA_AUDIO_FORMAT_U32_BE: spa_audio_format = 270;
pub const SPA_AUDIO_FORMAT_S24_LE: spa_audio_format = 271;
pub const SPA_AUDIO_FORMAT_S24_BE: spa_audio_format = 272;
pub const SPA_AUDIO_FORMAT_U24_LE: spa_audio_format = 273;
pub const SPA_AUDIO_FORMAT_U24_BE: spa_audio_format = 274;
pub const SPA_AUDIO_FORMAT_S20_LE: spa_audio_format = 275;
pub const SPA_AUDIO_FORMAT_S20_BE: spa_audio_format = 276;
pub const SPA_AUDIO_FORMAT_U20_LE: spa_audio_format = 277;
pub const SPA_AUDIO_FORMAT_U20_BE: spa_audio_format = 278;
pub const SPA_AUDIO_FORMAT_S18_LE: spa_audio_format = 279;
pub const SPA_AUDIO_FORMAT_S18_BE: spa_audio_format = 280;
pub const SPA_AUDIO_FORMAT_U18_LE: spa_audio_format = 281;
pub const SPA_AUDIO_FORMAT_U18_BE: spa_audio_format = 282;
pub const SPA_AUDIO_FORMAT_F32_LE: spa_audio_format = 283;
pub const SPA_AUDIO_FORMAT_F32_BE: spa_audio_format = 284;
pub const SPA_AUDIO_FORMAT_F64_LE: spa_audio_format = 285;
pub const SPA_AUDIO_FORMAT_F64_BE: spa_audio_format = 286;
pub const SPA_AUDIO_FORMAT_ULAW: spa_audio_format = 287;
pub const SPA_AUDIO_FORMAT_ALAW: spa_audio_format = 288;
pub const SPA_AUDIO_FORMAT_START_Planar: spa_audio_format = 512;
pub const SPA_AUDIO_FORMAT_U8P: spa_audio_format = 513;
pub const SPA_AUDIO_FORMAT_S16P: spa_audio_format = 514;
pub const SPA_AUDIO_FORMAT_S24_32P: spa_audio_format = 515;
pub const SPA_AUDIO_FORMAT_S32P: spa_audio_format = 516;
pub const SPA_AUDIO_FORMAT_S24P: spa_audio_format = 517;
pub const SPA_AUDIO_FORMAT_F32P: spa_audio_format = 518;
pub const SPA_AUDIO_FORMAT_F64P: spa_audio_format = 519;
pub const SPA_AUDIO_FORMAT_S8P: spa_audio_format = 520;
pub const SPA_AUDIO_FORMAT_START_Other: spa_audio_format = 1024;
pub const SPA_AUDIO_FORMAT_DSP_S32: spa_audio_format = 515;
pub const SPA_AUDIO_FORMAT_DSP_F32: spa_audio_format = 518;
pub const SPA_AUDIO_FORMAT_DSP_F64: spa_audio_format = 519;
pub const SPA_AUDIO_FORMAT_S16: spa_audio_format = 259;
pub const SPA_AUDIO_FORMAT_U16: spa_audio_format = 261;
pub const SPA_AUDIO_FORMAT_S24_32: spa_audio_format = 263;
pub const SPA_AUDIO_FORMAT_U24_32: spa_audio_format = 265;
pub const SPA_AUDIO_FORMAT_S32: spa_audio_format = 267;
pub const SPA_AUDIO_FORMAT_U32: spa_audio_format = 269;
pub const SPA_AUDIO_FORMAT_S24: spa_audio_format = 271;
pub const SPA_AUDIO_FORMAT_U24: spa_audio_format = 273;
pub const SPA_AUDIO_FORMAT_S20: spa_audio_format = 275;
pub const SPA_AUDIO_FORMAT_U20: spa_audio_format = 277;
pub const SPA_AUDIO_FORMAT_S18: spa_audio_format = 279;
pub const SPA_AUDIO_FORMAT_U18: spa_audio_format = 281;
pub const SPA_AUDIO_FORMAT_F32: spa_audio_format = 283;
pub const SPA_AUDIO_FORMAT_F64: spa_audio_format = 285;
pub const SPA_AUDIO_FORMAT_S16_OE: spa_audio_format = 260;
pub const SPA_AUDIO_FORMAT_U16_OE: spa_audio_format = 262;
pub const SPA_AUDIO_FORMAT_S24_32_OE: spa_audio_format = 264;
pub const SPA_AUDIO_FORMAT_U24_32_OE: spa_audio_format = 266;
pub const SPA_AUDIO_FORMAT_S32_OE: spa_audio_format = 268;
pub const SPA_AUDIO_FORMAT_U32_OE: spa_audio_format = 270;
pub const SPA_AUDIO_FORMAT_S24_OE: spa_audio_format = 272;
pub const SPA_AUDIO_FORMAT_U24_OE: spa_audio_format = 274;
pub const SPA_AUDIO_FORMAT_S20_OE: spa_audio_format = 276;
pub const SPA_AUDIO_FORMAT_U20_OE: spa_audio_format = 278;
pub const SPA_AUDIO_FORMAT_S18_OE: spa_audio_format = 280;
pub const SPA_AUDIO_FORMAT_U18_OE: spa_audio_format = 282;
pub const SPA_AUDIO_FORMAT_F32_OE: spa_audio_format = 284;
pub const SPA_AUDIO_FORMAT_F64_OE: spa_audio_format = 286;
pub type spa_audio_format = ::std::os::raw::c_uint;
#[doc = "< unspecified"]
pub const SPA_AUDIO_CHANNEL_UNKNOWN: spa_audio_channel = 0;
#[doc = "< N/A, silent"]
pub const SPA_AUDIO_CHANNEL_NA: spa_audio_channel = 1;
#[doc = "< mono stream"]
pub const SPA_AUDIO_CHANNEL_MONO: spa_audio_channel = 2;
#[doc = "< front left"]
pub const SPA_AUDIO_CHANNEL_FL: spa_audio_channel = 3;
#[doc = "< front right"]
pub const SPA_AUDIO_CHANNEL_FR: spa_audio_channel = 4;
#[doc = "< front center"]
pub const SPA_AUDIO_CHANNEL_FC: spa_audio_channel = 5;
#[doc = "< LFE"]
pub const SPA_AUDIO_CHANNEL_LFE: spa_audio_channel = 6;
#[doc = "< side left"]
pub const SPA_AUDIO_CHANNEL_SL: spa_audio_channel = 7;
#[doc = "< side right"]
pub const SPA_AUDIO_CHANNEL_SR: spa_audio_channel = 8;
#[doc = "< front left center"]
pub const SPA_AUDIO_CHANNEL_FLC: spa_audio_channel = 9;
#[doc = "< front right center"]
pub const SPA_AUDIO_CHANNEL_FRC: spa_audio_channel = 10;
#[doc = "< rear center"]
pub const SPA_AUDIO_CHANNEL_RC: spa_audio_channel = 11;
#[doc = "< rear left"]
pub const SPA_AUDIO_CHANNEL_RL: spa_audio_channel = 12;
#[doc = "< rear right"]
pub const SPA_AUDIO_CHANNEL_RR: spa_audio_channel = 13;
#[doc = "< top center"]
pub const SPA_AUDIO_CHANNEL_TC: spa_audio_channel = 14;
#[doc = "< top front left"]
pub const SPA_AUDIO_CHANNEL_TFL: spa_audio_channel = 15;
#[doc = "< top front center"]
pub const SPA_AUDIO_CHANNEL_TFC: spa_audio_channel = 16;
#[doc = "< top front right"]
pub const SPA_AUDIO_CHANNEL_TFR: spa_audio_channel = 17;
#[doc = "< top rear left"]
pub const SPA_AUDIO_CHANNEL_TRL: spa_audio_channel = 18;
#[doc = "< top rear center"]
pub const SPA_AUDIO_CHANNEL_TRC: spa_audio_channel = 19;
#[doc = "< top rear right"]
pub const SPA_AUDIO_CHANNEL_TRR: spa_audio_channel = 20;
#[doc = "< rear left center"]
pub const SPA_AUDIO_CHANNEL_RLC: spa_audio_channel = 21;
#[doc = "< rear right center"]
pub const SPA_AUDIO_CHANNEL_RRC: spa_audio_channel = 22;
#[doc = "< front left wide"]
pub const SPA_AUDIO_CHANNEL_FLW: spa_audio_channel = 23;
#[doc = "< front right wide"]
pub const SPA_AUDIO_CHANNEL_FRW: spa_audio_channel = 24;
#[doc = "< LFE 2"]
pub const SPA_AUDIO_CHANNEL_LFE2: spa_audio_channel = 25;
#[doc = "< front left high"]
pub const SPA_AUDIO_CHANNEL_FLH: spa_audio_channel = 26;
#[doc = "< front center high"]
pub const SPA_AUDIO_CHANNEL_FCH: spa_audio_channel = 27;
#[doc = "< front right high"]
pub const SPA_AUDIO_CHANNEL_FRH: spa_audio_channel = 28;
#[doc = "< top front left center"]
pub const SPA_AUDIO_CHANNEL_TFLC: spa_audio_channel = 29;
#[doc = "< top front right center"]
pub const SPA_AUDIO_CHANNEL_TFRC: spa_audio_channel = 30;
#[doc = "< top side left"]
pub const SPA_AUDIO_CHANNEL_TSL: spa_audio_channel = 31;
#[doc = "< top side right"]
pub const SPA_AUDIO_CHANNEL_TSR: spa_audio_channel = 32;
#[doc = "< left LFE"]
pub const SPA_AUDIO_CHANNEL_LLFE: spa_audio_channel = 33;
#[doc = "< right LFE"]
pub const SPA_AUDIO_CHANNEL_RLFE: spa_audio_channel = 34;
#[doc = "< bottom center"]
pub const SPA_AUDIO_CHANNEL_BC: spa_audio_channel = 35;
#[doc = "< bottom left center"]
pub const SPA_AUDIO_CHANNEL_BLC: spa_audio_channel = 36;
#[doc = "< bottom right center"]
pub const SPA_AUDIO_CHANNEL_BRC: spa_audio_channel = 37;
#[doc = "< aux channels"]
pub const SPA_AUDIO_CHANNEL_START_Aux: spa_audio_channel = 4096;
pub const SPA_AUDIO_CHANNEL_AUX0: spa_audio_channel = 4096;
pub const SPA_AUDIO_CHANNEL_AUX1: spa_audio_channel = 4097;
pub const SPA_AUDIO_CHANNEL_AUX2: spa_audio_channel = 4098;
pub const SPA_AUDIO_CHANNEL_AUX3: spa_audio_channel = 4099;
pub const SPA_AUDIO_CHANNEL_AUX4: spa_audio_channel = 4100;
pub const SPA_AUDIO_CHANNEL_AUX5: spa_audio_channel = 4101;
pub const SPA_AUDIO_CHANNEL_AUX6: spa_audio_channel = 4102;
pub const SPA_AUDIO_CHANNEL_AUX7: spa_audio_channel = 4103;
pub const SPA_AUDIO_CHANNEL_AUX8: spa_audio_channel = 4104;
pub const SPA_AUDIO_CHANNEL_AUX9: spa_audio_channel = 4105;
pub const SPA_AUDIO_CHANNEL_AUX10: spa_audio_channel = 4106;
pub const SPA_AUDIO_CHANNEL_AUX11: spa_audio_channel = 4107;
pub const SPA_AUDIO_CHANNEL_AUX12: spa_audio_channel = 4108;
pub const SPA_AUDIO_CHANNEL_AUX13: spa_audio_channel = 4109;
pub const SPA_AUDIO_CHANNEL_AUX14: spa_audio_channel = 4110;
pub const SPA_AUDIO_CHANNEL_AUX15: spa_audio_channel = 4111;
pub const SPA_AUDIO_CHANNEL_AUX16: spa_audio_channel = 4112;
pub const SPA_AUDIO_CHANNEL_AUX17: spa_audio_channel = 4113;
pub const SPA_AUDIO_CHANNEL_AUX18: spa_audio_channel = 4114;
pub const SPA_AUDIO_CHANNEL_AUX19: spa_audio_channel = 4115;
pub const SPA_AUDIO_CHANNEL_AUX20: spa_audio_channel = 4116;
pub const SPA_AUDIO_CHANNEL_AUX21: spa_audio_channel = 4117;
pub const SPA_AUDIO_CHANNEL_AUX22: spa_audio_channel = 4118;
pub const SPA_AUDIO_CHANNEL_AUX23: spa_audio_channel = 4119;
pub const SPA_AUDIO_CHANNEL_AUX24: spa_audio_channel = 4120;
pub const SPA_AUDIO_CHANNEL_AUX25: spa_audio_channel = 4121;
pub const SPA_AUDIO_CHANNEL_AUX26: spa_audio_channel = 4122;
pub const SPA_AUDIO_CHANNEL_AUX27: spa_audio_channel = 4123;
pub const SPA_AUDIO_CHANNEL_AUX28: spa_audio_channel = 4124;
pub const SPA_AUDIO_CHANNEL_AUX29: spa_audio_channel = 4125;
pub const SPA_AUDIO_CHANNEL_AUX30: spa_audio_channel = 4126;
pub const SPA_AUDIO_CHANNEL_AUX31: spa_audio_channel = 4127;
pub const SPA_AUDIO_CHANNEL_AUX32: spa_audio_channel = 4128;
pub const SPA_AUDIO_CHANNEL_AUX33: spa_audio_channel = 4129;
pub const SPA_AUDIO_CHANNEL_AUX34: spa_audio_channel = 4130;
pub const SPA_AUDIO_CHANNEL_AUX35: spa_audio_channel = 4131;
pub const SPA_AUDIO_CHANNEL_AUX36: spa_audio_channel = 4132;
pub const SPA_AUDIO_CHANNEL_AUX37: spa_audio_channel = 4133;
pub const SPA_AUDIO_CHANNEL_AUX38: spa_audio_channel = 4134;
pub const SPA_AUDIO_CHANNEL_AUX39: spa_audio_channel = 4135;
pub const SPA_AUDIO_CHANNEL_AUX40: spa_audio_channel = 4136;
pub const SPA_AUDIO_CHANNEL_AUX41: spa_audio_channel = 4137;
pub const SPA_AUDIO_CHANNEL_AUX42: spa_audio_channel = 4138;
pub const SPA_AUDIO_CHANNEL_AUX43: spa_audio_channel = 4139;
pub const SPA_AUDIO_CHANNEL_AUX44: spa_audio_channel = 4140;
pub const SPA_AUDIO_CHANNEL_AUX45: spa_audio_channel = 4141;
pub const SPA_AUDIO_CHANNEL_AUX46: spa_audio_channel = 4142;
pub const SPA_AUDIO_CHANNEL_AUX47: spa_audio_channel = 4143;
pub const SPA_AUDIO_CHANNEL_AUX48: spa_audio_channel = 4144;
pub const SPA_AUDIO_CHANNEL_AUX49: spa_audio_channel = 4145;
pub const SPA_AUDIO_CHANNEL_AUX50: spa_audio_channel = 4146;
pub const SPA_AUDIO_CHANNEL_AUX51: spa_audio_channel = 4147;
pub const SPA_AUDIO_CHANNEL_AUX52: spa_audio_channel = 4148;
pub const SPA_AUDIO_CHANNEL_AUX53: spa_audio_channel = 4149;
pub const SPA_AUDIO_CHANNEL_AUX54: spa_audio_channel = 4150;
pub const SPA_AUDIO_CHANNEL_AUX55: spa_audio_channel = 4151;
pub const SPA_AUDIO_CHANNEL_AUX56: spa_audio_channel = 4152;
pub const SPA_AUDIO_CHANNEL_AUX57: spa_audio_channel = 4153;
pub const SPA_AUDIO_CHANNEL_AUX58: spa_audio_channel = 4154;
pub const SPA_AUDIO_CHANNEL_AUX59: spa_audio_channel = 4155;
pub const SPA_AUDIO_CHANNEL_AUX60: spa_audio_channel = 4156;
pub const SPA_AUDIO_CHANNEL_AUX61: spa_audio_channel = 4157;
pub const SPA_AUDIO_CHANNEL_AUX62: spa_audio_channel = 4158;
pub const SPA_AUDIO_CHANNEL_AUX63: spa_audio_channel = 4159;
#[doc = "< aux channels"]
pub const SPA_AUDIO_CHANNEL_LAST_Aux: spa_audio_channel = 8191;
pub const SPA_AUDIO_CHANNEL_START_Custom: spa_audio_channel = 65536;
pub type spa_audio_channel = ::std::os::raw::c_uint;
pub const SPA_AUDIO_VOLUME_RAMP_INVALID: spa_audio_volume_ramp_scale = 0;
pub const SPA_AUDIO_VOLUME_RAMP_LINEAR: spa_audio_volume_ramp_scale = 1;
pub const SPA_AUDIO_VOLUME_RAMP_CUBIC: spa_audio_volume_ramp_scale = 2;
pub type spa_audio_volume_ramp_scale = ::std::os::raw::c_uint;
#[doc = " Audio information description"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_raw {
    pub format: spa_audio_format,
    pub flags: u32,
    pub rate: u32,
    pub channels: u32,
    pub position: [u32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_raw"][::std::mem::size_of::<spa_audio_info_raw>() - 272usize];
    ["Alignment of spa_audio_info_raw"][::std::mem::align_of::<spa_audio_info_raw>() - 4usize];
    ["Offset of field: spa_audio_info_raw::format"]
        [::std::mem::offset_of!(spa_audio_info_raw, format) - 0usize];
    ["Offset of field: spa_audio_info_raw::flags"]
        [::std::mem::offset_of!(spa_audio_info_raw, flags) - 4usize];
    ["Offset of field: spa_audio_info_raw::rate"]
        [::std::mem::offset_of!(spa_audio_info_raw, rate) - 8usize];
    ["Offset of field: spa_audio_info_raw::channels"]
        [::std::mem::offset_of!(spa_audio_info_raw, channels) - 12usize];
    ["Offset of field: spa_audio_info_raw::position"]
        [::std::mem::offset_of!(spa_audio_info_raw, position) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_type_audio_format_from_short_name_libspa_rs"]
    pub fn spa_type_audio_format_from_short_name(name: *const ::std::os::raw::c_char) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_type_audio_format_to_short_name_libspa_rs"]
    pub fn spa_type_audio_format_to_short_name(type_: u32) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_type_audio_channel_from_short_name_libspa_rs"]
    pub fn spa_type_audio_channel_from_short_name(name: *const ::std::os::raw::c_char) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_type_audio_channel_to_short_name_libspa_rs"]
    pub fn spa_type_audio_channel_to_short_name(type_: u32) -> *const ::std::os::raw::c_char;
}
pub const SPA_AUDIO_IEC958_CODEC_UNKNOWN: spa_audio_iec958_codec = 0;
pub const SPA_AUDIO_IEC958_CODEC_PCM: spa_audio_iec958_codec = 1;
pub const SPA_AUDIO_IEC958_CODEC_DTS: spa_audio_iec958_codec = 2;
pub const SPA_AUDIO_IEC958_CODEC_AC3: spa_audio_iec958_codec = 3;
#[doc = "< MPEG-1 or MPEG-2 (Part 3, not AAC)"]
pub const SPA_AUDIO_IEC958_CODEC_MPEG: spa_audio_iec958_codec = 4;
#[doc = "< MPEG-2 AAC"]
pub const SPA_AUDIO_IEC958_CODEC_MPEG2_AAC: spa_audio_iec958_codec = 5;
pub const SPA_AUDIO_IEC958_CODEC_EAC3: spa_audio_iec958_codec = 6;
#[doc = "< Dolby TrueHD"]
pub const SPA_AUDIO_IEC958_CODEC_TRUEHD: spa_audio_iec958_codec = 7;
#[doc = "< DTS-HD Master Audio"]
pub const SPA_AUDIO_IEC958_CODEC_DTSHD: spa_audio_iec958_codec = 8;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_iec958_codec = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_iec958 {
    pub codec: spa_audio_iec958_codec,
    pub flags: u32,
    pub rate: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_iec958"][::std::mem::size_of::<spa_audio_info_iec958>() - 12usize];
    ["Alignment of spa_audio_info_iec958"]
        [::std::mem::align_of::<spa_audio_info_iec958>() - 4usize];
    ["Offset of field: spa_audio_info_iec958::codec"]
        [::std::mem::offset_of!(spa_audio_info_iec958, codec) - 0usize];
    ["Offset of field: spa_audio_info_iec958::flags"]
        [::std::mem::offset_of!(spa_audio_info_iec958, flags) - 4usize];
    ["Offset of field: spa_audio_info_iec958::rate"]
        [::std::mem::offset_of!(spa_audio_info_iec958, rate) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_type_audio_iec958_codec_from_short_name_libspa_rs"]
    pub fn spa_type_audio_iec958_codec_from_short_name(name: *const ::std::os::raw::c_char) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_type_audio_iec958_codec_to_short_name_libspa_rs"]
    pub fn spa_type_audio_iec958_codec_to_short_name(type_: u32) -> *const ::std::os::raw::c_char;
}
pub const SPA_AUDIO_MP3_CHANNEL_MODE_UNKNOWN: spa_audio_mp3_channel_mode = 0;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_MONO: spa_audio_mp3_channel_mode = 1;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_STEREO: spa_audio_mp3_channel_mode = 2;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_JOINTSTEREO: spa_audio_mp3_channel_mode = 3;
pub const SPA_AUDIO_MP3_CHANNEL_MODE_DUAL: spa_audio_mp3_channel_mode = 4;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_mp3_channel_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_mp3 {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_mp3"][::std::mem::size_of::<spa_audio_info_mp3>() - 8usize];
    ["Alignment of spa_audio_info_mp3"][::std::mem::align_of::<spa_audio_info_mp3>() - 4usize];
    ["Offset of field: spa_audio_info_mp3::rate"]
        [::std::mem::offset_of!(spa_audio_info_mp3, rate) - 0usize];
    ["Offset of field: spa_audio_info_mp3::channels"]
        [::std::mem::offset_of!(spa_audio_info_mp3, channels) - 4usize];
};
pub const SPA_AUDIO_AAC_STREAM_FORMAT_UNKNOWN: spa_audio_aac_stream_format = 0;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_RAW: spa_audio_aac_stream_format = 1;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP2ADTS: spa_audio_aac_stream_format = 2;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4ADTS: spa_audio_aac_stream_format = 3;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4LOAS: spa_audio_aac_stream_format = 4;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4LATM: spa_audio_aac_stream_format = 5;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_ADIF: spa_audio_aac_stream_format = 6;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_MP4FF: spa_audio_aac_stream_format = 7;
pub const SPA_AUDIO_AAC_STREAM_FORMAT_CUSTOM: spa_audio_aac_stream_format = 65536;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_aac_stream_format = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_aac {
    pub rate: u32,
    pub channels: u32,
    pub bitrate: u32,
    pub stream_format: spa_audio_aac_stream_format,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_aac"][::std::mem::size_of::<spa_audio_info_aac>() - 16usize];
    ["Alignment of spa_audio_info_aac"][::std::mem::align_of::<spa_audio_info_aac>() - 4usize];
    ["Offset of field: spa_audio_info_aac::rate"]
        [::std::mem::offset_of!(spa_audio_info_aac, rate) - 0usize];
    ["Offset of field: spa_audio_info_aac::channels"]
        [::std::mem::offset_of!(spa_audio_info_aac, channels) - 4usize];
    ["Offset of field: spa_audio_info_aac::bitrate"]
        [::std::mem::offset_of!(spa_audio_info_aac, bitrate) - 8usize];
    ["Offset of field: spa_audio_info_aac::stream_format"]
        [::std::mem::offset_of!(spa_audio_info_aac, stream_format) - 12usize];
};
pub const SPA_AUDIO_WMA_PROFILE_UNKNOWN: spa_audio_wma_profile = 0;
pub const SPA_AUDIO_WMA_PROFILE_WMA7: spa_audio_wma_profile = 1;
pub const SPA_AUDIO_WMA_PROFILE_WMA8: spa_audio_wma_profile = 2;
pub const SPA_AUDIO_WMA_PROFILE_WMA9: spa_audio_wma_profile = 3;
pub const SPA_AUDIO_WMA_PROFILE_WMA10: spa_audio_wma_profile = 4;
pub const SPA_AUDIO_WMA_PROFILE_WMA9_PRO: spa_audio_wma_profile = 5;
pub const SPA_AUDIO_WMA_PROFILE_WMA9_LOSSLESS: spa_audio_wma_profile = 6;
pub const SPA_AUDIO_WMA_PROFILE_WMA10_LOSSLESS: spa_audio_wma_profile = 7;
pub const SPA_AUDIO_WMA_PROFILE_CUSTOM: spa_audio_wma_profile = 65536;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_wma_profile = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_wma {
    pub rate: u32,
    pub channels: u32,
    pub bitrate: u32,
    pub block_align: u32,
    pub profile: spa_audio_wma_profile,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_wma"][::std::mem::size_of::<spa_audio_info_wma>() - 20usize];
    ["Alignment of spa_audio_info_wma"][::std::mem::align_of::<spa_audio_info_wma>() - 4usize];
    ["Offset of field: spa_audio_info_wma::rate"]
        [::std::mem::offset_of!(spa_audio_info_wma, rate) - 0usize];
    ["Offset of field: spa_audio_info_wma::channels"]
        [::std::mem::offset_of!(spa_audio_info_wma, channels) - 4usize];
    ["Offset of field: spa_audio_info_wma::bitrate"]
        [::std::mem::offset_of!(spa_audio_info_wma, bitrate) - 8usize];
    ["Offset of field: spa_audio_info_wma::block_align"]
        [::std::mem::offset_of!(spa_audio_info_wma, block_align) - 12usize];
    ["Offset of field: spa_audio_info_wma::profile"]
        [::std::mem::offset_of!(spa_audio_info_wma, profile) - 16usize];
};
pub const SPA_AUDIO_AMR_BAND_MODE_UNKNOWN: spa_audio_amr_band_mode = 0;
pub const SPA_AUDIO_AMR_BAND_MODE_NB: spa_audio_amr_band_mode = 1;
pub const SPA_AUDIO_AMR_BAND_MODE_WB: spa_audio_amr_band_mode = 2;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_audio_amr_band_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_amr {
    pub rate: u32,
    pub channels: u32,
    pub band_mode: spa_audio_amr_band_mode,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_amr"][::std::mem::size_of::<spa_audio_info_amr>() - 12usize];
    ["Alignment of spa_audio_info_amr"][::std::mem::align_of::<spa_audio_info_amr>() - 4usize];
    ["Offset of field: spa_audio_info_amr::rate"]
        [::std::mem::offset_of!(spa_audio_info_amr, rate) - 0usize];
    ["Offset of field: spa_audio_info_amr::channels"]
        [::std::mem::offset_of!(spa_audio_info_amr, channels) - 4usize];
    ["Offset of field: spa_audio_info_amr::band_mode"]
        [::std::mem::offset_of!(spa_audio_info_amr, band_mode) - 8usize];
};
pub const SPA_BLUETOOTH_AUDIO_CODEC_START: spa_bluetooth_audio_codec = 0;
pub const SPA_BLUETOOTH_AUDIO_CODEC_SBC: spa_bluetooth_audio_codec = 1;
pub const SPA_BLUETOOTH_AUDIO_CODEC_SBC_XQ: spa_bluetooth_audio_codec = 2;
pub const SPA_BLUETOOTH_AUDIO_CODEC_MPEG: spa_bluetooth_audio_codec = 3;
pub const SPA_BLUETOOTH_AUDIO_CODEC_AAC: spa_bluetooth_audio_codec = 4;
pub const SPA_BLUETOOTH_AUDIO_CODEC_AAC_ELD: spa_bluetooth_audio_codec = 5;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX: spa_bluetooth_audio_codec = 6;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX_HD: spa_bluetooth_audio_codec = 7;
pub const SPA_BLUETOOTH_AUDIO_CODEC_LDAC: spa_bluetooth_audio_codec = 8;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL: spa_bluetooth_audio_codec = 9;
pub const SPA_BLUETOOTH_AUDIO_CODEC_APTX_LL_DUPLEX: spa_bluetooth_audio_codec = 10;
pub const SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM: spa_bluetooth_audio_codec = 11;
pub const SPA_BLUETOOTH_AUDIO_CODEC_FASTSTREAM_DUPLEX: spa_bluetooth_audio_codec = 12;
pub const SPA_BLUETOOTH_AUDIO_CODEC_LC3PLUS_HR: spa_bluetooth_audio_codec = 13;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05: spa_bluetooth_audio_codec = 14;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_51: spa_bluetooth_audio_codec = 15;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_71: spa_bluetooth_audio_codec = 16;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_DUPLEX: spa_bluetooth_audio_codec = 17;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_05_PRO: spa_bluetooth_audio_codec = 18;
pub const SPA_BLUETOOTH_AUDIO_CODEC_OPUS_G: spa_bluetooth_audio_codec = 19;
pub const SPA_BLUETOOTH_AUDIO_CODEC_CVSD: spa_bluetooth_audio_codec = 256;
pub const SPA_BLUETOOTH_AUDIO_CODEC_MSBC: spa_bluetooth_audio_codec = 257;
pub const SPA_BLUETOOTH_AUDIO_CODEC_LC3_SWB: spa_bluetooth_audio_codec = 258;
pub const SPA_BLUETOOTH_AUDIO_CODEC_LC3: spa_bluetooth_audio_codec = 512;
pub const SPA_BLUETOOTH_AUDIO_CODEC_G722: spa_bluetooth_audio_codec = 768;
#[doc = " \\addtogroup spa_param\n \\{"]
pub type spa_bluetooth_audio_codec = ::std::os::raw::c_uint;
#[doc = "< unknown cositing"]
pub const SPA_VIDEO_CHROMA_SITE_UNKNOWN: spa_video_chroma_site = 0;
#[doc = "< no cositing"]
pub const SPA_VIDEO_CHROMA_SITE_NONE: spa_video_chroma_site = 1;
#[doc = "< chroma is horizontally cosited"]
pub const SPA_VIDEO_CHROMA_SITE_H_COSITED: spa_video_chroma_site = 2;
#[doc = "< chroma is vertically cosited"]
pub const SPA_VIDEO_CHROMA_SITE_V_COSITED: spa_video_chroma_site = 4;
#[doc = "< chroma samples are sited on alternate lines"]
pub const SPA_VIDEO_CHROMA_SITE_ALT_LINE: spa_video_chroma_site = 8;
#[doc = " chroma samples cosited with luma samples"]
pub const SPA_VIDEO_CHROMA_SITE_COSITED: spa_video_chroma_site = 6;
#[doc = " jpeg style cositing, also for mpeg1 and mjpeg"]
pub const SPA_VIDEO_CHROMA_SITE_JPEG: spa_video_chroma_site = 1;
#[doc = " mpeg2 style cositing"]
pub const SPA_VIDEO_CHROMA_SITE_MPEG2: spa_video_chroma_site = 2;
pub const SPA_VIDEO_CHROMA_SITE_DV: spa_video_chroma_site = 14;
#[doc = " Various Chroma settings."]
pub type spa_video_chroma_site = ::std::os::raw::c_uint;
#[doc = "< unknown range"]
pub const SPA_VIDEO_COLOR_RANGE_UNKNOWN: spa_video_color_range = 0;
#[doc = "< [0..255] for 8 bit components"]
pub const SPA_VIDEO_COLOR_RANGE_0_255: spa_video_color_range = 1;
#[doc = "< [16..235] for 8 bit components. Chroma has\n[16..240] range."]
pub const SPA_VIDEO_COLOR_RANGE_16_235: spa_video_color_range = 2;
#[doc = " Possible color range values. These constants are defined for 8 bit color\n values and can be scaled for other bit depths."]
pub type spa_video_color_range = ::std::os::raw::c_uint;
#[doc = "< unknown matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_UNKNOWN: spa_video_color_matrix = 0;
#[doc = "< identity matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_RGB: spa_video_color_matrix = 1;
#[doc = "< FCC color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_FCC: spa_video_color_matrix = 2;
#[doc = "< ITU BT.709 color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_BT709: spa_video_color_matrix = 3;
#[doc = "< ITU BT.601 color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_BT601: spa_video_color_matrix = 4;
#[doc = "< SMTPE  240M color matrix"]
pub const SPA_VIDEO_COLOR_MATRIX_SMPTE240M: spa_video_color_matrix = 5;
#[doc = "<  ITU-R BT.2020 color matrix. since 1.6."]
pub const SPA_VIDEO_COLOR_MATRIX_BT2020: spa_video_color_matrix = 6;
#[doc = " The color matrix is used to convert between Y'PbPr and\n non-linear RGB (R'G'B')"]
pub type spa_video_color_matrix = ::std::os::raw::c_uint;
#[doc = "< unknown transfer function"]
pub const SPA_VIDEO_TRANSFER_UNKNOWN: spa_video_transfer_function = 0;
#[doc = "< linear RGB, gamma 1.0 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA10: spa_video_transfer_function = 1;
#[doc = "< Gamma 1.8 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA18: spa_video_transfer_function = 2;
#[doc = "< Gamma 2.0 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA20: spa_video_transfer_function = 3;
#[doc = "< Gamma 2.2 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA22: spa_video_transfer_function = 4;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower range"]
pub const SPA_VIDEO_TRANSFER_BT709: spa_video_transfer_function = 5;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower range"]
pub const SPA_VIDEO_TRANSFER_SMPTE240M: spa_video_transfer_function = 6;
#[doc = "< Gamma 2.4 curve with a linear segment in the lower range"]
pub const SPA_VIDEO_TRANSFER_SRGB: spa_video_transfer_function = 7;
#[doc = "< Gamma 2.8 curve"]
pub const SPA_VIDEO_TRANSFER_GAMMA28: spa_video_transfer_function = 8;
#[doc = "< Logarithmic transfer characteristic 100:1 range"]
pub const SPA_VIDEO_TRANSFER_LOG100: spa_video_transfer_function = 9;
#[doc = "< Logarithmic transfer characteristic 316.22777:1 range"]
pub const SPA_VIDEO_TRANSFER_LOG316: spa_video_transfer_function = 10;
#[doc = "< Gamma 2.2 curve with a linear segment in the lower\n   range. Used for BT.2020 with 12 bits per\n   component. \\since 1.6."]
pub const SPA_VIDEO_TRANSFER_BT2020_12: spa_video_transfer_function = 11;
#[doc = "< Gamma 2.19921875. \\since 1.8"]
pub const SPA_VIDEO_TRANSFER_ADOBERGB: spa_video_transfer_function = 12;
#[doc = " The video transfer function defines the formula for converting between\n non-linear RGB (R'G'B') and linear RGB"]
pub type spa_video_transfer_function = ::std::os::raw::c_uint;
#[doc = "< unknown color primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_UNKNOWN: spa_video_color_primaries = 0;
#[doc = "< BT709 primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT709: spa_video_color_primaries = 1;
#[doc = "< BT470M primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT470M: spa_video_color_primaries = 2;
#[doc = "< BT470BG primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT470BG: spa_video_color_primaries = 3;
#[doc = "< SMPTE170M primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_SMPTE170M: spa_video_color_primaries = 4;
#[doc = "< SMPTE240M primaries"]
pub const SPA_VIDEO_COLOR_PRIMARIES_SMPTE240M: spa_video_color_primaries = 5;
#[doc = "< Generic film"]
pub const SPA_VIDEO_COLOR_PRIMARIES_FILM: spa_video_color_primaries = 6;
#[doc = "< BT2020 primaries. \\since 1.6."]
pub const SPA_VIDEO_COLOR_PRIMARIES_BT2020: spa_video_color_primaries = 7;
#[doc = "< Adobe RGB primaries. \\since 1.8"]
pub const SPA_VIDEO_COLOR_PRIMARIES_ADOBERGB: spa_video_color_primaries = 8;
#[doc = " The color primaries define the how to transform linear RGB values to and from\n the CIE XYZ colorspace."]
pub type spa_video_color_primaries = ::std::os::raw::c_uint;
#[doc = " spa_video_colorimetry:\n\n Structure describing the color info."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_colorimetry {
    #[doc = "< The color range. This is the valid range for the\n    samples. It is used to convert the samples to Y'PbPr\n    values."]
    pub range: spa_video_color_range,
    #[doc = "< the color matrix. Used to convert between Y'PbPr and\n    non-linear RGB (R'G'B')"]
    pub matrix: spa_video_color_matrix,
    #[doc = "< The transfer function. Used to convert between\n   R'G'B' and RGB"]
    pub transfer: spa_video_transfer_function,
    #[doc = "< Color primaries. Used to convert between R'G'B'\n   and CIE XYZ"]
    pub primaries: spa_video_color_primaries,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_colorimetry"][::std::mem::size_of::<spa_video_colorimetry>() - 16usize];
    ["Alignment of spa_video_colorimetry"]
        [::std::mem::align_of::<spa_video_colorimetry>() - 4usize];
    ["Offset of field: spa_video_colorimetry::range"]
        [::std::mem::offset_of!(spa_video_colorimetry, range) - 0usize];
    ["Offset of field: spa_video_colorimetry::matrix"]
        [::std::mem::offset_of!(spa_video_colorimetry, matrix) - 4usize];
    ["Offset of field: spa_video_colorimetry::transfer"]
        [::std::mem::offset_of!(spa_video_colorimetry, transfer) - 8usize];
    ["Offset of field: spa_video_colorimetry::primaries"]
        [::std::mem::offset_of!(spa_video_colorimetry, primaries) - 12usize];
};
#[doc = " A special value indicating no multiview information. Used in spa_video_info and other\n places to indicate that no specific multiview handling has been requested or provided.\n This value is never carried on caps."]
pub const SPA_VIDEO_MULTIVIEW_MODE_NONE: spa_video_multiview_mode = -1;
#[doc = "< All frames are monoscopic"]
pub const SPA_VIDEO_MULTIVIEW_MODE_MONO: spa_video_multiview_mode = 0;
#[doc = "< All frames represent a left-eye view"]
pub const SPA_VIDEO_MULTIVIEW_MODE_LEFT: spa_video_multiview_mode = 1;
#[doc = "< All frames represent a right-eye view"]
pub const SPA_VIDEO_MULTIVIEW_MODE_RIGHT: spa_video_multiview_mode = 2;
#[doc = "< Left and right eye views are provided\n   in the left and right half of the frame\n   respectively."]
pub const SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE: spa_video_multiview_mode = 3;
#[doc = "< Left and right eye views are provided\n   in the left and right half of the\n   frame, but have been sampled using\n   quincunx method, with half-pixel offset\n   between the 2 views."]
pub const SPA_VIDEO_MULTIVIEW_MODE_SIDE_BY_SIDE_QUINCUNX: spa_video_multiview_mode = 4;
#[doc = "< Alternating vertical columns of pixels\n   represent the left and right eye view\n   respectively."]
pub const SPA_VIDEO_MULTIVIEW_MODE_COLUMN_INTERLEAVED: spa_video_multiview_mode = 5;
#[doc = "< Alternating horizontal rows of pixels\n   represent the left and right eye view\n   respectively."]
pub const SPA_VIDEO_MULTIVIEW_MODE_ROW_INTERLEAVED: spa_video_multiview_mode = 6;
#[doc = "< The top half of the frame contains the\n   left eye, and the bottom half the right\n   eye."]
pub const SPA_VIDEO_MULTIVIEW_MODE_TOP_BOTTOM: spa_video_multiview_mode = 7;
#[doc = "< Pixels are arranged with alternating\n   pixels representing left and right eye\n   views in a checkerboard fashion."]
pub const SPA_VIDEO_MULTIVIEW_MODE_CHECKERBOARD: spa_video_multiview_mode = 8;
#[doc = "< Left and right eye views are provided\n   in separate frames alternately."]
pub const SPA_VIDEO_MULTIVIEW_MODE_FRAME_BY_FRAME: spa_video_multiview_mode = 32;
#[doc = "< Multipleindependent views are\n   provided in separate frames in\n   sequence. This method only applies to\n   raw video buffers at the moment.\n   Specific view identification is via\n   metadata on raw video buffers."]
pub const SPA_VIDEO_MULTIVIEW_MODE_MULTIVIEW_FRAME_BY_FRAME: spa_video_multiview_mode = 33;
#[doc = "< Multiple views are provided as separate\n   \\ref spa_data framebuffers attached\n   to each \\ref spa_buffer, described\n   by the metadata"]
pub const SPA_VIDEO_MULTIVIEW_MODE_SEPARATED: spa_video_multiview_mode = 34;
#[doc = " All possible stereoscopic 3D and multiview representations.\n In conjunction with \\ref spa_video_multiview_flags, describes how\n multiview content is being transported in the stream."]
pub type spa_video_multiview_mode = ::std::os::raw::c_int;
#[doc = "< No flags"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_NONE: spa_video_multiview_flags = 0;
#[doc = "< For stereo streams, the normal arrangement\n   of left and right views is reversed"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_VIEW_FIRST: spa_video_multiview_flags = 1;
#[doc = "< The left view is vertically mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLIPPED: spa_video_multiview_flags = 2;
#[doc = "< The left view is horizontally mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_LEFT_FLOPPED: spa_video_multiview_flags = 4;
#[doc = "< The right view is vertically mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLIPPED: spa_video_multiview_flags = 8;
#[doc = "< The right view is horizontally mirrored"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_RIGHT_FLOPPED: spa_video_multiview_flags = 16;
#[doc = "< For frame-packed multiview\n   modes, indicates that the individual\n   views have been encoded with half the true\n   width or height and should be scaled back\n   up for display. This flag is used for\n   overriding input layout interpretation\n   by adjusting pixel-aspect-ratio.\n   For side-by-side, column interleaved or\n   checkerboard packings, the\n   pixel width will be doubled.\n   For row interleaved and\n   top-bottom encodings, pixel height will\n   be doubled"]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_HALF_ASPECT: spa_video_multiview_flags = 16384;
#[doc = "< The video stream contains both\n   mono and multiview portions,\n   signalled on each buffer by the\n   absence or presence of a buffer flag."]
pub const SPA_VIDEO_MULTIVIEW_FLAGS_MIXED_MONO: spa_video_multiview_flags = 32768;
#[doc = " spa_video_multiview_flags are used to indicate extra properties of a\n stereo/multiview stream beyond the frame layout and buffer mapping\n that is conveyed in the \\ref spa_video_multiview_mode."]
pub type spa_video_multiview_flags = ::std::os::raw::c_uint;
pub const SPA_VIDEO_FORMAT_UNKNOWN: spa_video_format = 0;
pub const SPA_VIDEO_FORMAT_ENCODED: spa_video_format = 1;
pub const SPA_VIDEO_FORMAT_I420: spa_video_format = 2;
pub const SPA_VIDEO_FORMAT_YV12: spa_video_format = 3;
pub const SPA_VIDEO_FORMAT_YUY2: spa_video_format = 4;
pub const SPA_VIDEO_FORMAT_UYVY: spa_video_format = 5;
pub const SPA_VIDEO_FORMAT_AYUV: spa_video_format = 6;
pub const SPA_VIDEO_FORMAT_RGBx: spa_video_format = 7;
pub const SPA_VIDEO_FORMAT_BGRx: spa_video_format = 8;
pub const SPA_VIDEO_FORMAT_xRGB: spa_video_format = 9;
pub const SPA_VIDEO_FORMAT_xBGR: spa_video_format = 10;
pub const SPA_VIDEO_FORMAT_RGBA: spa_video_format = 11;
pub const SPA_VIDEO_FORMAT_BGRA: spa_video_format = 12;
pub const SPA_VIDEO_FORMAT_ARGB: spa_video_format = 13;
pub const SPA_VIDEO_FORMAT_ABGR: spa_video_format = 14;
pub const SPA_VIDEO_FORMAT_RGB: spa_video_format = 15;
pub const SPA_VIDEO_FORMAT_BGR: spa_video_format = 16;
pub const SPA_VIDEO_FORMAT_Y41B: spa_video_format = 17;
pub const SPA_VIDEO_FORMAT_Y42B: spa_video_format = 18;
pub const SPA_VIDEO_FORMAT_YVYU: spa_video_format = 19;
pub const SPA_VIDEO_FORMAT_Y444: spa_video_format = 20;
pub const SPA_VIDEO_FORMAT_v210: spa_video_format = 21;
pub const SPA_VIDEO_FORMAT_v216: spa_video_format = 22;
pub const SPA_VIDEO_FORMAT_NV12: spa_video_format = 23;
pub const SPA_VIDEO_FORMAT_NV21: spa_video_format = 24;
pub const SPA_VIDEO_FORMAT_GRAY8: spa_video_format = 25;
pub const SPA_VIDEO_FORMAT_GRAY16_BE: spa_video_format = 26;
pub const SPA_VIDEO_FORMAT_GRAY16_LE: spa_video_format = 27;
pub const SPA_VIDEO_FORMAT_v308: spa_video_format = 28;
pub const SPA_VIDEO_FORMAT_RGB16: spa_video_format = 29;
pub const SPA_VIDEO_FORMAT_BGR16: spa_video_format = 30;
pub const SPA_VIDEO_FORMAT_RGB15: spa_video_format = 31;
pub const SPA_VIDEO_FORMAT_BGR15: spa_video_format = 32;
pub const SPA_VIDEO_FORMAT_UYVP: spa_video_format = 33;
pub const SPA_VIDEO_FORMAT_A420: spa_video_format = 34;
pub const SPA_VIDEO_FORMAT_RGB8P: spa_video_format = 35;
pub const SPA_VIDEO_FORMAT_YUV9: spa_video_format = 36;
pub const SPA_VIDEO_FORMAT_YVU9: spa_video_format = 37;
pub const SPA_VIDEO_FORMAT_IYU1: spa_video_format = 38;
pub const SPA_VIDEO_FORMAT_ARGB64: spa_video_format = 39;
pub const SPA_VIDEO_FORMAT_AYUV64: spa_video_format = 40;
pub const SPA_VIDEO_FORMAT_r210: spa_video_format = 41;
pub const SPA_VIDEO_FORMAT_I420_10BE: spa_video_format = 42;
pub const SPA_VIDEO_FORMAT_I420_10LE: spa_video_format = 43;
pub const SPA_VIDEO_FORMAT_I422_10BE: spa_video_format = 44;
pub const SPA_VIDEO_FORMAT_I422_10LE: spa_video_format = 45;
pub const SPA_VIDEO_FORMAT_Y444_10BE: spa_video_format = 46;
pub const SPA_VIDEO_FORMAT_Y444_10LE: spa_video_format = 47;
pub const SPA_VIDEO_FORMAT_GBR: spa_video_format = 48;
pub const SPA_VIDEO_FORMAT_GBR_10BE: spa_video_format = 49;
pub const SPA_VIDEO_FORMAT_GBR_10LE: spa_video_format = 50;
pub const SPA_VIDEO_FORMAT_NV16: spa_video_format = 51;
pub const SPA_VIDEO_FORMAT_NV24: spa_video_format = 52;
pub const SPA_VIDEO_FORMAT_NV12_64Z32: spa_video_format = 53;
pub const SPA_VIDEO_FORMAT_A420_10BE: spa_video_format = 54;
pub const SPA_VIDEO_FORMAT_A420_10LE: spa_video_format = 55;
pub const SPA_VIDEO_FORMAT_A422_10BE: spa_video_format = 56;
pub const SPA_VIDEO_FORMAT_A422_10LE: spa_video_format = 57;
pub const SPA_VIDEO_FORMAT_A444_10BE: spa_video_format = 58;
pub const SPA_VIDEO_FORMAT_A444_10LE: spa_video_format = 59;
pub const SPA_VIDEO_FORMAT_NV61: spa_video_format = 60;
pub const SPA_VIDEO_FORMAT_P010_10BE: spa_video_format = 61;
pub const SPA_VIDEO_FORMAT_P010_10LE: spa_video_format = 62;
pub const SPA_VIDEO_FORMAT_IYU2: spa_video_format = 63;
pub const SPA_VIDEO_FORMAT_VYUY: spa_video_format = 64;
pub const SPA_VIDEO_FORMAT_GBRA: spa_video_format = 65;
pub const SPA_VIDEO_FORMAT_GBRA_10BE: spa_video_format = 66;
pub const SPA_VIDEO_FORMAT_GBRA_10LE: spa_video_format = 67;
pub const SPA_VIDEO_FORMAT_GBR_12BE: spa_video_format = 68;
pub const SPA_VIDEO_FORMAT_GBR_12LE: spa_video_format = 69;
pub const SPA_VIDEO_FORMAT_GBRA_12BE: spa_video_format = 70;
pub const SPA_VIDEO_FORMAT_GBRA_12LE: spa_video_format = 71;
pub const SPA_VIDEO_FORMAT_I420_12BE: spa_video_format = 72;
pub const SPA_VIDEO_FORMAT_I420_12LE: spa_video_format = 73;
pub const SPA_VIDEO_FORMAT_I422_12BE: spa_video_format = 74;
pub const SPA_VIDEO_FORMAT_I422_12LE: spa_video_format = 75;
pub const SPA_VIDEO_FORMAT_Y444_12BE: spa_video_format = 76;
pub const SPA_VIDEO_FORMAT_Y444_12LE: spa_video_format = 77;
pub const SPA_VIDEO_FORMAT_RGBA_F16: spa_video_format = 78;
pub const SPA_VIDEO_FORMAT_RGBA_F32: spa_video_format = 79;
#[doc = "< 32-bit x:R:G:B 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_xRGB_210LE: spa_video_format = 80;
#[doc = "< 32-bit x:B:G:R 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_xBGR_210LE: spa_video_format = 81;
#[doc = "< 32-bit R:G:B:x 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_RGBx_102LE: spa_video_format = 82;
#[doc = "< 32-bit B:G:R:x 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_BGRx_102LE: spa_video_format = 83;
#[doc = "< 32-bit A:R:G:B 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_ARGB_210LE: spa_video_format = 84;
#[doc = "< 32-bit A:B:G:R 2:10:10:10 little endian"]
pub const SPA_VIDEO_FORMAT_ABGR_210LE: spa_video_format = 85;
#[doc = "< 32-bit R:G:B:A 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_RGBA_102LE: spa_video_format = 86;
#[doc = "< 32-bit B:G:R:A 10:10:10:2 little endian"]
pub const SPA_VIDEO_FORMAT_BGRA_102LE: spa_video_format = 87;
pub const SPA_VIDEO_FORMAT_DSP_F32: spa_video_format = 79;
#[doc = " Video formats\n\n The components are in general described in big-endian order. There are some\n exceptions (e.g. RGB15 and RGB16) which use the host endianness.\n\n Most of the formats are identical to their GStreamer equivalent. See the\n GStreamer video formats documentation for more details:\n\n https://gstreamer.freedesktop.org/documentation/additional/design/mediatype-video-raw.html#formats"]
pub type spa_video_format = ::std::os::raw::c_uint;
#[doc = "< no flags"]
pub const SPA_VIDEO_FLAG_NONE: spa_video_flags = 0;
#[doc = "< a variable fps is selected, fps_n and fps_d\n   denote the maximum fps of the video"]
pub const SPA_VIDEO_FLAG_VARIABLE_FPS: spa_video_flags = 1;
#[doc = "< Each color has been scaled by the alpha value."]
pub const SPA_VIDEO_FLAG_PREMULTIPLIED_ALPHA: spa_video_flags = 2;
#[doc = "< use the format modifier"]
pub const SPA_VIDEO_FLAG_MODIFIER: spa_video_flags = 4;
#[doc = "< format modifier was not fixated yet"]
pub const SPA_VIDEO_FLAG_MODIFIER_FIXATION_REQUIRED: spa_video_flags = 8;
#[doc = " Extra video flags"]
pub type spa_video_flags = ::std::os::raw::c_uint;
#[doc = "< all frames are progressive"]
pub const SPA_VIDEO_INTERLACE_MODE_PROGRESSIVE: spa_video_interlace_mode = 0;
#[doc = "< 2 fields are interleaved in one video frame.\n Extra buffer flags describe the field order."]
pub const SPA_VIDEO_INTERLACE_MODE_INTERLEAVED: spa_video_interlace_mode = 1;
#[doc = "< frames contains both interlaced and progressive\n   video, the buffer flags describe the frame and\n   fields."]
pub const SPA_VIDEO_INTERLACE_MODE_MIXED: spa_video_interlace_mode = 2;
#[doc = "< 2 fields are stored in one buffer, use the\n   frame ID to get access to the required\n   field. For multiview (the 'views'\n   property > 1) the fields of view N can\n   be found at frame ID (N * 2) and (N *\n   2) + 1. Each field has only half the\n   amount of lines as noted in the height\n   property. This mode requires multiple\n   spa_data to describe the fields."]
pub const SPA_VIDEO_INTERLACE_MODE_FIELDS: spa_video_interlace_mode = 3;
#[doc = " The possible values of the #spa_video_interlace_mode describing the interlace\n mode of the stream."]
pub type spa_video_interlace_mode = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_raw {
    #[doc = "< the format"]
    pub format: spa_video_format,
    #[doc = "< extra video flags"]
    pub flags: u32,
    #[doc = "< format modifier\n only used with DMA-BUF"]
    pub modifier: u64,
    #[doc = "< the frame size of the video"]
    pub size: spa_rectangle,
    #[doc = "< the framerate of the video, 0/1 means variable rate"]
    pub framerate: spa_fraction,
    #[doc = "< the maximum framerate of the video. This is only valid when\n\\ref framerate is 0/1"]
    pub max_framerate: spa_fraction,
    #[doc = "< the number of views in this video"]
    pub views: u32,
    #[doc = "< the interlace mode"]
    pub interlace_mode: spa_video_interlace_mode,
    #[doc = "< the pixel aspect ratio"]
    pub pixel_aspect_ratio: spa_fraction,
    #[doc = "< multiview mode"]
    pub multiview_mode: spa_video_multiview_mode,
    #[doc = "< multiview flags"]
    pub multiview_flags: spa_video_multiview_flags,
    #[doc = "< the chroma siting"]
    pub chroma_site: spa_video_chroma_site,
    #[doc = "< the color range. This is the valid range for the samples.\n   It is used to convert the samples to Y'PbPr values."]
    pub color_range: spa_video_color_range,
    #[doc = "< the color matrix. Used to convert between Y'PbPr and\n   non-linear RGB (R'G'B')"]
    pub color_matrix: spa_video_color_matrix,
    #[doc = "< the transfer function. used to convert between R'G'B' and RGB"]
    pub transfer_function: spa_video_transfer_function,
    #[doc = "< color primaries. used to convert between R'G'B' and CIE XYZ"]
    pub color_primaries: spa_video_color_primaries,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_raw"][::std::mem::size_of::<spa_video_info_raw>() - 88usize];
    ["Alignment of spa_video_info_raw"][::std::mem::align_of::<spa_video_info_raw>() - 8usize];
    ["Offset of field: spa_video_info_raw::format"]
        [::std::mem::offset_of!(spa_video_info_raw, format) - 0usize];
    ["Offset of field: spa_video_info_raw::flags"]
        [::std::mem::offset_of!(spa_video_info_raw, flags) - 4usize];
    ["Offset of field: spa_video_info_raw::modifier"]
        [::std::mem::offset_of!(spa_video_info_raw, modifier) - 8usize];
    ["Offset of field: spa_video_info_raw::size"]
        [::std::mem::offset_of!(spa_video_info_raw, size) - 16usize];
    ["Offset of field: spa_video_info_raw::framerate"]
        [::std::mem::offset_of!(spa_video_info_raw, framerate) - 24usize];
    ["Offset of field: spa_video_info_raw::max_framerate"]
        [::std::mem::offset_of!(spa_video_info_raw, max_framerate) - 32usize];
    ["Offset of field: spa_video_info_raw::views"]
        [::std::mem::offset_of!(spa_video_info_raw, views) - 40usize];
    ["Offset of field: spa_video_info_raw::interlace_mode"]
        [::std::mem::offset_of!(spa_video_info_raw, interlace_mode) - 44usize];
    ["Offset of field: spa_video_info_raw::pixel_aspect_ratio"]
        [::std::mem::offset_of!(spa_video_info_raw, pixel_aspect_ratio) - 48usize];
    ["Offset of field: spa_video_info_raw::multiview_mode"]
        [::std::mem::offset_of!(spa_video_info_raw, multiview_mode) - 56usize];
    ["Offset of field: spa_video_info_raw::multiview_flags"]
        [::std::mem::offset_of!(spa_video_info_raw, multiview_flags) - 60usize];
    ["Offset of field: spa_video_info_raw::chroma_site"]
        [::std::mem::offset_of!(spa_video_info_raw, chroma_site) - 64usize];
    ["Offset of field: spa_video_info_raw::color_range"]
        [::std::mem::offset_of!(spa_video_info_raw, color_range) - 68usize];
    ["Offset of field: spa_video_info_raw::color_matrix"]
        [::std::mem::offset_of!(spa_video_info_raw, color_matrix) - 72usize];
    ["Offset of field: spa_video_info_raw::transfer_function"]
        [::std::mem::offset_of!(spa_video_info_raw, transfer_function) - 76usize];
    ["Offset of field: spa_video_info_raw::color_primaries"]
        [::std::mem::offset_of!(spa_video_info_raw, color_primaries) - 80usize];
};
unsafe extern "C" {
    #[link_name = "spa_type_video_format_from_short_name_libspa_rs"]
    pub fn spa_type_video_format_from_short_name(name: *const ::std::os::raw::c_char) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_type_video_format_to_short_name_libspa_rs"]
    pub fn spa_type_video_format_to_short_name(type_: u32) -> *const ::std::os::raw::c_char;
}
pub const SPA_PARAM_LATENCY_START: spa_param_latency = 0;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const SPA_PARAM_LATENCY_direction: spa_param_latency = 1;
#[doc = "< min latency relative to quantum (Float)"]
pub const SPA_PARAM_LATENCY_minQuantum: spa_param_latency = 2;
#[doc = "< max latency relative to quantum (Float)"]
pub const SPA_PARAM_LATENCY_maxQuantum: spa_param_latency = 3;
#[doc = "< min latency (Int) relative to graph rate"]
pub const SPA_PARAM_LATENCY_minRate: spa_param_latency = 4;
#[doc = "< max latency (Int) relative to graph rate"]
pub const SPA_PARAM_LATENCY_maxRate: spa_param_latency = 5;
#[doc = "< min latency (Long) in nanoseconds"]
pub const SPA_PARAM_LATENCY_minNs: spa_param_latency = 6;
#[doc = "< max latency (Long) in nanoseconds"]
pub const SPA_PARAM_LATENCY_maxNs: spa_param_latency = 7;
#[doc = " Properties for SPA_TYPE_OBJECT_ParamLatency\n\n The latency indicates:\n\n - for playback: time delay between start of a graph cycle, and the rendering of\n   the first sample of that cycle in audio output.\n\n - for capture: time delay between start of a graph cycle, and the first sample\n   of that cycle having occurred in audio input.\n\n For physical output/input, the latency is intended to correspond to the\n rendering/capture of physical audio, including hardware internal rendering delay.\n\n The latency values are adjusted by \\ref SPA_PROP_latencyOffsetNsec or\n SPA_PARAM_ProcessLatency, if present. (e.g. for ALSA this is used to adjust for\n the internal hardware latency)."]
pub type spa_param_latency = ::std::os::raw::c_uint;
#[doc = " helper structure for managing latency objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_latency_info {
    pub direction: spa_direction,
    pub min_quantum: f32,
    pub max_quantum: f32,
    pub min_rate: i32,
    pub max_rate: i32,
    pub min_ns: i64,
    pub max_ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_latency_info"][::std::mem::size_of::<spa_latency_info>() - 40usize];
    ["Alignment of spa_latency_info"][::std::mem::align_of::<spa_latency_info>() - 8usize];
    ["Offset of field: spa_latency_info::direction"]
        [::std::mem::offset_of!(spa_latency_info, direction) - 0usize];
    ["Offset of field: spa_latency_info::min_quantum"]
        [::std::mem::offset_of!(spa_latency_info, min_quantum) - 4usize];
    ["Offset of field: spa_latency_info::max_quantum"]
        [::std::mem::offset_of!(spa_latency_info, max_quantum) - 8usize];
    ["Offset of field: spa_latency_info::min_rate"]
        [::std::mem::offset_of!(spa_latency_info, min_rate) - 12usize];
    ["Offset of field: spa_latency_info::max_rate"]
        [::std::mem::offset_of!(spa_latency_info, max_rate) - 16usize];
    ["Offset of field: spa_latency_info::min_ns"]
        [::std::mem::offset_of!(spa_latency_info, min_ns) - 24usize];
    ["Offset of field: spa_latency_info::max_ns"]
        [::std::mem::offset_of!(spa_latency_info, max_ns) - 32usize];
};
pub const SPA_PARAM_PROCESS_LATENCY_START: spa_param_process_latency = 0;
#[doc = "< latency relative to quantum (Float)"]
pub const SPA_PARAM_PROCESS_LATENCY_quantum: spa_param_process_latency = 1;
#[doc = "< latency (Int) relative to graph rate"]
pub const SPA_PARAM_PROCESS_LATENCY_rate: spa_param_process_latency = 2;
#[doc = "< latency (Long) in nanoseconds"]
pub const SPA_PARAM_PROCESS_LATENCY_ns: spa_param_process_latency = 3;
#[doc = " Properties for SPA_TYPE_OBJECT_ParamProcessLatency\n\n The processing latency indicates logical time delay between a sample in an input port,\n and a corresponding sample in an output port, relative to the graph time."]
pub type spa_param_process_latency = ::std::os::raw::c_uint;
#[doc = " Helper structure for managing process latency objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq)]
pub struct spa_process_latency_info {
    pub quantum: f32,
    pub rate: i32,
    pub ns: i64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_process_latency_info"]
        [::std::mem::size_of::<spa_process_latency_info>() - 16usize];
    ["Alignment of spa_process_latency_info"]
        [::std::mem::align_of::<spa_process_latency_info>() - 8usize];
    ["Offset of field: spa_process_latency_info::quantum"]
        [::std::mem::offset_of!(spa_process_latency_info, quantum) - 0usize];
    ["Offset of field: spa_process_latency_info::rate"]
        [::std::mem::offset_of!(spa_process_latency_info, rate) - 4usize];
    ["Offset of field: spa_process_latency_info::ns"]
        [::std::mem::offset_of!(spa_process_latency_info, ns) - 8usize];
};
pub const SPA_PROFILER_START: spa_profiler = 0;
#[doc = "< driver related profiler properties"]
pub const SPA_PROFILER_START_Driver: spa_profiler = 65536;
#[doc = "< Generic info, counter and CPU load,\n (Struct(\n      Long : counter,\n      Float : cpu_load fast,\n      Float : cpu_load medium,\n      Float : cpu_load slow),\n      Int : xrun-count))"]
pub const SPA_PROFILER_info: spa_profiler = 65537;
#[doc = "< clock information\n  (Struct(\n      Int : clock flags,\n      Int : clock id,\n      String: clock name,\n      Long : clock nsec,\n      Fraction : clock rate,\n      Long : clock position,\n      Long : clock duration,\n      Long : clock delay,\n      Double : clock rate_diff,\n      Long : clock next_nsec,\n      Int : transport_state,\n      Int : clock cycle,\n      Long : xrun duration))"]
pub const SPA_PROFILER_clock: spa_profiler = 65538;
#[doc = "< generic driver info block\n  (Struct(\n      Int : driver_id,\n      String : name,\n      Long : driver prev_signal,\n      Long : driver signal,\n      Long : driver awake,\n      Long : driver finish,\n      Int : driver status,\n      Fraction : latency,\n      Int : xrun_count))"]
pub const SPA_PROFILER_driverBlock: spa_profiler = 65539;
#[doc = "< follower related profiler properties"]
pub const SPA_PROFILER_START_Follower: spa_profiler = 131072;
#[doc = "< generic follower info block\n  (Struct(\n      Int : id,\n      String : name,\n      Long : prev_signal,\n      Long : signal,\n      Long : awake,\n      Long : finish,\n      Int : status,\n      Fraction : latency,\n      Int : xrun_count))"]
pub const SPA_PROFILER_followerBlock: spa_profiler = 131073;
#[doc = "< follower clock information\n  (Struct(\n      Int : clock id,\n      String: clock name,\n      Long : clock nsec,\n      Fraction : clock rate,\n      Long : clock position,\n      Long : clock duration,\n      Long : clock delay,\n      Double : clock rate_diff,\n      Long : clock next_nsec,\n      Long : xrun duration))"]
pub const SPA_PROFILER_followerClock: spa_profiler = 131074;
pub const SPA_PROFILER_START_CUSTOM: spa_profiler = 16777216;
#[doc = " properties for SPA_TYPE_OBJECT_Profiler"]
pub type spa_profiler = ::std::os::raw::c_uint;
pub const SPA_PARAM_TAG_START: spa_param_tag = 0;
#[doc = "< direction, input/output (Id enum spa_direction)"]
pub const SPA_PARAM_TAG_direction: spa_param_tag = 1;
#[doc = "< Struct(\n      Int: n_items\n      (String: key\n       String: value)*\n  )"]
pub const SPA_PARAM_TAG_info: spa_param_tag = 2;
#[doc = " properties for SPA_TYPE_OBJECT_ParamTag"]
pub type spa_param_tag = ::std::os::raw::c_uint;
#[doc = " helper structure for managing tag objects"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_tag_info {
    pub direction: spa_direction,
    pub info: *const spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_tag_info"][::std::mem::size_of::<spa_tag_info>() - 16usize];
    ["Alignment of spa_tag_info"][::std::mem::align_of::<spa_tag_info>() - 8usize];
    ["Offset of field: spa_tag_info::direction"]
        [::std::mem::offset_of!(spa_tag_info, direction) - 0usize];
    ["Offset of field: spa_tag_info::info"][::std::mem::offset_of!(spa_tag_info, info) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_debug_type_find_libspa_rs"]
    pub fn spa_debug_type_find(info: *const spa_type_info, type_: u32) -> *const spa_type_info;
}
unsafe extern "C" {
    #[link_name = "spa_debug_type_short_name_libspa_rs"]
    pub fn spa_debug_type_short_name(
        name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_debug_type_find_name_libspa_rs"]
    pub fn spa_debug_type_find_name(
        info: *const spa_type_info,
        type_: u32,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_debug_type_find_short_name_libspa_rs"]
    pub fn spa_debug_type_find_short_name(
        info: *const spa_type_info,
        type_: u32,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_debug_type_find_type_libspa_rs"]
    pub fn spa_debug_type_find_type(
        info: *const spa_type_info,
        name: *const ::std::os::raw::c_char,
    ) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_debug_type_find_short_libspa_rs"]
    pub fn spa_debug_type_find_short(
        info: *const spa_type_info,
        name: *const ::std::os::raw::c_char,
    ) -> *const spa_type_info;
}
unsafe extern "C" {
    #[link_name = "spa_debug_type_find_type_short_libspa_rs"]
    pub fn spa_debug_type_find_type_short(
        info: *const spa_type_info,
        name: *const ::std::os::raw::c_char,
    ) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_debugc_buffer_libspa_rs"]
    pub fn spa_debugc_buffer(
        ctx: *mut spa_debug_context,
        indent: ::std::os::raw::c_int,
        buffer: *const spa_buffer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_buffer_libspa_rs"]
    pub fn spa_debug_buffer(
        indent: ::std::os::raw::c_int,
        buffer: *const spa_buffer,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup spa_dict\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dict_item {
    pub key: *const ::std::os::raw::c_char,
    pub value: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dict_item"][::std::mem::size_of::<spa_dict_item>() - 16usize];
    ["Alignment of spa_dict_item"][::std::mem::align_of::<spa_dict_item>() - 8usize];
    ["Offset of field: spa_dict_item::key"][::std::mem::offset_of!(spa_dict_item, key) - 0usize];
    ["Offset of field: spa_dict_item::value"]
        [::std::mem::offset_of!(spa_dict_item, value) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dict {
    pub flags: u32,
    pub n_items: u32,
    pub items: *const spa_dict_item,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dict"][::std::mem::size_of::<spa_dict>() - 16usize];
    ["Alignment of spa_dict"][::std::mem::align_of::<spa_dict>() - 8usize];
    ["Offset of field: spa_dict::flags"][::std::mem::offset_of!(spa_dict, flags) - 0usize];
    ["Offset of field: spa_dict::n_items"][::std::mem::offset_of!(spa_dict, n_items) - 4usize];
    ["Offset of field: spa_dict::items"][::std::mem::offset_of!(spa_dict, items) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_dict_item_compare_libspa_rs"]
    pub fn spa_dict_item_compare(
        i1: *const ::std::os::raw::c_void,
        i2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_dict_qsort_libspa_rs"]
    pub fn spa_dict_qsort(dict: *mut spa_dict);
}
unsafe extern "C" {
    #[link_name = "spa_dict_lookup_item_libspa_rs"]
    pub fn spa_dict_lookup_item(
        dict: *const spa_dict,
        key: *const ::std::os::raw::c_char,
    ) -> *const spa_dict_item;
}
unsafe extern "C" {
    #[link_name = "spa_dict_lookup_libspa_rs"]
    pub fn spa_dict_lookup(
        dict: *const spa_dict,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_debugc_dict_libspa_rs"]
    pub fn spa_debugc_dict(
        ctx: *mut spa_debug_context,
        indent: ::std::os::raw::c_int,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_dict_libspa_rs"]
    pub fn spa_debug_dict(
        indent: ::std::os::raw::c_int,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_frame {
    pub pod: spa_pod,
    pub parent: *mut spa_pod_frame,
    pub offset: u32,
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_frame"][::std::mem::size_of::<spa_pod_frame>() - 24usize];
    ["Alignment of spa_pod_frame"][::std::mem::align_of::<spa_pod_frame>() - 8usize];
    ["Offset of field: spa_pod_frame::pod"][::std::mem::offset_of!(spa_pod_frame, pod) - 0usize];
    ["Offset of field: spa_pod_frame::parent"]
        [::std::mem::offset_of!(spa_pod_frame, parent) - 8usize];
    ["Offset of field: spa_pod_frame::offset"]
        [::std::mem::offset_of!(spa_pod_frame, offset) - 16usize];
    ["Offset of field: spa_pod_frame::flags"]
        [::std::mem::offset_of!(spa_pod_frame, flags) - 20usize];
};
unsafe extern "C" {
    #[link_name = "spa_pod_is_inside_libspa_rs"]
    pub fn spa_pod_is_inside(
        pod: *const ::std::os::raw::c_void,
        size: u32,
        iter: *const ::std::os::raw::c_void,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_pod_next_libspa_rs"]
    pub fn spa_pod_next(iter: *const ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "spa_pod_prop_first_libspa_rs"]
    pub fn spa_pod_prop_first(body: *const spa_pod_object_body) -> *mut spa_pod_prop;
}
unsafe extern "C" {
    #[link_name = "spa_pod_prop_is_inside_libspa_rs"]
    pub fn spa_pod_prop_is_inside(
        body: *const spa_pod_object_body,
        size: u32,
        iter: *const spa_pod_prop,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_pod_prop_next_libspa_rs"]
    pub fn spa_pod_prop_next(iter: *const spa_pod_prop) -> *mut spa_pod_prop;
}
unsafe extern "C" {
    #[link_name = "spa_pod_control_first_libspa_rs"]
    pub fn spa_pod_control_first(body: *const spa_pod_sequence_body) -> *mut spa_pod_control;
}
unsafe extern "C" {
    #[link_name = "spa_pod_control_is_inside_libspa_rs"]
    pub fn spa_pod_control_is_inside(
        body: *const spa_pod_sequence_body,
        size: u32,
        iter: *const spa_pod_control,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_pod_control_next_libspa_rs"]
    pub fn spa_pod_control_next(iter: *const spa_pod_control) -> *mut spa_pod_control;
}
unsafe extern "C" {
    #[link_name = "spa_pod_from_data_libspa_rs"]
    pub fn spa_pod_from_data(
        data: *mut ::std::os::raw::c_void,
        maxsize: usize,
        offset: off_t,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_none_libspa_rs"]
    pub fn spa_pod_is_none(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_bool_libspa_rs"]
    pub fn spa_pod_is_bool(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_bool_libspa_rs"]
    pub fn spa_pod_get_bool(pod: *const spa_pod, value: *mut bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_id_libspa_rs"]
    pub fn spa_pod_is_id(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_id_libspa_rs"]
    pub fn spa_pod_get_id(pod: *const spa_pod, value: *mut u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_int_libspa_rs"]
    pub fn spa_pod_is_int(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_int_libspa_rs"]
    pub fn spa_pod_get_int(pod: *const spa_pod, value: *mut i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_long_libspa_rs"]
    pub fn spa_pod_is_long(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_long_libspa_rs"]
    pub fn spa_pod_get_long(pod: *const spa_pod, value: *mut i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_float_libspa_rs"]
    pub fn spa_pod_is_float(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_float_libspa_rs"]
    pub fn spa_pod_get_float(pod: *const spa_pod, value: *mut f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_double_libspa_rs"]
    pub fn spa_pod_is_double(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_double_libspa_rs"]
    pub fn spa_pod_get_double(pod: *const spa_pod, value: *mut f64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_string_libspa_rs"]
    pub fn spa_pod_is_string(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_string_libspa_rs"]
    pub fn spa_pod_get_string(
        pod: *const spa_pod,
        value: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_copy_string_libspa_rs"]
    pub fn spa_pod_copy_string(
        pod: *const spa_pod,
        maxlen: usize,
        dest: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_bytes_libspa_rs"]
    pub fn spa_pod_is_bytes(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_bytes_libspa_rs"]
    pub fn spa_pod_get_bytes(
        pod: *const spa_pod,
        value: *mut *const ::std::os::raw::c_void,
        len: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_pointer_libspa_rs"]
    pub fn spa_pod_is_pointer(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_pointer_libspa_rs"]
    pub fn spa_pod_get_pointer(
        pod: *const spa_pod,
        type_: *mut u32,
        value: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_fd_libspa_rs"]
    pub fn spa_pod_is_fd(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_fd_libspa_rs"]
    pub fn spa_pod_get_fd(pod: *const spa_pod, value: *mut i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_rectangle_libspa_rs"]
    pub fn spa_pod_is_rectangle(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_rectangle_libspa_rs"]
    pub fn spa_pod_get_rectangle(
        pod: *const spa_pod,
        value: *mut spa_rectangle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_fraction_libspa_rs"]
    pub fn spa_pod_is_fraction(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_fraction_libspa_rs"]
    pub fn spa_pod_get_fraction(
        pod: *const spa_pod,
        value: *mut spa_fraction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_bitmap_libspa_rs"]
    pub fn spa_pod_is_bitmap(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_array_libspa_rs"]
    pub fn spa_pod_is_array(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_array_libspa_rs"]
    pub fn spa_pod_get_array(
        pod: *const spa_pod,
        n_values: *mut u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "spa_pod_copy_array_libspa_rs"]
    pub fn spa_pod_copy_array(
        pod: *const spa_pod,
        type_: u32,
        values: *mut ::std::os::raw::c_void,
        max_values: u32,
    ) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_choice_libspa_rs"]
    pub fn spa_pod_is_choice(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_get_values_libspa_rs"]
    pub fn spa_pod_get_values(
        pod: *const spa_pod,
        n_vals: *mut u32,
        choice: *mut u32,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_struct_libspa_rs"]
    pub fn spa_pod_is_struct(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_object_libspa_rs"]
    pub fn spa_pod_is_object(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_object_type_libspa_rs"]
    pub fn spa_pod_is_object_type(pod: *const spa_pod, type_: u32) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_object_id_libspa_rs"]
    pub fn spa_pod_is_object_id(pod: *const spa_pod, id: u32) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_sequence_libspa_rs"]
    pub fn spa_pod_is_sequence(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_object_find_prop_libspa_rs"]
    pub fn spa_pod_object_find_prop(
        pod: *const spa_pod_object,
        start: *const spa_pod_prop,
        key: u32,
    ) -> *const spa_pod_prop;
}
unsafe extern "C" {
    #[link_name = "spa_pod_find_prop_libspa_rs"]
    pub fn spa_pod_find_prop(
        pod: *const spa_pod,
        start: *const spa_pod_prop,
        key: u32,
    ) -> *const spa_pod_prop;
}
unsafe extern "C" {
    #[link_name = "spa_pod_object_fixate_libspa_rs"]
    pub fn spa_pod_object_fixate(pod: *mut spa_pod_object) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_fixate_libspa_rs"]
    pub fn spa_pod_fixate(pod: *mut spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_object_is_fixated_libspa_rs"]
    pub fn spa_pod_object_is_fixated(pod: *const spa_pod_object) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_object_has_props_libspa_rs"]
    pub fn spa_pod_object_has_props(pod: *const spa_pod_object) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_is_fixated_libspa_rs"]
    pub fn spa_pod_is_fixated(pod: *const spa_pod) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup spa_pod\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_parser_state {
    pub offset: u32,
    pub flags: u32,
    pub frame: *mut spa_pod_frame,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_parser_state"][::std::mem::size_of::<spa_pod_parser_state>() - 16usize];
    ["Alignment of spa_pod_parser_state"][::std::mem::align_of::<spa_pod_parser_state>() - 8usize];
    ["Offset of field: spa_pod_parser_state::offset"]
        [::std::mem::offset_of!(spa_pod_parser_state, offset) - 0usize];
    ["Offset of field: spa_pod_parser_state::flags"]
        [::std::mem::offset_of!(spa_pod_parser_state, flags) - 4usize];
    ["Offset of field: spa_pod_parser_state::frame"]
        [::std::mem::offset_of!(spa_pod_parser_state, frame) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_parser {
    pub data: *const ::std::os::raw::c_void,
    pub size: u32,
    pub _padding: u32,
    pub state: spa_pod_parser_state,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_parser"][::std::mem::size_of::<spa_pod_parser>() - 32usize];
    ["Alignment of spa_pod_parser"][::std::mem::align_of::<spa_pod_parser>() - 8usize];
    ["Offset of field: spa_pod_parser::data"]
        [::std::mem::offset_of!(spa_pod_parser, data) - 0usize];
    ["Offset of field: spa_pod_parser::size"]
        [::std::mem::offset_of!(spa_pod_parser, size) - 8usize];
    ["Offset of field: spa_pod_parser::_padding"]
        [::std::mem::offset_of!(spa_pod_parser, _padding) - 12usize];
    ["Offset of field: spa_pod_parser::state"]
        [::std::mem::offset_of!(spa_pod_parser, state) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_pod_parser_init_libspa_rs"]
    pub fn spa_pod_parser_init(
        parser: *mut spa_pod_parser,
        data: *const ::std::os::raw::c_void,
        size: u32,
    );
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_pod_libspa_rs"]
    pub fn spa_pod_parser_pod(parser: *mut spa_pod_parser, pod: *const spa_pod);
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_state_libspa_rs"]
    pub fn spa_pod_parser_get_state(parser: *mut spa_pod_parser, state: *mut spa_pod_parser_state);
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_reset_libspa_rs"]
    pub fn spa_pod_parser_reset(parser: *mut spa_pod_parser, state: *mut spa_pod_parser_state);
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_deref_libspa_rs"]
    pub fn spa_pod_parser_deref(
        parser: *mut spa_pod_parser,
        offset: u32,
        size: u32,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_frame_libspa_rs"]
    pub fn spa_pod_parser_frame(
        parser: *mut spa_pod_parser,
        frame: *mut spa_pod_frame,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_push_libspa_rs"]
    pub fn spa_pod_parser_push(
        parser: *mut spa_pod_parser,
        frame: *mut spa_pod_frame,
        pod: *const spa_pod,
        offset: u32,
    );
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_current_libspa_rs"]
    pub fn spa_pod_parser_current(parser: *mut spa_pod_parser) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_advance_libspa_rs"]
    pub fn spa_pod_parser_advance(parser: *mut spa_pod_parser, pod: *const spa_pod);
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_next_libspa_rs"]
    pub fn spa_pod_parser_next(parser: *mut spa_pod_parser) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_pop_libspa_rs"]
    pub fn spa_pod_parser_pop(
        parser: *mut spa_pod_parser,
        frame: *mut spa_pod_frame,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_bool_libspa_rs"]
    pub fn spa_pod_parser_get_bool(
        parser: *mut spa_pod_parser,
        value: *mut bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_id_libspa_rs"]
    pub fn spa_pod_parser_get_id(
        parser: *mut spa_pod_parser,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_int_libspa_rs"]
    pub fn spa_pod_parser_get_int(
        parser: *mut spa_pod_parser,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_long_libspa_rs"]
    pub fn spa_pod_parser_get_long(
        parser: *mut spa_pod_parser,
        value: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_float_libspa_rs"]
    pub fn spa_pod_parser_get_float(
        parser: *mut spa_pod_parser,
        value: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_double_libspa_rs"]
    pub fn spa_pod_parser_get_double(
        parser: *mut spa_pod_parser,
        value: *mut f64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_string_libspa_rs"]
    pub fn spa_pod_parser_get_string(
        parser: *mut spa_pod_parser,
        value: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_bytes_libspa_rs"]
    pub fn spa_pod_parser_get_bytes(
        parser: *mut spa_pod_parser,
        value: *mut *const ::std::os::raw::c_void,
        len: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_pointer_libspa_rs"]
    pub fn spa_pod_parser_get_pointer(
        parser: *mut spa_pod_parser,
        type_: *mut u32,
        value: *mut *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_fd_libspa_rs"]
    pub fn spa_pod_parser_get_fd(
        parser: *mut spa_pod_parser,
        value: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_rectangle_libspa_rs"]
    pub fn spa_pod_parser_get_rectangle(
        parser: *mut spa_pod_parser,
        value: *mut spa_rectangle,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_fraction_libspa_rs"]
    pub fn spa_pod_parser_get_fraction(
        parser: *mut spa_pod_parser,
        value: *mut spa_fraction,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_get_pod_libspa_rs"]
    pub fn spa_pod_parser_get_pod(
        parser: *mut spa_pod_parser,
        value: *mut *mut spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_push_struct_libspa_rs"]
    pub fn spa_pod_parser_push_struct(
        parser: *mut spa_pod_parser,
        frame: *mut spa_pod_frame,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_push_object_libspa_rs"]
    pub fn spa_pod_parser_push_object(
        parser: *mut spa_pod_parser,
        frame: *mut spa_pod_frame,
        type_: u32,
        id: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_can_collect_libspa_rs"]
    pub fn spa_pod_parser_can_collect(pod: *const spa_pod, type_: ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_pod_parser_getv_libspa_rs"]
    pub fn spa_pod_parser_getv(
        parser: *mut spa_pod_parser,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_parse_libspa_rs"]
    pub fn spa_format_parse(
        format: *const spa_pod,
        media_type: *mut u32,
        media_subtype: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_strbuf_format_value_libspa_rs"]
    pub fn spa_debug_strbuf_format_value(
        buffer: *mut spa_strbuf,
        info: *const spa_type_info,
        type_: u32,
        body: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_format_value_libspa_rs"]
    pub fn spa_debug_format_value(
        info: *const spa_type_info,
        type_: u32,
        body: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debugc_format_libspa_rs"]
    pub fn spa_debugc_format(
        ctx: *mut spa_debug_context,
        indent: ::std::os::raw::c_int,
        info: *const spa_type_info,
        format: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_format_libspa_rs"]
    pub fn spa_debug_format(
        indent: ::std::os::raw::c_int,
        info: *const spa_type_info,
        format: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup spa_list List\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_list {
    pub next: *mut spa_list,
    pub prev: *mut spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_list"][::std::mem::size_of::<spa_list>() - 16usize];
    ["Alignment of spa_list"][::std::mem::align_of::<spa_list>() - 8usize];
    ["Offset of field: spa_list::next"][::std::mem::offset_of!(spa_list, next) - 0usize];
    ["Offset of field: spa_list::prev"][::std::mem::offset_of!(spa_list, prev) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_list_init_libspa_rs"]
    pub fn spa_list_init(list: *mut spa_list);
}
unsafe extern "C" {
    #[link_name = "spa_list_is_initialized_libspa_rs"]
    pub fn spa_list_is_initialized(list: *mut spa_list) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_list_insert_libspa_rs"]
    pub fn spa_list_insert(list: *mut spa_list, elem: *mut spa_list);
}
unsafe extern "C" {
    #[link_name = "spa_list_insert_list_libspa_rs"]
    pub fn spa_list_insert_list(list: *mut spa_list, other: *mut spa_list);
}
unsafe extern "C" {
    #[link_name = "spa_list_remove_libspa_rs"]
    pub fn spa_list_remove(elem: *mut spa_list);
}
#[doc = " \\struct spa_callbacks\n Callbacks, contains the structure with functions and the data passed\n to the functions.  The structure should also contain a version field that\n is checked."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_callbacks {
    pub funcs: *const ::std::os::raw::c_void,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_callbacks"][::std::mem::size_of::<spa_callbacks>() - 16usize];
    ["Alignment of spa_callbacks"][::std::mem::align_of::<spa_callbacks>() - 8usize];
    ["Offset of field: spa_callbacks::funcs"]
        [::std::mem::offset_of!(spa_callbacks, funcs) - 0usize];
    ["Offset of field: spa_callbacks::data"][::std::mem::offset_of!(spa_callbacks, data) - 8usize];
};
#[doc = " \\struct spa_interface"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_interface {
    pub type_: *const ::std::os::raw::c_char,
    pub version: u32,
    pub cb: spa_callbacks,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_interface"][::std::mem::size_of::<spa_interface>() - 32usize];
    ["Alignment of spa_interface"][::std::mem::align_of::<spa_interface>() - 8usize];
    ["Offset of field: spa_interface::type_"]
        [::std::mem::offset_of!(spa_interface, type_) - 0usize];
    ["Offset of field: spa_interface::version"]
        [::std::mem::offset_of!(spa_interface, version) - 8usize];
    ["Offset of field: spa_interface::cb"][::std::mem::offset_of!(spa_interface, cb) - 16usize];
};
#[doc = " \\struct spa_hook_list\n A list of hooks. This struct is primarily used by\n implementation that use multiple caller-provided \\ref spa_hook."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_hook_list {
    pub list: spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_hook_list"][::std::mem::size_of::<spa_hook_list>() - 16usize];
    ["Alignment of spa_hook_list"][::std::mem::align_of::<spa_hook_list>() - 8usize];
    ["Offset of field: spa_hook_list::list"][::std::mem::offset_of!(spa_hook_list, list) - 0usize];
};
#[doc = " \\struct spa_hook\n A hook, contains the structure with functions and the data passed\n to the functions.\n\n A hook should be treated as opaque by the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_hook {
    pub link: spa_list,
    pub cb: spa_callbacks,
    #[doc = " callback and data for the hook list, private to the\n hook_list implementor"]
    pub removed: ::std::option::Option<unsafe extern "C" fn(hook: *mut spa_hook)>,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_hook"][::std::mem::size_of::<spa_hook>() - 48usize];
    ["Alignment of spa_hook"][::std::mem::align_of::<spa_hook>() - 8usize];
    ["Offset of field: spa_hook::link"][::std::mem::offset_of!(spa_hook, link) - 0usize];
    ["Offset of field: spa_hook::cb"][::std::mem::offset_of!(spa_hook, cb) - 16usize];
    ["Offset of field: spa_hook::removed"][::std::mem::offset_of!(spa_hook, removed) - 32usize];
    ["Offset of field: spa_hook::priv_"][::std::mem::offset_of!(spa_hook, priv_) - 40usize];
};
unsafe extern "C" {
    #[doc = " Initialize a hook list to the empty list"]
    #[link_name = "spa_hook_list_init_libspa_rs"]
    pub fn spa_hook_list_init(list: *mut spa_hook_list);
}
unsafe extern "C" {
    #[link_name = "spa_hook_list_is_empty_libspa_rs"]
    pub fn spa_hook_list_is_empty(list: *mut spa_hook_list) -> bool;
}
unsafe extern "C" {
    #[doc = " Append a hook."]
    #[link_name = "spa_hook_list_append_libspa_rs"]
    pub fn spa_hook_list_append(
        list: *mut spa_hook_list,
        hook: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Prepend a hook"]
    #[link_name = "spa_hook_list_prepend_libspa_rs"]
    pub fn spa_hook_list_prepend(
        list: *mut spa_hook_list,
        hook: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Remove a hook"]
    #[link_name = "spa_hook_remove_libspa_rs"]
    pub fn spa_hook_remove(hook: *mut spa_hook);
}
unsafe extern "C" {
    #[doc = " Remove all hooks from the list"]
    #[link_name = "spa_hook_list_clean_libspa_rs"]
    pub fn spa_hook_list_clean(list: *mut spa_hook_list);
}
unsafe extern "C" {
    #[link_name = "spa_hook_list_isolate_libspa_rs"]
    pub fn spa_hook_list_isolate(
        list: *mut spa_hook_list,
        save: *mut spa_hook_list,
        hook: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "spa_hook_list_join_libspa_rs"]
    pub fn spa_hook_list_join(list: *mut spa_hook_list, save: *mut spa_hook_list);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node"][::std::mem::size_of::<spa_node>() - 32usize];
    ["Alignment of spa_node"][::std::mem::align_of::<spa_node>() - 8usize];
    ["Offset of field: spa_node::iface"][::std::mem::offset_of!(spa_node, iface) - 0usize];
};
#[doc = " Node information structure\n\n Contains the basic node information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_info {
    pub max_input_ports: u32,
    pub max_output_ports: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra node properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_info"][::std::mem::size_of::<spa_node_info>() - 48usize];
    ["Alignment of spa_node_info"][::std::mem::align_of::<spa_node_info>() - 8usize];
    ["Offset of field: spa_node_info::max_input_ports"]
        [::std::mem::offset_of!(spa_node_info, max_input_ports) - 0usize];
    ["Offset of field: spa_node_info::max_output_ports"]
        [::std::mem::offset_of!(spa_node_info, max_output_ports) - 4usize];
    ["Offset of field: spa_node_info::change_mask"]
        [::std::mem::offset_of!(spa_node_info, change_mask) - 8usize];
    ["Offset of field: spa_node_info::flags"]
        [::std::mem::offset_of!(spa_node_info, flags) - 16usize];
    ["Offset of field: spa_node_info::props"]
        [::std::mem::offset_of!(spa_node_info, props) - 24usize];
    ["Offset of field: spa_node_info::params"]
        [::std::mem::offset_of!(spa_node_info, params) - 32usize];
    ["Offset of field: spa_node_info::n_params"]
        [::std::mem::offset_of!(spa_node_info, n_params) - 40usize];
};
#[doc = " Port information structure\n\n Contains the basic port information."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_port_info {
    pub change_mask: u64,
    #[doc = "< port flags"]
    pub flags: u64,
    #[doc = "< rate of sequence numbers on port"]
    pub rate: spa_fraction,
    #[doc = "< extra port properties"]
    pub props: *const spa_dict,
    #[doc = "< parameter information"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_port_info"][::std::mem::size_of::<spa_port_info>() - 48usize];
    ["Alignment of spa_port_info"][::std::mem::align_of::<spa_port_info>() - 8usize];
    ["Offset of field: spa_port_info::change_mask"]
        [::std::mem::offset_of!(spa_port_info, change_mask) - 0usize];
    ["Offset of field: spa_port_info::flags"]
        [::std::mem::offset_of!(spa_port_info, flags) - 8usize];
    ["Offset of field: spa_port_info::rate"][::std::mem::offset_of!(spa_port_info, rate) - 16usize];
    ["Offset of field: spa_port_info::props"]
        [::std::mem::offset_of!(spa_port_info, props) - 24usize];
    ["Offset of field: spa_port_info::params"]
        [::std::mem::offset_of!(spa_port_info, params) - 32usize];
    ["Offset of field: spa_port_info::n_params"]
        [::std::mem::offset_of!(spa_port_info, n_params) - 40usize];
};
#[doc = " an error result"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_node_error {
    pub message: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_error"][::std::mem::size_of::<spa_result_node_error>() - 8usize];
    ["Alignment of spa_result_node_error"]
        [::std::mem::align_of::<spa_result_node_error>() - 8usize];
    ["Offset of field: spa_result_node_error::message"]
        [::std::mem::offset_of!(spa_result_node_error, message) - 0usize];
};
#[doc = " the result of enum_params or port_enum_params."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_node_params {
    #[doc = "< id of parameter"]
    pub id: u32,
    #[doc = "< index of parameter"]
    pub index: u32,
    #[doc = "< next index of iteration"]
    pub next: u32,
    #[doc = "< the result param"]
    pub param: *mut spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_params"][::std::mem::size_of::<spa_result_node_params>() - 24usize];
    ["Alignment of spa_result_node_params"]
        [::std::mem::align_of::<spa_result_node_params>() - 8usize];
    ["Offset of field: spa_result_node_params::id"]
        [::std::mem::offset_of!(spa_result_node_params, id) - 0usize];
    ["Offset of field: spa_result_node_params::index"]
        [::std::mem::offset_of!(spa_result_node_params, index) - 4usize];
    ["Offset of field: spa_result_node_params::next"]
        [::std::mem::offset_of!(spa_result_node_params, next) - 8usize];
    ["Offset of field: spa_result_node_params::param"]
        [::std::mem::offset_of!(spa_result_node_params, param) - 16usize];
};
#[doc = " events from the spa_node.\n\n All event are called from the main thread and multiple\n listeners can be registered for the events with\n spa_node_add_listener()."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Emitted when info changes"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_node_info),
    >,
    #[doc = " Emitted when port info changes, NULL when port is removed"]
    pub port_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port: u32,
            info: *const spa_port_info,
        ),
    >,
    #[doc = " notify a result.\n\n Some methods will trigger a result event with an optional\n result of the given type. Look at the documentation of the\n method to know when to expect a result event.\n\n The result event can be called synchronously, as an event\n called from inside the method itself, in which case the seq\n number passed to the method will be passed unchanged.\n\n The result event will be called asynchronously when the\n method returned an async return value. In this case, the seq\n number in the result will match the async return value of\n the method call. Users should match the seq number from\n request to the reply."]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " \\param node a spa_node\n \\param event the event that was emitted\n\n This will be called when an out-of-bound event is notified\n on \\a node."]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_events"][::std::mem::size_of::<spa_node_events>() - 40usize];
    ["Alignment of spa_node_events"][::std::mem::align_of::<spa_node_events>() - 8usize];
    ["Offset of field: spa_node_events::version"]
        [::std::mem::offset_of!(spa_node_events, version) - 0usize];
    ["Offset of field: spa_node_events::info"]
        [::std::mem::offset_of!(spa_node_events, info) - 8usize];
    ["Offset of field: spa_node_events::port_info"]
        [::std::mem::offset_of!(spa_node_events, port_info) - 16usize];
    ["Offset of field: spa_node_events::result"]
        [::std::mem::offset_of!(spa_node_events, result) - 24usize];
    ["Offset of field: spa_node_events::event"]
        [::std::mem::offset_of!(spa_node_events, event) - 32usize];
};
#[doc = " Node callbacks\n\n Callbacks are called from the real-time data thread. Only\n one callback structure can be set on an spa_node."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_callbacks {
    pub version: u32,
    #[doc = " \\param node a spa_node\n\n The node is ready for processing.\n\n When this function is NULL, synchronous operation is requested\n on the ports."]
    pub ready: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            state: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param node a spa_node\n \\param port_id an input port_id\n \\param buffer_id the buffer id to be reused\n\n The node has a buffer that can be reused.\n\n When this function is NULL, the buffers to reuse will be set in\n the io area of the input ports."]
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " \\param data user data\n \\param trigger the timestamp in microseconds when the xrun happened\n \\param delay the amount of microseconds of xrun.\n \\param info an object with extra info (NULL for now)\n\n The node has encountered an over or underrun\n\n The info contains an object with more information"]
    pub xrun: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            trigger: u64,
            delay: u64,
            info: *mut spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_callbacks"][::std::mem::size_of::<spa_node_callbacks>() - 32usize];
    ["Alignment of spa_node_callbacks"][::std::mem::align_of::<spa_node_callbacks>() - 8usize];
    ["Offset of field: spa_node_callbacks::version"]
        [::std::mem::offset_of!(spa_node_callbacks, version) - 0usize];
    ["Offset of field: spa_node_callbacks::ready"]
        [::std::mem::offset_of!(spa_node_callbacks, ready) - 8usize];
    ["Offset of field: spa_node_callbacks::reuse_buffer"]
        [::std::mem::offset_of!(spa_node_callbacks, reuse_buffer) - 16usize];
    ["Offset of field: spa_node_callbacks::xrun"]
        [::std::mem::offset_of!(spa_node_callbacks, xrun) - 24usize];
};
#[doc = " Node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_node_methods {
    pub version: u32,
    #[doc = " Adds an event listener on \\a node.\n\n Setting the events will trigger the info event and a\n port_info event for each managed port on the new\n listener.\n\n \\param node a #spa_node\n \\param listener a listener\n \\param events a struct \\ref spa_node_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set callbacks to on \\a node.\n if \\a callbacks is NULL, the current callbacks are removed.\n\n This function must be called from the main thread.\n\n All callbacks are called from the data thread.\n\n \\param node a spa_node\n \\param callbacks callbacks to set\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub set_callbacks: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            callbacks: *const spa_node_callbacks,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the node, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a node.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result will either be the \\a seq\n number when executed synchronously or the async return value of\n this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param id the param id to enumerate\n \\param start the index of enumeration, pass 0 for the first item\n \\param max the maximum number of parameters to enumerate\n \\param filter and optional filter to use\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a node\n         an async return value when the result event will be\n             emitted later."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a node.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param node a \\ref spa_node\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when node is NULL\n         -ENOTSUP when there are no parameters implemented on \\a node\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a node. This\n structure is allocated by the host and is used to exchange\n data and parameters with the node.\n\n Setting an \\a io of NULL will disable the node io.\n\n This function must be called from the main thread.\n\n \\param id the id of the io area, the available ids can be\n        enumerated with the node parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to a node.\n\n Upon completion, a command might change the state of a node.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param command a spa_command\n \\return 0 on success\n         -EINVAL when node or command is NULL\n         -ENOTSUP when this node can't process commands\n         -EINVAL \\a command is an invalid command"]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Make a new port with \\a port_id. The caller should use the lowest unused\n port id for the given \\a direction.\n\n Port ids should be between 0 and max_ports as obtained from the info\n event.\n\n This function must be called from the main thread.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id an unused port id\n \\param props extra properties\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub add_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a port with \\a port_id.\n\n \\param node a  spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id a port id\n \\return 0 on success\n         -EINVAL when node is NULL or when port_id is unknown or\n\t\twhen the port can't be removed."]
    pub remove_port: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate all possible parameters of \\a id on \\a port_id of \\a node\n that are compatible with \\a filter.\n\n When SPA_ID_INVALID is given as the port_id, the node will reply with\n the params that would be returned for a new port in the given direction.\n\n The result parameters can be queried and modified and ultimately be used\n to call port_set_param.\n\n The function will emit the result event up to \\a max times with\n the result value. The seq in the result event will either be the\n \\a seq number when executed synchronously or the async return\n value of this function when executed asynchronously.\n\n This function must be called from the main thread.\n\n \\param node a spa_node\n \\param seq a sequence number to pass to the result event when\n\tthis method is executed synchronously.\n \\param direction an spa_direction\n \\param port_id the port to query or SPA_ID_INVALID\n \\param id the parameter id to query\n \\param start the first index to query, 0 to get the first item\n \\param max the maximum number of params to query\n \\param filter a parameter filter or NULL for no filter\n\n \\return 0 when no more items can be iterated.\n         -EINVAL when invalid parameters are given\n         -ENOENT when \\a id is unknown\n         an async return value when the result event will be\n             emitted later."]
    pub port_enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            start: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a port_id of \\a node.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread. The node muse be paused\n or the port SPA_IO_Buffers area is NULL when this function is called with\n a param that changes the processing state (like a format change).\n\n \\param node a struct \\ref spa_node\n \\param direction a enum \\ref spa_direction\n \\param port_id the port to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a struct \\ref spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can be found by\n                doing port_enum_params.\n         -EINVAL when node is NULL or invalid arguments are given\n         -ESRCH when one of the mandatory param\n                 properties is not specified and SPA_NODE_PARAM_FLAG_FIXATE was\n                 not set in \\a flags.\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub port_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell the port to use the given buffers\n\n When \\a flags contains SPA_NODE_BUFFERS_FLAG_ALLOC, the data\n in the buffers should point to an array of at least 1 data entry\n with the desired supported type that will be filled by this function.\n\n The port should also have a spa_io_buffers io area configured to exchange\n the buffers with the port.\n\n For an input port, all the buffers will remain dequeued.\n Once a buffer has been queued on a port in the spa_io_buffers,\n it should not be reused until the reuse_buffer callback is notified\n or when the buffer has been returned in the spa_io_buffers of\n the port.\n\n For output ports, all buffers will be queued in the port. When process\n returns SPA_STATUS_HAVE_DATA, buffers are available in one or more\n of the spa_io_buffers areas.\n\n When a buffer can be reused, port_reuse_buffer() should be called or the\n buffer_id should be placed in the spa_io_buffers area before calling\n process.\n\n Passing NULL as \\a buffers will remove the reference that the port has\n on the buffers.\n\n When this function returns async, use the spa_node_sync operation to\n wait for completion.\n\n This function must be called from the main thread. The node muse be paused\n or the port SPA_IO_Buffers area is NULL when this function is called.\n\n \\param object an object implementing the interface\n \\param direction a port direction\n \\param port_id a port id\n \\param flags extra flags\n \\param buffers an array of buffer pointers\n \\param n_buffers number of elements in \\a buffers\n \\return 0 on success"]
    pub port_use_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            flags: u32,
            buffers: *mut *mut spa_buffer,
            n_buffers: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the given memory area with \\a id on \\a port_id. This\n structure is allocated by the host and is used to exchange\n data and parameters with the port.\n\n Setting an \\a io of NULL will disable the port io.\n\n This function must be called from the main thread.\n\n This function can be called when the node is running and the node\n must be prepared to handle changes in io areas while running. This\n is normally done by synchronizing the port io updates with the\n data processing loop.\n\n \\param direction a spa_direction\n \\param port_id a port id\n \\param id the id of the io area, the available ids can be\n        enumerated with the port parameters.\n \\param data a io area memory\n \\param size the size of \\a data\n \\return 0 on success\n         -EINVAL when invalid input is given\n         -ENOENT when \\a id is unknown\n         -ENOSPC when \\a size is too small"]
    pub port_set_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            data: *mut ::std::os::raw::c_void,
            size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tell an output port to reuse a buffer.\n\n This function must be called from the data thread.\n\n \\param node a spa_node\n \\param port_id a port id\n \\param buffer_id a buffer id to reuse\n \\return 0 on success\n         -EINVAL when node is NULL"]
    pub port_reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Process the node\n\n This function must be called from the data thread.\n\n Output io areas with SPA_STATUS_NEED_DATA will recycle the\n buffers if any.\n\n Input areas with SPA_STATUS_HAVE_DATA are consumed if possible\n and the status is set to SPA_STATUS_NEED_DATA or SPA_STATUS_OK.\n\n When the node has new output buffers, the SPA_STATUS_HAVE_DATA\n bit will be set.\n\n When the node can accept new input in the next cycle, the\n SPA_STATUS_NEED_DATA bit will be set.\n\n Note that the node might return SPA_STATUS_NEED_DATA even when\n no input ports have this status. This means that the amount of\n data still available on the input ports is likely not going to\n be enough for the next cycle and the host might need to prefetch\n data for the next cycle."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_node_methods"][::std::mem::size_of::<spa_node_methods>() - 128usize];
    ["Alignment of spa_node_methods"][::std::mem::align_of::<spa_node_methods>() - 8usize];
    ["Offset of field: spa_node_methods::version"]
        [::std::mem::offset_of!(spa_node_methods, version) - 0usize];
    ["Offset of field: spa_node_methods::add_listener"]
        [::std::mem::offset_of!(spa_node_methods, add_listener) - 8usize];
    ["Offset of field: spa_node_methods::set_callbacks"]
        [::std::mem::offset_of!(spa_node_methods, set_callbacks) - 16usize];
    ["Offset of field: spa_node_methods::sync"]
        [::std::mem::offset_of!(spa_node_methods, sync) - 24usize];
    ["Offset of field: spa_node_methods::enum_params"]
        [::std::mem::offset_of!(spa_node_methods, enum_params) - 32usize];
    ["Offset of field: spa_node_methods::set_param"]
        [::std::mem::offset_of!(spa_node_methods, set_param) - 40usize];
    ["Offset of field: spa_node_methods::set_io"]
        [::std::mem::offset_of!(spa_node_methods, set_io) - 48usize];
    ["Offset of field: spa_node_methods::send_command"]
        [::std::mem::offset_of!(spa_node_methods, send_command) - 56usize];
    ["Offset of field: spa_node_methods::add_port"]
        [::std::mem::offset_of!(spa_node_methods, add_port) - 64usize];
    ["Offset of field: spa_node_methods::remove_port"]
        [::std::mem::offset_of!(spa_node_methods, remove_port) - 72usize];
    ["Offset of field: spa_node_methods::port_enum_params"]
        [::std::mem::offset_of!(spa_node_methods, port_enum_params) - 80usize];
    ["Offset of field: spa_node_methods::port_set_param"]
        [::std::mem::offset_of!(spa_node_methods, port_set_param) - 88usize];
    ["Offset of field: spa_node_methods::port_use_buffers"]
        [::std::mem::offset_of!(spa_node_methods, port_use_buffers) - 96usize];
    ["Offset of field: spa_node_methods::port_set_io"]
        [::std::mem::offset_of!(spa_node_methods, port_set_io) - 104usize];
    ["Offset of field: spa_node_methods::port_reuse_buffer"]
        [::std::mem::offset_of!(spa_node_methods, port_reuse_buffer) - 112usize];
    ["Offset of field: spa_node_methods::process"]
        [::std::mem::offset_of!(spa_node_methods, process) - 120usize];
};
unsafe extern "C" {
    #[link_name = "spa_node_add_listener_libspa_rs"]
    pub fn spa_node_add_listener(
        object: *mut spa_node,
        listener: *mut spa_hook,
        events: *const spa_node_events,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_set_callbacks_libspa_rs"]
    pub fn spa_node_set_callbacks(
        object: *mut spa_node,
        callbacks: *const spa_node_callbacks,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_sync_libspa_rs"]
    pub fn spa_node_sync(
        object: *mut spa_node,
        seq: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_enum_params_libspa_rs"]
    pub fn spa_node_enum_params(
        object: *mut spa_node,
        seq: ::std::os::raw::c_int,
        id: u32,
        start: u32,
        max: u32,
        filter: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_set_param_libspa_rs"]
    pub fn spa_node_set_param(
        object: *mut spa_node,
        id: u32,
        flags: u32,
        param: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_set_io_libspa_rs"]
    pub fn spa_node_set_io(
        object: *mut spa_node,
        id: u32,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_send_command_libspa_rs"]
    pub fn spa_node_send_command(
        object: *mut spa_node,
        command: *const spa_command,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_add_port_libspa_rs"]
    pub fn spa_node_add_port(
        object: *mut spa_node,
        direction: spa_direction,
        port_id: u32,
        props: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_remove_port_libspa_rs"]
    pub fn spa_node_remove_port(
        object: *mut spa_node,
        direction: spa_direction,
        port_id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_port_enum_params_libspa_rs"]
    pub fn spa_node_port_enum_params(
        object: *mut spa_node,
        seq: ::std::os::raw::c_int,
        direction: spa_direction,
        port_id: u32,
        id: u32,
        start: u32,
        max: u32,
        filter: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_port_set_param_libspa_rs"]
    pub fn spa_node_port_set_param(
        object: *mut spa_node,
        direction: spa_direction,
        port_id: u32,
        id: u32,
        flags: u32,
        param: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_port_use_buffers_libspa_rs"]
    pub fn spa_node_port_use_buffers(
        object: *mut spa_node,
        direction: spa_direction,
        port_id: u32,
        flags: u32,
        buffers: *mut *mut spa_buffer,
        n_buffers: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_port_set_io_libspa_rs"]
    pub fn spa_node_port_set_io(
        object: *mut spa_node,
        direction: spa_direction,
        port_id: u32,
        id: u32,
        data: *mut ::std::os::raw::c_void,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_port_reuse_buffer_libspa_rs"]
    pub fn spa_node_port_reuse_buffer(
        object: *mut spa_node,
        port_id: u32,
        buffer_id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_port_reuse_buffer_fast_libspa_rs"]
    pub fn spa_node_port_reuse_buffer_fast(
        object: *mut spa_node,
        port_id: u32,
        buffer_id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_process_libspa_rs"]
    pub fn spa_node_process(object: *mut spa_node) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_process_fast_libspa_rs"]
    pub fn spa_node_process_fast(object: *mut spa_node) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debugc_port_info_libspa_rs"]
    pub fn spa_debugc_port_info(
        ctx: *mut spa_debug_context,
        indent: ::std::os::raw::c_int,
        info: *const spa_port_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_port_info_libspa_rs"]
    pub fn spa_debug_port_info(
        indent: ::std::os::raw::c_int,
        info: *const spa_port_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debugc_pod_value_libspa_rs"]
    pub fn spa_debugc_pod_value(
        ctx: *mut spa_debug_context,
        indent: ::std::os::raw::c_int,
        info: *const spa_type_info,
        type_: u32,
        body: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debugc_pod_libspa_rs"]
    pub fn spa_debugc_pod(
        ctx: *mut spa_debug_context,
        indent: ::std::os::raw::c_int,
        info: *const spa_type_info,
        pod: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_pod_value_libspa_rs"]
    pub fn spa_debug_pod_value(
        indent: ::std::os::raw::c_int,
        info: *const spa_type_info,
        type_: u32,
        body: *mut ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_debug_pod_libspa_rs"]
    pub fn spa_debug_pod(
        indent: ::std::os::raw::c_int,
        info: *const spa_type_info,
        pod: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_state {
    #[doc = "< current status"]
    pub status: ::std::os::raw::c_int,
    #[doc = "< required number of signals"]
    pub required: i32,
    #[doc = "< number of pending signals"]
    pub pending: i32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_state"][::std::mem::size_of::<spa_graph_state>() - 12usize];
    ["Alignment of spa_graph_state"][::std::mem::align_of::<spa_graph_state>() - 4usize];
    ["Offset of field: spa_graph_state::status"]
        [::std::mem::offset_of!(spa_graph_state, status) - 0usize];
    ["Offset of field: spa_graph_state::required"]
        [::std::mem::offset_of!(spa_graph_state, required) - 4usize];
    ["Offset of field: spa_graph_state::pending"]
        [::std::mem::offset_of!(spa_graph_state, pending) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_graph_state_reset_libspa_rs"]
    pub fn spa_graph_state_reset(state: *mut spa_graph_state);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_link {
    pub link: spa_list,
    pub state: *mut spa_graph_state,
    pub signal: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    pub signal_data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_link"][::std::mem::size_of::<spa_graph_link>() - 40usize];
    ["Alignment of spa_graph_link"][::std::mem::align_of::<spa_graph_link>() - 8usize];
    ["Offset of field: spa_graph_link::link"]
        [::std::mem::offset_of!(spa_graph_link, link) - 0usize];
    ["Offset of field: spa_graph_link::state"]
        [::std::mem::offset_of!(spa_graph_link, state) - 16usize];
    ["Offset of field: spa_graph_link::signal"]
        [::std::mem::offset_of!(spa_graph_link, signal) - 24usize];
    ["Offset of field: spa_graph_link::signal_data"]
        [::std::mem::offset_of!(spa_graph_link, signal_data) - 32usize];
};
unsafe extern "C" {
    #[link_name = "spa_graph_link_trigger_libspa_rs"]
    pub fn spa_graph_link_trigger(link: *mut spa_graph_link) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph {
    pub flags: u32,
    pub parent: *mut spa_graph_node,
    pub state: *mut spa_graph_state,
    pub nodes: spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph"][::std::mem::size_of::<spa_graph>() - 40usize];
    ["Alignment of spa_graph"][::std::mem::align_of::<spa_graph>() - 8usize];
    ["Offset of field: spa_graph::flags"][::std::mem::offset_of!(spa_graph, flags) - 0usize];
    ["Offset of field: spa_graph::parent"][::std::mem::offset_of!(spa_graph, parent) - 8usize];
    ["Offset of field: spa_graph::state"][::std::mem::offset_of!(spa_graph, state) - 16usize];
    ["Offset of field: spa_graph::nodes"][::std::mem::offset_of!(spa_graph, nodes) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_node_callbacks {
    pub version: u32,
    pub process: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node: *mut spa_graph_node,
        ) -> ::std::os::raw::c_int,
    >,
    pub reuse_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node: *mut spa_graph_node,
            port_id: u32,
            buffer_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_node_callbacks"]
        [::std::mem::size_of::<spa_graph_node_callbacks>() - 24usize];
    ["Alignment of spa_graph_node_callbacks"]
        [::std::mem::align_of::<spa_graph_node_callbacks>() - 8usize];
    ["Offset of field: spa_graph_node_callbacks::version"]
        [::std::mem::offset_of!(spa_graph_node_callbacks, version) - 0usize];
    ["Offset of field: spa_graph_node_callbacks::process"]
        [::std::mem::offset_of!(spa_graph_node_callbacks, process) - 8usize];
    ["Offset of field: spa_graph_node_callbacks::reuse_buffer"]
        [::std::mem::offset_of!(spa_graph_node_callbacks, reuse_buffer) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_node {
    #[doc = "< link in graph nodes list"]
    pub link: spa_list,
    #[doc = "< owner graph"]
    pub graph: *mut spa_graph,
    #[doc = "< list of input and output ports"]
    pub ports: [spa_list; 2usize],
    #[doc = "< list of links to next nodes"]
    pub links: spa_list,
    #[doc = "< node flags"]
    pub flags: u32,
    #[doc = "< state of the node"]
    pub state: *mut spa_graph_state,
    #[doc = "< link in graph"]
    pub graph_link: spa_graph_link,
    #[doc = "< subgraph or NULL"]
    pub subgraph: *mut spa_graph,
    pub callbacks: spa_callbacks,
    #[doc = "< link for scheduler"]
    pub sched_link: spa_list,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_node"][::std::mem::size_of::<spa_graph_node>() - 168usize];
    ["Alignment of spa_graph_node"][::std::mem::align_of::<spa_graph_node>() - 8usize];
    ["Offset of field: spa_graph_node::link"]
        [::std::mem::offset_of!(spa_graph_node, link) - 0usize];
    ["Offset of field: spa_graph_node::graph"]
        [::std::mem::offset_of!(spa_graph_node, graph) - 16usize];
    ["Offset of field: spa_graph_node::ports"]
        [::std::mem::offset_of!(spa_graph_node, ports) - 24usize];
    ["Offset of field: spa_graph_node::links"]
        [::std::mem::offset_of!(spa_graph_node, links) - 56usize];
    ["Offset of field: spa_graph_node::flags"]
        [::std::mem::offset_of!(spa_graph_node, flags) - 72usize];
    ["Offset of field: spa_graph_node::state"]
        [::std::mem::offset_of!(spa_graph_node, state) - 80usize];
    ["Offset of field: spa_graph_node::graph_link"]
        [::std::mem::offset_of!(spa_graph_node, graph_link) - 88usize];
    ["Offset of field: spa_graph_node::subgraph"]
        [::std::mem::offset_of!(spa_graph_node, subgraph) - 128usize];
    ["Offset of field: spa_graph_node::callbacks"]
        [::std::mem::offset_of!(spa_graph_node, callbacks) - 136usize];
    ["Offset of field: spa_graph_node::sched_link"]
        [::std::mem::offset_of!(spa_graph_node, sched_link) - 152usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_graph_port {
    #[doc = "< link in node port list"]
    pub link: spa_list,
    #[doc = "< owner node"]
    pub node: *mut spa_graph_node,
    #[doc = "< port direction"]
    pub direction: spa_direction,
    #[doc = "< port id"]
    pub port_id: u32,
    #[doc = "< port flags"]
    pub flags: u32,
    #[doc = "< peer"]
    pub peer: *mut spa_graph_port,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_graph_port"][::std::mem::size_of::<spa_graph_port>() - 48usize];
    ["Alignment of spa_graph_port"][::std::mem::align_of::<spa_graph_port>() - 8usize];
    ["Offset of field: spa_graph_port::link"]
        [::std::mem::offset_of!(spa_graph_port, link) - 0usize];
    ["Offset of field: spa_graph_port::node"]
        [::std::mem::offset_of!(spa_graph_port, node) - 16usize];
    ["Offset of field: spa_graph_port::direction"]
        [::std::mem::offset_of!(spa_graph_port, direction) - 24usize];
    ["Offset of field: spa_graph_port::port_id"]
        [::std::mem::offset_of!(spa_graph_port, port_id) - 28usize];
    ["Offset of field: spa_graph_port::flags"]
        [::std::mem::offset_of!(spa_graph_port, flags) - 32usize];
    ["Offset of field: spa_graph_port::peer"]
        [::std::mem::offset_of!(spa_graph_port, peer) - 40usize];
};
unsafe extern "C" {
    #[link_name = "spa_graph_node_trigger_libspa_rs"]
    pub fn spa_graph_node_trigger(node: *mut spa_graph_node) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_graph_run_libspa_rs"]
    pub fn spa_graph_run(graph: *mut spa_graph) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_graph_finish_libspa_rs"]
    pub fn spa_graph_finish(graph: *mut spa_graph) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_graph_link_signal_node_libspa_rs"]
    pub fn spa_graph_link_signal_node(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_graph_link_signal_graph_libspa_rs"]
    pub fn spa_graph_link_signal_graph(data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_graph_init_libspa_rs"]
    pub fn spa_graph_init(graph: *mut spa_graph, state: *mut spa_graph_state);
}
unsafe extern "C" {
    #[link_name = "spa_graph_link_add_libspa_rs"]
    pub fn spa_graph_link_add(
        out: *mut spa_graph_node,
        state: *mut spa_graph_state,
        link: *mut spa_graph_link,
    );
}
unsafe extern "C" {
    #[link_name = "spa_graph_link_remove_libspa_rs"]
    pub fn spa_graph_link_remove(link: *mut spa_graph_link);
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_init_libspa_rs"]
    pub fn spa_graph_node_init(node: *mut spa_graph_node, state: *mut spa_graph_state);
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_impl_sub_process_libspa_rs"]
    pub fn spa_graph_node_impl_sub_process(
        data: *mut ::std::os::raw::c_void,
        node: *mut spa_graph_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_set_subgraph_libspa_rs"]
    pub fn spa_graph_node_set_subgraph(node: *mut spa_graph_node, subgraph: *mut spa_graph);
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_set_callbacks_libspa_rs"]
    pub fn spa_graph_node_set_callbacks(
        node: *mut spa_graph_node,
        callbacks: *const spa_graph_node_callbacks,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_add_libspa_rs"]
    pub fn spa_graph_node_add(graph: *mut spa_graph, node: *mut spa_graph_node);
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_remove_libspa_rs"]
    pub fn spa_graph_node_remove(node: *mut spa_graph_node);
}
unsafe extern "C" {
    #[link_name = "spa_graph_port_init_libspa_rs"]
    pub fn spa_graph_port_init(
        port: *mut spa_graph_port,
        direction: spa_direction,
        port_id: u32,
        flags: u32,
    );
}
unsafe extern "C" {
    #[link_name = "spa_graph_port_add_libspa_rs"]
    pub fn spa_graph_port_add(node: *mut spa_graph_node, port: *mut spa_graph_port);
}
unsafe extern "C" {
    #[link_name = "spa_graph_port_remove_libspa_rs"]
    pub fn spa_graph_port_remove(port: *mut spa_graph_port);
}
unsafe extern "C" {
    #[link_name = "spa_graph_port_link_libspa_rs"]
    pub fn spa_graph_port_link(out: *mut spa_graph_port, in_: *mut spa_graph_port);
}
unsafe extern "C" {
    #[link_name = "spa_graph_port_unlink_libspa_rs"]
    pub fn spa_graph_port_unlink(port: *mut spa_graph_port);
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_impl_process_libspa_rs"]
    pub fn spa_graph_node_impl_process(
        data: *mut ::std::os::raw::c_void,
        node: *mut spa_graph_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_graph_node_impl_reuse_buffer_libspa_rs"]
    pub fn spa_graph_node_impl_reuse_buffer(
        data: *mut ::std::os::raw::c_void,
        node: *mut spa_graph_node,
        port_id: u32,
        buffer_id: u32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device"][::std::mem::size_of::<spa_device>() - 32usize];
    ["Alignment of spa_device"][::std::mem::align_of::<spa_device>() - 8usize];
    ["Offset of field: spa_device::iface"][::std::mem::offset_of!(spa_device, iface) - 0usize];
};
#[doc = " Information about the device and parameters it supports\n\n This information is part of the info event on a device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_info {
    pub version: u32,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< device properties"]
    pub props: *const spa_dict,
    #[doc = "< supported parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of elements in params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_info"][::std::mem::size_of::<spa_device_info>() - 48usize];
    ["Alignment of spa_device_info"][::std::mem::align_of::<spa_device_info>() - 8usize];
    ["Offset of field: spa_device_info::version"]
        [::std::mem::offset_of!(spa_device_info, version) - 0usize];
    ["Offset of field: spa_device_info::change_mask"]
        [::std::mem::offset_of!(spa_device_info, change_mask) - 8usize];
    ["Offset of field: spa_device_info::flags"]
        [::std::mem::offset_of!(spa_device_info, flags) - 16usize];
    ["Offset of field: spa_device_info::props"]
        [::std::mem::offset_of!(spa_device_info, props) - 24usize];
    ["Offset of field: spa_device_info::params"]
        [::std::mem::offset_of!(spa_device_info, params) - 32usize];
    ["Offset of field: spa_device_info::n_params"]
        [::std::mem::offset_of!(spa_device_info, n_params) - 40usize];
};
#[doc = " Information about a device object\n\n This information is part of the object_info event on the device."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_object_info {
    pub version: u32,
    #[doc = "< the object type managed by this device"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< a factory name that implements the object"]
    pub factory_name: *const ::std::os::raw::c_char,
    pub change_mask: u64,
    pub flags: u64,
    #[doc = "< extra object properties"]
    pub props: *const spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_object_info"][::std::mem::size_of::<spa_device_object_info>() - 48usize];
    ["Alignment of spa_device_object_info"]
        [::std::mem::align_of::<spa_device_object_info>() - 8usize];
    ["Offset of field: spa_device_object_info::version"]
        [::std::mem::offset_of!(spa_device_object_info, version) - 0usize];
    ["Offset of field: spa_device_object_info::type_"]
        [::std::mem::offset_of!(spa_device_object_info, type_) - 8usize];
    ["Offset of field: spa_device_object_info::factory_name"]
        [::std::mem::offset_of!(spa_device_object_info, factory_name) - 16usize];
    ["Offset of field: spa_device_object_info::change_mask"]
        [::std::mem::offset_of!(spa_device_object_info, change_mask) - 24usize];
    ["Offset of field: spa_device_object_info::flags"]
        [::std::mem::offset_of!(spa_device_object_info, flags) - 32usize];
    ["Offset of field: spa_device_object_info::props"]
        [::std::mem::offset_of!(spa_device_object_info, props) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_device_params {
    pub id: u32,
    pub index: u32,
    pub next: u32,
    pub param: *mut spa_pod,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_device_params"]
        [::std::mem::size_of::<spa_result_device_params>() - 24usize];
    ["Alignment of spa_result_device_params"]
        [::std::mem::align_of::<spa_result_device_params>() - 8usize];
    ["Offset of field: spa_result_device_params::id"]
        [::std::mem::offset_of!(spa_result_device_params, id) - 0usize];
    ["Offset of field: spa_result_device_params::index"]
        [::std::mem::offset_of!(spa_result_device_params, index) - 4usize];
    ["Offset of field: spa_result_device_params::next"]
        [::std::mem::offset_of!(spa_result_device_params, next) - 8usize];
    ["Offset of field: spa_result_device_params::param"]
        [::std::mem::offset_of!(spa_result_device_params, param) - 16usize];
};
#[doc = " spa_device_events:\n\n Events are always emitted from the main thread"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_events {
    pub version: u32,
    #[doc = " notify extra information about the device"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const spa_device_info),
    >,
    #[doc = " notify a result"]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " a device event"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
    #[doc = " info changed for an object managed by the device, info is NULL when\n the object is removed"]
    pub object_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            info: *const spa_device_object_info,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_events"][::std::mem::size_of::<spa_device_events>() - 40usize];
    ["Alignment of spa_device_events"][::std::mem::align_of::<spa_device_events>() - 8usize];
    ["Offset of field: spa_device_events::version"]
        [::std::mem::offset_of!(spa_device_events, version) - 0usize];
    ["Offset of field: spa_device_events::info"]
        [::std::mem::offset_of!(spa_device_events, info) - 8usize];
    ["Offset of field: spa_device_events::result"]
        [::std::mem::offset_of!(spa_device_events, result) - 16usize];
    ["Offset of field: spa_device_events::event"]
        [::std::mem::offset_of!(spa_device_events, event) - 24usize];
    ["Offset of field: spa_device_events::object_info"]
        [::std::mem::offset_of!(spa_device_events, object_info) - 32usize];
};
#[doc = " spa_device_methods:"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_device_methods {
    pub version: u32,
    #[doc = " Set events to receive asynchronous notifications from\n the device.\n\n Setting the events will trigger the info event and an\n object_info event for each managed object on the new\n listener.\n\n \\param object a \\ref spa_device\n \\param listener a listener\n \\param events a struct \\ref spa_device_events\n \\param data data passed as first argument in functions of \\a events\n \\return 0 on success\n\t   < 0 errno on error"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const spa_device_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Perform a sync operation.\n\n This method will emit the result event with the given sequence\n number synchronously or with the returned async return value\n asynchronously.\n\n Because all methods are serialized in the device, this can be used\n to wait for completion of all previous method calls.\n\n \\param seq a sequence number\n \\return 0 on success\n         -EINVAL when node is NULL\n         an async result"]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate the parameters of a device.\n\n Parameters are identified with an \\a id. Some parameters can have\n multiple values, see the documentation of the parameter id.\n\n Parameters can be filtered by passing a non-NULL \\a filter.\n\n The result callback will be called at most \\a max times with a\n struct spa_result_device_params as the result.\n\n This function must be called from the main thread.\n\n \\param device a \\ref spa_device\n \\param seq a sequence number to pass to the result function\n \\param id the param id to enumerate\n \\param index the index of enumeration, pass 0 for the first item.\n \\param max the maximum number of items to iterate\n \\param filter and optional filter to use\n \\return 0 when there are no more parameters to enumerate\n         -EINVAL when invalid arguments are given\n         -ENOENT the parameter \\a id is unknown\n         -ENOTSUP when there are no parameters\n                 implemented on \\a device"]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            max: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a device.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param object \\ref spa_device\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when invalid arguments are given\n         -ENOTSUP when there are no parameters implemented on \\a device\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_device_methods"][::std::mem::size_of::<spa_device_methods>() - 40usize];
    ["Alignment of spa_device_methods"][::std::mem::align_of::<spa_device_methods>() - 8usize];
    ["Offset of field: spa_device_methods::version"]
        [::std::mem::offset_of!(spa_device_methods, version) - 0usize];
    ["Offset of field: spa_device_methods::add_listener"]
        [::std::mem::offset_of!(spa_device_methods, add_listener) - 8usize];
    ["Offset of field: spa_device_methods::sync"]
        [::std::mem::offset_of!(spa_device_methods, sync) - 16usize];
    ["Offset of field: spa_device_methods::enum_params"]
        [::std::mem::offset_of!(spa_device_methods, enum_params) - 24usize];
    ["Offset of field: spa_device_methods::set_param"]
        [::std::mem::offset_of!(spa_device_methods, set_param) - 32usize];
};
unsafe extern "C" {
    #[link_name = "spa_device_add_listener_libspa_rs"]
    pub fn spa_device_add_listener(
        object: *mut spa_device,
        listener: *mut spa_hook,
        events: *const spa_device_events,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_device_sync_libspa_rs"]
    pub fn spa_device_sync(
        object: *mut spa_device,
        seq: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_device_enum_params_libspa_rs"]
    pub fn spa_device_enum_params(
        object: *mut spa_device,
        seq: ::std::os::raw::c_int,
        id: u32,
        index: u32,
        max: u32,
        filter: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_device_set_param_libspa_rs"]
    pub fn spa_device_set_param(
        object: *mut spa_device,
        id: u32,
        flags: u32,
        param: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_builder_state {
    pub offset: u32,
    pub flags: u32,
    pub frame: *mut spa_pod_frame,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_builder_state"][::std::mem::size_of::<spa_pod_builder_state>() - 16usize];
    ["Alignment of spa_pod_builder_state"]
        [::std::mem::align_of::<spa_pod_builder_state>() - 8usize];
    ["Offset of field: spa_pod_builder_state::offset"]
        [::std::mem::offset_of!(spa_pod_builder_state, offset) - 0usize];
    ["Offset of field: spa_pod_builder_state::flags"]
        [::std::mem::offset_of!(spa_pod_builder_state, flags) - 4usize];
    ["Offset of field: spa_pod_builder_state::frame"]
        [::std::mem::offset_of!(spa_pod_builder_state, frame) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_builder_callbacks {
    pub version: u32,
    pub overflow: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, size: u32) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_builder_callbacks"]
        [::std::mem::size_of::<spa_pod_builder_callbacks>() - 16usize];
    ["Alignment of spa_pod_builder_callbacks"]
        [::std::mem::align_of::<spa_pod_builder_callbacks>() - 8usize];
    ["Offset of field: spa_pod_builder_callbacks::version"]
        [::std::mem::offset_of!(spa_pod_builder_callbacks, version) - 0usize];
    ["Offset of field: spa_pod_builder_callbacks::overflow"]
        [::std::mem::offset_of!(spa_pod_builder_callbacks, overflow) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_pod_builder {
    pub data: *mut ::std::os::raw::c_void,
    pub size: u32,
    pub _padding: u32,
    pub state: spa_pod_builder_state,
    pub callbacks: spa_callbacks,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_pod_builder"][::std::mem::size_of::<spa_pod_builder>() - 48usize];
    ["Alignment of spa_pod_builder"][::std::mem::align_of::<spa_pod_builder>() - 8usize];
    ["Offset of field: spa_pod_builder::data"]
        [::std::mem::offset_of!(spa_pod_builder, data) - 0usize];
    ["Offset of field: spa_pod_builder::size"]
        [::std::mem::offset_of!(spa_pod_builder, size) - 8usize];
    ["Offset of field: spa_pod_builder::_padding"]
        [::std::mem::offset_of!(spa_pod_builder, _padding) - 12usize];
    ["Offset of field: spa_pod_builder::state"]
        [::std::mem::offset_of!(spa_pod_builder, state) - 16usize];
    ["Offset of field: spa_pod_builder::callbacks"]
        [::std::mem::offset_of!(spa_pod_builder, callbacks) - 32usize];
};
unsafe extern "C" {
    #[link_name = "spa_pod_builder_get_state_libspa_rs"]
    pub fn spa_pod_builder_get_state(
        builder: *mut spa_pod_builder,
        state: *mut spa_pod_builder_state,
    );
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_set_callbacks_libspa_rs"]
    pub fn spa_pod_builder_set_callbacks(
        builder: *mut spa_pod_builder,
        callbacks: *const spa_pod_builder_callbacks,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_reset_libspa_rs"]
    pub fn spa_pod_builder_reset(builder: *mut spa_pod_builder, state: *mut spa_pod_builder_state);
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_init_libspa_rs"]
    pub fn spa_pod_builder_init(
        builder: *mut spa_pod_builder,
        data: *mut ::std::os::raw::c_void,
        size: u32,
    );
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_deref_libspa_rs"]
    pub fn spa_pod_builder_deref(builder: *mut spa_pod_builder, offset: u32) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_frame_libspa_rs"]
    pub fn spa_pod_builder_frame(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_push_libspa_rs"]
    pub fn spa_pod_builder_push(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
        pod: *const spa_pod,
        offset: u32,
    );
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_raw_libspa_rs"]
    pub fn spa_pod_builder_raw(
        builder: *mut spa_pod_builder,
        data: *const ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_pad_libspa_rs"]
    pub fn spa_pod_builder_pad(builder: *mut spa_pod_builder, size: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_raw_padded_libspa_rs"]
    pub fn spa_pod_builder_raw_padded(
        builder: *mut spa_pod_builder,
        data: *const ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_pop_libspa_rs"]
    pub fn spa_pod_builder_pop(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_primitive_libspa_rs"]
    pub fn spa_pod_builder_primitive(
        builder: *mut spa_pod_builder,
        p: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_none_libspa_rs"]
    pub fn spa_pod_builder_none(builder: *mut spa_pod_builder) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_child_libspa_rs"]
    pub fn spa_pod_builder_child(
        builder: *mut spa_pod_builder,
        size: u32,
        type_: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_bool_libspa_rs"]
    pub fn spa_pod_builder_bool(builder: *mut spa_pod_builder, val: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_id_libspa_rs"]
    pub fn spa_pod_builder_id(builder: *mut spa_pod_builder, val: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_int_libspa_rs"]
    pub fn spa_pod_builder_int(builder: *mut spa_pod_builder, val: i32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_long_libspa_rs"]
    pub fn spa_pod_builder_long(builder: *mut spa_pod_builder, val: i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_float_libspa_rs"]
    pub fn spa_pod_builder_float(builder: *mut spa_pod_builder, val: f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_double_libspa_rs"]
    pub fn spa_pod_builder_double(builder: *mut spa_pod_builder, val: f64)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_write_string_libspa_rs"]
    pub fn spa_pod_builder_write_string(
        builder: *mut spa_pod_builder,
        str_: *const ::std::os::raw::c_char,
        len: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_string_len_libspa_rs"]
    pub fn spa_pod_builder_string_len(
        builder: *mut spa_pod_builder,
        str_: *const ::std::os::raw::c_char,
        len: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_string_libspa_rs"]
    pub fn spa_pod_builder_string(
        builder: *mut spa_pod_builder,
        str_: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_bytes_libspa_rs"]
    pub fn spa_pod_builder_bytes(
        builder: *mut spa_pod_builder,
        bytes: *const ::std::os::raw::c_void,
        len: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_reserve_bytes_libspa_rs"]
    pub fn spa_pod_builder_reserve_bytes(
        builder: *mut spa_pod_builder,
        len: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_bytes_start_libspa_rs"]
    pub fn spa_pod_builder_bytes_start(builder: *mut spa_pod_builder) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_bytes_append_libspa_rs"]
    pub fn spa_pod_builder_bytes_append(
        builder: *mut spa_pod_builder,
        offset: u32,
        data: *const ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_bytes_end_libspa_rs"]
    pub fn spa_pod_builder_bytes_end(
        builder: *mut spa_pod_builder,
        offset: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_pointer_libspa_rs"]
    pub fn spa_pod_builder_pointer(
        builder: *mut spa_pod_builder,
        type_: u32,
        val: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_fd_libspa_rs"]
    pub fn spa_pod_builder_fd(builder: *mut spa_pod_builder, fd: i64) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_rectangle_libspa_rs"]
    pub fn spa_pod_builder_rectangle(
        builder: *mut spa_pod_builder,
        width: u32,
        height: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_fraction_libspa_rs"]
    pub fn spa_pod_builder_fraction(
        builder: *mut spa_pod_builder,
        num: u32,
        denom: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_push_array_libspa_rs"]
    pub fn spa_pod_builder_push_array(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_array_libspa_rs"]
    pub fn spa_pod_builder_array(
        builder: *mut spa_pod_builder,
        child_size: u32,
        child_type: u32,
        n_elems: u32,
        elems: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_push_choice_libspa_rs"]
    pub fn spa_pod_builder_push_choice(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
        type_: u32,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_push_struct_libspa_rs"]
    pub fn spa_pod_builder_push_struct(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_push_object_libspa_rs"]
    pub fn spa_pod_builder_push_object(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
        type_: u32,
        id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_prop_libspa_rs"]
    pub fn spa_pod_builder_prop(
        builder: *mut spa_pod_builder,
        key: u32,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_push_sequence_libspa_rs"]
    pub fn spa_pod_builder_push_sequence(
        builder: *mut spa_pod_builder,
        frame: *mut spa_pod_frame,
        unit: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_control_libspa_rs"]
    pub fn spa_pod_builder_control(
        builder: *mut spa_pod_builder,
        offset: u32,
        type_: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_choice_from_id_libspa_rs"]
    pub fn spa_choice_from_id(id: ::std::os::raw::c_char) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_pod_builder_addv_libspa_rs"]
    pub fn spa_pod_builder_addv(
        builder: *mut spa_pod_builder,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Copy a pod structure"]
    #[link_name = "spa_pod_copy_libspa_rs"]
    pub fn spa_pod_copy(pod: *const spa_pod) -> *mut spa_pod;
}
#[doc = " \\addtogroup spa_device\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_device_params_data {
    pub builder: *mut spa_pod_builder,
    pub data: spa_result_device_params,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_device_params_data"]
        [::std::mem::size_of::<spa_result_device_params_data>() - 32usize];
    ["Alignment of spa_result_device_params_data"]
        [::std::mem::align_of::<spa_result_device_params_data>() - 8usize];
    ["Offset of field: spa_result_device_params_data::builder"]
        [::std::mem::offset_of!(spa_result_device_params_data, builder) - 0usize];
    ["Offset of field: spa_result_device_params_data::data"]
        [::std::mem::offset_of!(spa_result_device_params_data, data) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_result_func_device_params_libspa_rs"]
    pub fn spa_result_func_device_params(
        data: *mut ::std::os::raw::c_void,
        seq: ::std::os::raw::c_int,
        res: ::std::os::raw::c_int,
        type_: u32,
        result: *const ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "spa_device_enum_params_sync_libspa_rs"]
    pub fn spa_device_enum_params_sync(
        device: *mut spa_device,
        id: u32,
        index: *mut u32,
        filter: *const spa_pod,
        param: *mut *mut spa_pod,
        builder: *mut spa_pod_builder,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_result_node_params_data {
    pub builder: *mut spa_pod_builder,
    pub data: spa_result_node_params,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_result_node_params_data"]
        [::std::mem::size_of::<spa_result_node_params_data>() - 32usize];
    ["Alignment of spa_result_node_params_data"]
        [::std::mem::align_of::<spa_result_node_params_data>() - 8usize];
    ["Offset of field: spa_result_node_params_data::builder"]
        [::std::mem::offset_of!(spa_result_node_params_data, builder) - 0usize];
    ["Offset of field: spa_result_node_params_data::data"]
        [::std::mem::offset_of!(spa_result_node_params_data, data) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_result_func_node_params_libspa_rs"]
    pub fn spa_result_func_node_params(
        data: *mut ::std::os::raw::c_void,
        seq: ::std::os::raw::c_int,
        res: ::std::os::raw::c_int,
        type_: u32,
        result: *const ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "spa_node_enum_params_sync_libspa_rs"]
    pub fn spa_node_enum_params_sync(
        node: *mut spa_node,
        id: u32,
        index: *mut u32,
        filter: *const spa_pod,
        param: *mut *mut spa_pod,
        builder: *mut spa_pod_builder,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_node_port_enum_params_sync_libspa_rs"]
    pub fn spa_node_port_enum_params_sync(
        node: *mut spa_node,
        direction: spa_direction,
        port_id: u32,
        id: u32,
        index: *mut u32,
        filter: *const spa_pod,
        param: *mut *mut spa_pod,
        builder: *mut spa_pod_builder,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_latency_info_compare_libspa_rs"]
    pub fn spa_latency_info_compare(
        a: *const spa_latency_info,
        b: *const spa_latency_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_latency_info_combine_start_libspa_rs"]
    pub fn spa_latency_info_combine_start(info: *mut spa_latency_info, direction: spa_direction);
}
unsafe extern "C" {
    #[link_name = "spa_latency_info_combine_finish_libspa_rs"]
    pub fn spa_latency_info_combine_finish(info: *mut spa_latency_info);
}
unsafe extern "C" {
    #[link_name = "spa_latency_info_combine_libspa_rs"]
    pub fn spa_latency_info_combine(
        info: *mut spa_latency_info,
        other: *const spa_latency_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_latency_parse_libspa_rs"]
    pub fn spa_latency_parse(
        latency: *const spa_pod,
        info: *mut spa_latency_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_latency_build_libspa_rs"]
    pub fn spa_latency_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_latency_info,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_process_latency_parse_libspa_rs"]
    pub fn spa_process_latency_parse(
        latency: *const spa_pod,
        info: *mut spa_process_latency_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_process_latency_build_libspa_rs"]
    pub fn spa_process_latency_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_process_latency_info,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_process_latency_info_add_libspa_rs"]
    pub fn spa_process_latency_info_add(
        process: *const spa_process_latency_info,
        info: *mut spa_latency_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_process_latency_info_compare_libspa_rs"]
    pub fn spa_process_latency_info_compare(
        a: *const spa_process_latency_info,
        b: *const spa_process_latency_info,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_dsd {
    pub bitorder: spa_param_bitorder,
    pub flags: u32,
    pub interleave: i32,
    pub rate: u32,
    pub channels: u32,
    pub position: [u32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_dsd"][::std::mem::size_of::<spa_audio_info_dsd>() - 276usize];
    ["Alignment of spa_audio_info_dsd"][::std::mem::align_of::<spa_audio_info_dsd>() - 4usize];
    ["Offset of field: spa_audio_info_dsd::bitorder"]
        [::std::mem::offset_of!(spa_audio_info_dsd, bitorder) - 0usize];
    ["Offset of field: spa_audio_info_dsd::flags"]
        [::std::mem::offset_of!(spa_audio_info_dsd, flags) - 4usize];
    ["Offset of field: spa_audio_info_dsd::interleave"]
        [::std::mem::offset_of!(spa_audio_info_dsd, interleave) - 8usize];
    ["Offset of field: spa_audio_info_dsd::rate"]
        [::std::mem::offset_of!(spa_audio_info_dsd, rate) - 12usize];
    ["Offset of field: spa_audio_info_dsd::channels"]
        [::std::mem::offset_of!(spa_audio_info_dsd, channels) - 16usize];
    ["Offset of field: spa_audio_info_dsd::position"]
        [::std::mem::offset_of!(spa_audio_info_dsd, position) - 20usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_dsp {
    pub format: spa_audio_format,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_dsp"][::std::mem::size_of::<spa_audio_info_dsp>() - 4usize];
    ["Alignment of spa_audio_info_dsp"][::std::mem::align_of::<spa_audio_info_dsp>() - 4usize];
    ["Offset of field: spa_audio_info_dsp::format"]
        [::std::mem::offset_of!(spa_audio_info_dsp, format) - 0usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_vorbis {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_vorbis"][::std::mem::size_of::<spa_audio_info_vorbis>() - 8usize];
    ["Alignment of spa_audio_info_vorbis"]
        [::std::mem::align_of::<spa_audio_info_vorbis>() - 4usize];
    ["Offset of field: spa_audio_info_vorbis::rate"]
        [::std::mem::offset_of!(spa_audio_info_vorbis, rate) - 0usize];
    ["Offset of field: spa_audio_info_vorbis::channels"]
        [::std::mem::offset_of!(spa_audio_info_vorbis, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_ra {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_ra"][::std::mem::size_of::<spa_audio_info_ra>() - 8usize];
    ["Alignment of spa_audio_info_ra"][::std::mem::align_of::<spa_audio_info_ra>() - 4usize];
    ["Offset of field: spa_audio_info_ra::rate"]
        [::std::mem::offset_of!(spa_audio_info_ra, rate) - 0usize];
    ["Offset of field: spa_audio_info_ra::channels"]
        [::std::mem::offset_of!(spa_audio_info_ra, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_alac {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_alac"][::std::mem::size_of::<spa_audio_info_alac>() - 8usize];
    ["Alignment of spa_audio_info_alac"][::std::mem::align_of::<spa_audio_info_alac>() - 4usize];
    ["Offset of field: spa_audio_info_alac::rate"]
        [::std::mem::offset_of!(spa_audio_info_alac, rate) - 0usize];
    ["Offset of field: spa_audio_info_alac::channels"]
        [::std::mem::offset_of!(spa_audio_info_alac, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_flac {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_flac"][::std::mem::size_of::<spa_audio_info_flac>() - 8usize];
    ["Alignment of spa_audio_info_flac"][::std::mem::align_of::<spa_audio_info_flac>() - 4usize];
    ["Offset of field: spa_audio_info_flac::rate"]
        [::std::mem::offset_of!(spa_audio_info_flac, rate) - 0usize];
    ["Offset of field: spa_audio_info_flac::channels"]
        [::std::mem::offset_of!(spa_audio_info_flac, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_ape {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_ape"][::std::mem::size_of::<spa_audio_info_ape>() - 8usize];
    ["Alignment of spa_audio_info_ape"][::std::mem::align_of::<spa_audio_info_ape>() - 4usize];
    ["Offset of field: spa_audio_info_ape::rate"]
        [::std::mem::offset_of!(spa_audio_info_ape, rate) - 0usize];
    ["Offset of field: spa_audio_info_ape::channels"]
        [::std::mem::offset_of!(spa_audio_info_ape, channels) - 4usize];
};
#[doc = " \\addtogroup spa_param\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_info_opus {
    pub rate: u32,
    pub channels: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info_opus"][::std::mem::size_of::<spa_audio_info_opus>() - 8usize];
    ["Alignment of spa_audio_info_opus"][::std::mem::align_of::<spa_audio_info_opus>() - 4usize];
    ["Offset of field: spa_audio_info_opus::rate"]
        [::std::mem::offset_of!(spa_audio_info_opus, rate) - 0usize];
    ["Offset of field: spa_audio_info_opus::channels"]
        [::std::mem::offset_of!(spa_audio_info_opus, channels) - 4usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spa_audio_info {
    pub media_type: u32,
    pub media_subtype: u32,
    pub info: spa_audio_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spa_audio_info__bindgen_ty_1 {
    pub raw: spa_audio_info_raw,
    pub dsp: spa_audio_info_dsp,
    pub iec958: spa_audio_info_iec958,
    pub dsd: spa_audio_info_dsd,
    pub mp3: spa_audio_info_mp3,
    pub aac: spa_audio_info_aac,
    pub vorbis: spa_audio_info_vorbis,
    pub wma: spa_audio_info_wma,
    pub ra: spa_audio_info_ra,
    pub amr: spa_audio_info_amr,
    pub alac: spa_audio_info_alac,
    pub flac: spa_audio_info_flac,
    pub ape: spa_audio_info_ape,
    pub opus: spa_audio_info_ape,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info__bindgen_ty_1"]
        [::std::mem::size_of::<spa_audio_info__bindgen_ty_1>() - 276usize];
    ["Alignment of spa_audio_info__bindgen_ty_1"]
        [::std::mem::align_of::<spa_audio_info__bindgen_ty_1>() - 4usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::raw"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, raw) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::dsp"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, dsp) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::iec958"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, iec958) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::dsd"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, dsd) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::mp3"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, mp3) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::aac"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, aac) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::vorbis"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, vorbis) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::wma"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, wma) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::ra"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, ra) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::amr"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, amr) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::alac"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, alac) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::flac"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, flac) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::ape"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, ape) - 0usize];
    ["Offset of field: spa_audio_info__bindgen_ty_1::opus"]
        [::std::mem::offset_of!(spa_audio_info__bindgen_ty_1, opus) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_info"][::std::mem::size_of::<spa_audio_info>() - 284usize];
    ["Alignment of spa_audio_info"][::std::mem::align_of::<spa_audio_info>() - 4usize];
    ["Offset of field: spa_audio_info::media_type"]
        [::std::mem::offset_of!(spa_audio_info, media_type) - 0usize];
    ["Offset of field: spa_audio_info::media_subtype"]
        [::std::mem::offset_of!(spa_audio_info, media_subtype) - 4usize];
    ["Offset of field: spa_audio_info::info"]
        [::std::mem::offset_of!(spa_audio_info, info) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_format_audio_raw_parse_libspa_rs"]
    pub fn spa_format_audio_raw_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_raw,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_raw_build_libspa_rs"]
    pub fn spa_format_audio_raw_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_raw,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_dsp_parse_libspa_rs"]
    pub fn spa_format_audio_dsp_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_dsp,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_dsp_build_libspa_rs"]
    pub fn spa_format_audio_dsp_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_dsp,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_iec958_parse_libspa_rs"]
    pub fn spa_format_audio_iec958_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_iec958,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_iec958_build_libspa_rs"]
    pub fn spa_format_audio_iec958_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_iec958,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_dsd_parse_libspa_rs"]
    pub fn spa_format_audio_dsd_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_dsd,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_dsd_build_libspa_rs"]
    pub fn spa_format_audio_dsd_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_dsd,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_mp3_parse_libspa_rs"]
    pub fn spa_format_audio_mp3_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_mp3,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_mp3_build_libspa_rs"]
    pub fn spa_format_audio_mp3_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_mp3,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_aac_parse_libspa_rs"]
    pub fn spa_format_audio_aac_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_aac,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_aac_build_libspa_rs"]
    pub fn spa_format_audio_aac_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_aac,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_vorbis_parse_libspa_rs"]
    pub fn spa_format_audio_vorbis_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_vorbis,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_vorbis_build_libspa_rs"]
    pub fn spa_format_audio_vorbis_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_vorbis,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_wma_parse_libspa_rs"]
    pub fn spa_format_audio_wma_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_wma,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_wma_build_libspa_rs"]
    pub fn spa_format_audio_wma_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_wma,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_ra_parse_libspa_rs"]
    pub fn spa_format_audio_ra_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_ra,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_ra_build_libspa_rs"]
    pub fn spa_format_audio_ra_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_ra,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_amr_parse_libspa_rs"]
    pub fn spa_format_audio_amr_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_amr,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_amr_build_libspa_rs"]
    pub fn spa_format_audio_amr_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_amr,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_alac_parse_libspa_rs"]
    pub fn spa_format_audio_alac_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_alac,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_alac_build_libspa_rs"]
    pub fn spa_format_audio_alac_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_alac,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_flac_parse_libspa_rs"]
    pub fn spa_format_audio_flac_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_flac,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_flac_build_libspa_rs"]
    pub fn spa_format_audio_flac_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_flac,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_ape_parse_libspa_rs"]
    pub fn spa_format_audio_ape_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info_ape,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_ape_build_libspa_rs"]
    pub fn spa_format_audio_ape_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info_ape,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_parse_libspa_rs"]
    pub fn spa_format_audio_parse(
        format: *const spa_pod,
        info: *mut spa_audio_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_audio_build_libspa_rs"]
    pub fn spa_format_audio_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_audio_info,
    ) -> *mut spa_pod;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_audio_layout_info {
    pub n_channels: u32,
    pub position: [u32; 64usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_audio_layout_info"][::std::mem::size_of::<spa_audio_layout_info>() - 260usize];
    ["Alignment of spa_audio_layout_info"]
        [::std::mem::align_of::<spa_audio_layout_info>() - 4usize];
    ["Offset of field: spa_audio_layout_info::n_channels"]
        [::std::mem::offset_of!(spa_audio_layout_info, n_channels) - 0usize];
    ["Offset of field: spa_audio_layout_info::position"]
        [::std::mem::offset_of!(spa_audio_layout_info, position) - 4usize];
};
pub const SPA_H264_STREAM_FORMAT_UNKNOWN: spa_h264_stream_format = 0;
pub const SPA_H264_STREAM_FORMAT_AVC: spa_h264_stream_format = 1;
pub const SPA_H264_STREAM_FORMAT_AVC3: spa_h264_stream_format = 2;
pub const SPA_H264_STREAM_FORMAT_BYTESTREAM: spa_h264_stream_format = 3;
pub type spa_h264_stream_format = ::std::os::raw::c_uint;
pub const SPA_H264_ALIGNMENT_UNKNOWN: spa_h264_alignment = 0;
pub const SPA_H264_ALIGNMENT_AU: spa_h264_alignment = 1;
pub const SPA_H264_ALIGNMENT_NAL: spa_h264_alignment = 2;
pub type spa_h264_alignment = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_h264 {
    pub size: spa_rectangle,
    pub framerate: spa_fraction,
    pub max_framerate: spa_fraction,
    pub stream_format: spa_h264_stream_format,
    pub alignment: spa_h264_alignment,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_h264"][::std::mem::size_of::<spa_video_info_h264>() - 32usize];
    ["Alignment of spa_video_info_h264"][::std::mem::align_of::<spa_video_info_h264>() - 4usize];
    ["Offset of field: spa_video_info_h264::size"]
        [::std::mem::offset_of!(spa_video_info_h264, size) - 0usize];
    ["Offset of field: spa_video_info_h264::framerate"]
        [::std::mem::offset_of!(spa_video_info_h264, framerate) - 8usize];
    ["Offset of field: spa_video_info_h264::max_framerate"]
        [::std::mem::offset_of!(spa_video_info_h264, max_framerate) - 16usize];
    ["Offset of field: spa_video_info_h264::stream_format"]
        [::std::mem::offset_of!(spa_video_info_h264, stream_format) - 24usize];
    ["Offset of field: spa_video_info_h264::alignment"]
        [::std::mem::offset_of!(spa_video_info_h264, alignment) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_mjpg {
    pub size: spa_rectangle,
    pub framerate: spa_fraction,
    pub max_framerate: spa_fraction,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_mjpg"][::std::mem::size_of::<spa_video_info_mjpg>() - 24usize];
    ["Alignment of spa_video_info_mjpg"][::std::mem::align_of::<spa_video_info_mjpg>() - 4usize];
    ["Offset of field: spa_video_info_mjpg::size"]
        [::std::mem::offset_of!(spa_video_info_mjpg, size) - 0usize];
    ["Offset of field: spa_video_info_mjpg::framerate"]
        [::std::mem::offset_of!(spa_video_info_mjpg, framerate) - 8usize];
    ["Offset of field: spa_video_info_mjpg::max_framerate"]
        [::std::mem::offset_of!(spa_video_info_mjpg, max_framerate) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_video_info_dsp {
    pub format: spa_video_format,
    pub flags: u32,
    pub modifier: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info_dsp"][::std::mem::size_of::<spa_video_info_dsp>() - 16usize];
    ["Alignment of spa_video_info_dsp"][::std::mem::align_of::<spa_video_info_dsp>() - 8usize];
    ["Offset of field: spa_video_info_dsp::format"]
        [::std::mem::offset_of!(spa_video_info_dsp, format) - 0usize];
    ["Offset of field: spa_video_info_dsp::flags"]
        [::std::mem::offset_of!(spa_video_info_dsp, flags) - 4usize];
    ["Offset of field: spa_video_info_dsp::modifier"]
        [::std::mem::offset_of!(spa_video_info_dsp, modifier) - 8usize];
};
#[repr(C)]
#[derive(Copy, Clone)]
pub struct spa_video_info {
    pub media_type: u32,
    pub media_subtype: u32,
    pub info: spa_video_info__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union spa_video_info__bindgen_ty_1 {
    pub raw: spa_video_info_raw,
    pub dsp: spa_video_info_dsp,
    pub h264: spa_video_info_h264,
    pub mjpg: spa_video_info_mjpg,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info__bindgen_ty_1"]
        [::std::mem::size_of::<spa_video_info__bindgen_ty_1>() - 88usize];
    ["Alignment of spa_video_info__bindgen_ty_1"]
        [::std::mem::align_of::<spa_video_info__bindgen_ty_1>() - 8usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::raw"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, raw) - 0usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::dsp"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, dsp) - 0usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::h264"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, h264) - 0usize];
    ["Offset of field: spa_video_info__bindgen_ty_1::mjpg"]
        [::std::mem::offset_of!(spa_video_info__bindgen_ty_1, mjpg) - 0usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_video_info"][::std::mem::size_of::<spa_video_info>() - 96usize];
    ["Alignment of spa_video_info"][::std::mem::align_of::<spa_video_info>() - 8usize];
    ["Offset of field: spa_video_info::media_type"]
        [::std::mem::offset_of!(spa_video_info, media_type) - 0usize];
    ["Offset of field: spa_video_info::media_subtype"]
        [::std::mem::offset_of!(spa_video_info, media_subtype) - 4usize];
    ["Offset of field: spa_video_info::info"]
        [::std::mem::offset_of!(spa_video_info, info) - 8usize];
};
unsafe extern "C" {
    #[link_name = "spa_format_video_raw_parse_libspa_rs"]
    pub fn spa_format_video_raw_parse(
        format: *const spa_pod,
        info: *mut spa_video_info_raw,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_raw_build_libspa_rs"]
    pub fn spa_format_video_raw_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_video_info_raw,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_dsp_parse_libspa_rs"]
    pub fn spa_format_video_dsp_parse(
        format: *const spa_pod,
        info: *mut spa_video_info_dsp,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_dsp_build_libspa_rs"]
    pub fn spa_format_video_dsp_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_video_info_dsp,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_h264_parse_libspa_rs"]
    pub fn spa_format_video_h264_parse(
        format: *const spa_pod,
        info: *mut spa_video_info_h264,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_h264_build_libspa_rs"]
    pub fn spa_format_video_h264_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_video_info_h264,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_mjpg_parse_libspa_rs"]
    pub fn spa_format_video_mjpg_parse(
        format: *const spa_pod,
        info: *mut spa_video_info_mjpg,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_mjpg_build_libspa_rs"]
    pub fn spa_format_video_mjpg_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_video_info_mjpg,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_parse_libspa_rs"]
    pub fn spa_format_video_parse(
        format: *const spa_pod,
        info: *mut spa_video_info,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_format_video_build_libspa_rs"]
    pub fn spa_format_video_build(
        builder: *mut spa_pod_builder,
        id: u32,
        info: *const spa_video_info,
    ) -> *mut spa_pod;
}
unsafe extern "C" {
    #[doc = " \\addtogroup spa_pod\n \\{"]
    #[link_name = "spa_pod_compare_value_libspa_rs"]
    pub fn spa_pod_compare_value(
        type_: u32,
        r1: *const ::std::os::raw::c_void,
        r2: *const ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_compare_libspa_rs"]
    pub fn spa_pod_compare(pod1: *const spa_pod, pod2: *const spa_pod) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\addtogroup spa_pod\n \\{"]
    #[link_name = "spa_pod_choice_fix_default_libspa_rs"]
    pub fn spa_pod_choice_fix_default(choice: *mut spa_pod_choice) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_filter_flags_value_libspa_rs"]
    pub fn spa_pod_filter_flags_value(
        b: *mut spa_pod_builder,
        type_: u32,
        r1: *const ::std::os::raw::c_void,
        r2: *const ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_filter_is_step_of_libspa_rs"]
    pub fn spa_pod_filter_is_step_of(
        type_: u32,
        r1: *const ::std::os::raw::c_void,
        r2: *const ::std::os::raw::c_void,
        size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_filter_prop_libspa_rs"]
    pub fn spa_pod_filter_prop(
        b: *mut spa_pod_builder,
        p1: *const spa_pod_prop,
        p2: *const spa_pod_prop,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_filter_part_libspa_rs"]
    pub fn spa_pod_filter_part(
        b: *mut spa_pod_builder,
        pod: *const spa_pod,
        pod_size: u32,
        filter: *const spa_pod,
        filter_size: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_pod_filter_libspa_rs"]
    pub fn spa_pod_filter(
        b: *mut spa_pod_builder,
        result: *mut *mut spa_pod,
        pod: *const spa_pod,
        filter: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_cpu {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_cpu"][::std::mem::size_of::<spa_cpu>() - 32usize];
    ["Alignment of spa_cpu"][::std::mem::align_of::<spa_cpu>() - 8usize];
    ["Offset of field: spa_cpu::iface"][::std::mem::offset_of!(spa_cpu, iface) - 0usize];
};
unsafe extern "C" {
    #[link_name = "spa_cpu_vm_type_to_string_libspa_rs"]
    pub fn spa_cpu_vm_type_to_string(vm_type: u32) -> *const ::std::os::raw::c_char;
}
#[doc = " methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_cpu_methods {
    pub version: u32,
    #[doc = " get CPU flags"]
    pub get_flags:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " force CPU flags, use SPA_CPU_FORCE_AUTODETECT to autodetect CPU flags"]
    pub force_flags: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get number of CPU cores"]
    pub get_count:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    #[doc = " get maximum required alignment of data"]
    pub get_max_align:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    pub get_vm_type:
        ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> u32>,
    pub zero_denormals: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enable: bool,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_cpu_methods"][::std::mem::size_of::<spa_cpu_methods>() - 56usize];
    ["Alignment of spa_cpu_methods"][::std::mem::align_of::<spa_cpu_methods>() - 8usize];
    ["Offset of field: spa_cpu_methods::version"]
        [::std::mem::offset_of!(spa_cpu_methods, version) - 0usize];
    ["Offset of field: spa_cpu_methods::get_flags"]
        [::std::mem::offset_of!(spa_cpu_methods, get_flags) - 8usize];
    ["Offset of field: spa_cpu_methods::force_flags"]
        [::std::mem::offset_of!(spa_cpu_methods, force_flags) - 16usize];
    ["Offset of field: spa_cpu_methods::get_count"]
        [::std::mem::offset_of!(spa_cpu_methods, get_count) - 24usize];
    ["Offset of field: spa_cpu_methods::get_max_align"]
        [::std::mem::offset_of!(spa_cpu_methods, get_max_align) - 32usize];
    ["Offset of field: spa_cpu_methods::get_vm_type"]
        [::std::mem::offset_of!(spa_cpu_methods, get_vm_type) - 40usize];
    ["Offset of field: spa_cpu_methods::zero_denormals"]
        [::std::mem::offset_of!(spa_cpu_methods, zero_denormals) - 48usize];
};
unsafe extern "C" {
    #[link_name = "spa_cpu_get_flags_libspa_rs"]
    pub fn spa_cpu_get_flags(c: *mut spa_cpu) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_cpu_force_flags_libspa_rs"]
    pub fn spa_cpu_force_flags(c: *mut spa_cpu, flags: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_cpu_get_count_libspa_rs"]
    pub fn spa_cpu_get_count(c: *mut spa_cpu) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_cpu_get_max_align_libspa_rs"]
    pub fn spa_cpu_get_max_align(c: *mut spa_cpu) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_cpu_get_vm_type_libspa_rs"]
    pub fn spa_cpu_get_vm_type(c: *mut spa_cpu) -> u32;
}
unsafe extern "C" {
    #[link_name = "spa_cpu_zero_denormals_libspa_rs"]
    pub fn spa_cpu_zero_denormals(c: *mut spa_cpu, enable: bool) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of itimerspec"][::std::mem::size_of::<itimerspec>() - 32usize];
    ["Alignment of itimerspec"][::std::mem::align_of::<itimerspec>() - 8usize];
    ["Offset of field: itimerspec::it_interval"]
        [::std::mem::offset_of!(itimerspec, it_interval) - 0usize];
    ["Offset of field: itimerspec::it_value"]
        [::std::mem::offset_of!(itimerspec, it_value) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_system {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_system"][::std::mem::size_of::<spa_system>() - 32usize];
    ["Alignment of spa_system"][::std::mem::align_of::<spa_system>() - 8usize];
    ["Offset of field: spa_system::iface"][::std::mem::offset_of!(spa_system, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_poll_event {
    pub events: u32,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_poll_event"][::std::mem::size_of::<spa_poll_event>() - 16usize];
    ["Alignment of spa_poll_event"][::std::mem::align_of::<spa_poll_event>() - 8usize];
    ["Offset of field: spa_poll_event::events"]
        [::std::mem::offset_of!(spa_poll_event, events) - 0usize];
    ["Offset of field: spa_poll_event::data"]
        [::std::mem::offset_of!(spa_poll_event, data) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_system_methods {
    pub version: u32,
    pub read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *mut ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            buf: *const ::std::os::raw::c_void,
            count: usize,
        ) -> isize,
    >,
    pub ioctl: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            request: ::std::os::raw::c_ulong,
            ...
        ) -> ::std::os::raw::c_int,
    >,
    pub close: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            value: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub clock_getres: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            res: *mut timespec,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_add: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_mod: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
            events: u32,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_del: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            fd: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub pollfd_wait: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            pfd: ::std::os::raw::c_int,
            ev: *mut spa_poll_event,
            n_ev: ::std::os::raw::c_int,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            clockid: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_settime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
            new_value: *const itimerspec,
            old_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_gettime: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            curr_value: *mut itimerspec,
        ) -> ::std::os::raw::c_int,
    >,
    pub timerfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            expirations: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_write: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub eventfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            count: *mut u64,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal: ::std::os::raw::c_int,
            flags: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub signalfd_read: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            signal: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_system_methods"][::std::mem::size_of::<spa_system_methods>() - 168usize];
    ["Alignment of spa_system_methods"][::std::mem::align_of::<spa_system_methods>() - 8usize];
    ["Offset of field: spa_system_methods::version"]
        [::std::mem::offset_of!(spa_system_methods, version) - 0usize];
    ["Offset of field: spa_system_methods::read"]
        [::std::mem::offset_of!(spa_system_methods, read) - 8usize];
    ["Offset of field: spa_system_methods::write"]
        [::std::mem::offset_of!(spa_system_methods, write) - 16usize];
    ["Offset of field: spa_system_methods::ioctl"]
        [::std::mem::offset_of!(spa_system_methods, ioctl) - 24usize];
    ["Offset of field: spa_system_methods::close"]
        [::std::mem::offset_of!(spa_system_methods, close) - 32usize];
    ["Offset of field: spa_system_methods::clock_gettime"]
        [::std::mem::offset_of!(spa_system_methods, clock_gettime) - 40usize];
    ["Offset of field: spa_system_methods::clock_getres"]
        [::std::mem::offset_of!(spa_system_methods, clock_getres) - 48usize];
    ["Offset of field: spa_system_methods::pollfd_create"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_create) - 56usize];
    ["Offset of field: spa_system_methods::pollfd_add"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_add) - 64usize];
    ["Offset of field: spa_system_methods::pollfd_mod"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_mod) - 72usize];
    ["Offset of field: spa_system_methods::pollfd_del"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_del) - 80usize];
    ["Offset of field: spa_system_methods::pollfd_wait"]
        [::std::mem::offset_of!(spa_system_methods, pollfd_wait) - 88usize];
    ["Offset of field: spa_system_methods::timerfd_create"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_create) - 96usize];
    ["Offset of field: spa_system_methods::timerfd_settime"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_settime) - 104usize];
    ["Offset of field: spa_system_methods::timerfd_gettime"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_gettime) - 112usize];
    ["Offset of field: spa_system_methods::timerfd_read"]
        [::std::mem::offset_of!(spa_system_methods, timerfd_read) - 120usize];
    ["Offset of field: spa_system_methods::eventfd_create"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_create) - 128usize];
    ["Offset of field: spa_system_methods::eventfd_write"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_write) - 136usize];
    ["Offset of field: spa_system_methods::eventfd_read"]
        [::std::mem::offset_of!(spa_system_methods, eventfd_read) - 144usize];
    ["Offset of field: spa_system_methods::signalfd_create"]
        [::std::mem::offset_of!(spa_system_methods, signalfd_create) - 152usize];
    ["Offset of field: spa_system_methods::signalfd_read"]
        [::std::mem::offset_of!(spa_system_methods, signalfd_read) - 160usize];
};
unsafe extern "C" {
    #[link_name = "spa_system_read_libspa_rs"]
    pub fn spa_system_read(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        buf: *mut ::std::os::raw::c_void,
        count: usize,
    ) -> isize;
}
unsafe extern "C" {
    #[link_name = "spa_system_write_libspa_rs"]
    pub fn spa_system_write(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        buf: *const ::std::os::raw::c_void,
        count: usize,
    ) -> isize;
}
unsafe extern "C" {
    #[link_name = "spa_system_close_libspa_rs"]
    pub fn spa_system_close(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_clock_gettime_libspa_rs"]
    pub fn spa_system_clock_gettime(
        object: *mut spa_system,
        clockid: ::std::os::raw::c_int,
        value: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_clock_getres_libspa_rs"]
    pub fn spa_system_clock_getres(
        object: *mut spa_system,
        clockid: ::std::os::raw::c_int,
        res: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_pollfd_create_libspa_rs"]
    pub fn spa_system_pollfd_create(
        object: *mut spa_system,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_pollfd_add_libspa_rs"]
    pub fn spa_system_pollfd_add(
        object: *mut spa_system,
        pfd: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        events: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_pollfd_mod_libspa_rs"]
    pub fn spa_system_pollfd_mod(
        object: *mut spa_system,
        pfd: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
        events: u32,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_pollfd_del_libspa_rs"]
    pub fn spa_system_pollfd_del(
        object: *mut spa_system,
        pfd: ::std::os::raw::c_int,
        fd: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_pollfd_wait_libspa_rs"]
    pub fn spa_system_pollfd_wait(
        object: *mut spa_system,
        pfd: ::std::os::raw::c_int,
        ev: *mut spa_poll_event,
        n_ev: ::std::os::raw::c_int,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_timerfd_create_libspa_rs"]
    pub fn spa_system_timerfd_create(
        object: *mut spa_system,
        clockid: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_timerfd_settime_libspa_rs"]
    pub fn spa_system_timerfd_settime(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
        new_value: *const itimerspec,
        old_value: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_timerfd_gettime_libspa_rs"]
    pub fn spa_system_timerfd_gettime(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        curr_value: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_timerfd_read_libspa_rs"]
    pub fn spa_system_timerfd_read(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        expirations: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_eventfd_create_libspa_rs"]
    pub fn spa_system_eventfd_create(
        object: *mut spa_system,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_eventfd_write_libspa_rs"]
    pub fn spa_system_eventfd_write(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        count: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_eventfd_read_libspa_rs"]
    pub fn spa_system_eventfd_read(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        count: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_signalfd_create_libspa_rs"]
    pub fn spa_system_signalfd_create(
        object: *mut spa_system,
        signal: ::std::os::raw::c_int,
        flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_system_signalfd_read_libspa_rs"]
    pub fn spa_system_signalfd_read(
        object: *mut spa_system,
        fd: ::std::os::raw::c_int,
        signal: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop"][::std::mem::size_of::<spa_loop>() - 32usize];
    ["Alignment of spa_loop"][::std::mem::align_of::<spa_loop>() - 8usize];
    ["Offset of field: spa_loop::iface"][::std::mem::offset_of!(spa_loop, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_control {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control"][::std::mem::size_of::<spa_loop_control>() - 32usize];
    ["Alignment of spa_loop_control"][::std::mem::align_of::<spa_loop_control>() - 8usize];
    ["Offset of field: spa_loop_control::iface"]
        [::std::mem::offset_of!(spa_loop_control, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_utils {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_utils"][::std::mem::size_of::<spa_loop_utils>() - 32usize];
    ["Alignment of spa_loop_utils"][::std::mem::align_of::<spa_loop_utils>() - 8usize];
    ["Offset of field: spa_loop_utils::iface"]
        [::std::mem::offset_of!(spa_loop_utils, iface) - 0usize];
};
pub type spa_source_func_t = ::std::option::Option<unsafe extern "C" fn(source: *mut spa_source)>;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_source {
    pub loop_: *mut spa_loop,
    pub func: spa_source_func_t,
    pub data: *mut ::std::os::raw::c_void,
    pub fd: ::std::os::raw::c_int,
    pub mask: u32,
    pub rmask: u32,
    pub priv_: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_source"][::std::mem::size_of::<spa_source>() - 48usize];
    ["Alignment of spa_source"][::std::mem::align_of::<spa_source>() - 8usize];
    ["Offset of field: spa_source::loop_"][::std::mem::offset_of!(spa_source, loop_) - 0usize];
    ["Offset of field: spa_source::func"][::std::mem::offset_of!(spa_source, func) - 8usize];
    ["Offset of field: spa_source::data"][::std::mem::offset_of!(spa_source, data) - 16usize];
    ["Offset of field: spa_source::fd"][::std::mem::offset_of!(spa_source, fd) - 24usize];
    ["Offset of field: spa_source::mask"][::std::mem::offset_of!(spa_source, mask) - 28usize];
    ["Offset of field: spa_source::rmask"][::std::mem::offset_of!(spa_source, rmask) - 32usize];
    ["Offset of field: spa_source::priv_"][::std::mem::offset_of!(spa_source, priv_) - 40usize];
};
pub type spa_invoke_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        loop_: *mut spa_loop,
        async_: bool,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Register sources and work items to an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_methods {
    pub version: u32,
    #[doc = " Add a source to the loop. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub add_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update the source io mask. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub update_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Remove a source from the loop. Must be called from the loop's own thread.\n\n \\param[in] object The callbacks data.\n \\param[in] source The source.\n \\return 0 on success, negative errno-style value on failure."]
    pub remove_source: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Invoke a function in the context of this loop.\n May be called from any thread and multiple threads at the same time.\n If called from the loop's thread, all callbacks previously queued with\n invoke() will be run synchronously, which might cause unexpected\n reentrancy problems.\n\n \\param[in] object The callbacks data.\n \\param func The function to be invoked.\n \\param seq An opaque sequence number. This will be made\n            available to func.\n \\param[in] data Data that will be copied into the internal ring buffer and made\n             available to func. Because this data is copied, it is okay to\n             pass a pointer to a local variable, but do not pass a pointer to\n             an object that has identity.\n \\param size The size of data to copy.\n \\param block If \\true, do not return until func has been called. Otherwise,\n              returns immediately. Passing \\true does not risk a deadlock because\n              the data thread is never allowed to wait on any other thread.\n              It the loop requires some locking, it must be acquired before\n              calling this function because a blocking invoke will release\n              the lock while blocking.\n \\param user_data An opaque pointer passed to func.\n \\return `-EPIPE` if the internal ring buffer filled up,\n         if block is \\false, 0 if seq was SPA_ID_INVALID or\n         seq with the ASYNC flag set\n         or the return value of func otherwise."]
    pub invoke: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_invoke_func_t,
            seq: u32,
            data: *const ::std::os::raw::c_void,
            size: usize,
            block: bool,
            user_data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_methods"][::std::mem::size_of::<spa_loop_methods>() - 40usize];
    ["Alignment of spa_loop_methods"][::std::mem::align_of::<spa_loop_methods>() - 8usize];
    ["Offset of field: spa_loop_methods::version"]
        [::std::mem::offset_of!(spa_loop_methods, version) - 0usize];
    ["Offset of field: spa_loop_methods::add_source"]
        [::std::mem::offset_of!(spa_loop_methods, add_source) - 8usize];
    ["Offset of field: spa_loop_methods::update_source"]
        [::std::mem::offset_of!(spa_loop_methods, update_source) - 16usize];
    ["Offset of field: spa_loop_methods::remove_source"]
        [::std::mem::offset_of!(spa_loop_methods, remove_source) - 24usize];
    ["Offset of field: spa_loop_methods::invoke"]
        [::std::mem::offset_of!(spa_loop_methods, invoke) - 32usize];
};
unsafe extern "C" {
    #[link_name = "spa_loop_add_source_libspa_rs"]
    pub fn spa_loop_add_source(
        object: *mut spa_loop,
        source: *mut spa_source,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_update_source_libspa_rs"]
    pub fn spa_loop_update_source(
        object: *mut spa_loop,
        source: *mut spa_source,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_remove_source_libspa_rs"]
    pub fn spa_loop_remove_source(
        object: *mut spa_loop,
        source: *mut spa_source,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_invoke_libspa_rs"]
    pub fn spa_loop_invoke(
        object: *mut spa_loop,
        func: spa_invoke_func_t,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        block: bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Control hooks. These hooks can't be removed from their\n  callbacks and must be removed from a safe place (when the loop\n  is not running or when it is locked)."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_control_hooks {
    pub version: u32,
    #[doc = " Executed right before waiting for events. It is typically used to\n release locks."]
    pub before: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " Executed right after waiting for events. It is typically used to\n reacquire locks."]
    pub after: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control_hooks"][::std::mem::size_of::<spa_loop_control_hooks>() - 24usize];
    ["Alignment of spa_loop_control_hooks"]
        [::std::mem::align_of::<spa_loop_control_hooks>() - 8usize];
    ["Offset of field: spa_loop_control_hooks::version"]
        [::std::mem::offset_of!(spa_loop_control_hooks, version) - 0usize];
    ["Offset of field: spa_loop_control_hooks::before"]
        [::std::mem::offset_of!(spa_loop_control_hooks, before) - 8usize];
    ["Offset of field: spa_loop_control_hooks::after"]
        [::std::mem::offset_of!(spa_loop_control_hooks, after) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_loop_control_hook_before_libspa_rs"]
    pub fn spa_loop_control_hook_before(l: *mut spa_hook_list);
}
unsafe extern "C" {
    #[link_name = "spa_loop_control_hook_after_libspa_rs"]
    pub fn spa_loop_control_hook_after(l: *mut spa_hook_list);
}
#[doc = " Control an event loop\n\n The event loop control function provide API to run the event loop.\n\n The below (pseudo)code is a minimal example outlining the use of the loop\n control:\n \\code{.c}\n spa_loop_control_enter(loop);\n while (running) {\n   spa_loop_control_iterate(loop, -1);\n }\n spa_loop_control_leave(loop);\n \\endcode\n\n It is also possible to add the loop to an existing event loop by using the\n spa_loop_control_get_fd() call. This fd will become readable when activity\n has been detected on the sources in the loop. spa_loop_control_iterate() with\n a 0 timeout should be called to process the pending sources.\n\n spa_loop_control_enter() and spa_loop_control_leave() should be called once\n from the thread that will run the iterate() function."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_control_methods {
    pub version: u32,
    #[doc = " get the loop fd\n \\param object the control to query\n\n Get the fd of this loop control. This fd will be readable when a\n source in the loop has activity. The user should call iterate()\n with a 0 timeout to schedule one iteration of the loop and dispatch\n the sources.\n \\return the fd of the loop"]
    pub get_fd: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
    #[doc = " Add a hook\n \\param object the control to change\n \\param hooks the hooks to add\n\n Adds hooks to the loop controlled by \\a ctrl."]
    pub add_hook: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            hook: *mut spa_hook,
            hooks: *const spa_loop_control_hooks,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Enter a loop\n \\param object the control\n\n This function should be called before calling iterate and is\n typically used to capture the thread that this loop will run in.\n It should ideally be called once from the thread that will run\n the loop."]
    pub enter: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Leave a loop\n \\param object the control\n\n It should ideally be called once after calling iterate when the loop\n will no longer be iterated from the thread that called enter()."]
    pub leave: ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>,
    #[doc = " Perform one iteration of the loop.\n \\param ctrl the control\n \\param timeout an optional timeout in milliseconds.\n\t0 for no timeout, -1 for infinite timeout.\n\n This function will block\n up to \\a timeout milliseconds and then dispatch the fds with activity.\n The number of dispatched fds is returned."]
    pub iterate: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            timeout: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Check context of the loop\n \\param ctrl the control\n\n This function will check if the current thread is currently the\n one that did the enter call. Since version 1:1.\n\n returns 1 on success, 0 or negative errno value on error."]
    pub check: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_control_methods"]
        [::std::mem::size_of::<spa_loop_control_methods>() - 56usize];
    ["Alignment of spa_loop_control_methods"]
        [::std::mem::align_of::<spa_loop_control_methods>() - 8usize];
    ["Offset of field: spa_loop_control_methods::version"]
        [::std::mem::offset_of!(spa_loop_control_methods, version) - 0usize];
    ["Offset of field: spa_loop_control_methods::get_fd"]
        [::std::mem::offset_of!(spa_loop_control_methods, get_fd) - 8usize];
    ["Offset of field: spa_loop_control_methods::add_hook"]
        [::std::mem::offset_of!(spa_loop_control_methods, add_hook) - 16usize];
    ["Offset of field: spa_loop_control_methods::enter"]
        [::std::mem::offset_of!(spa_loop_control_methods, enter) - 24usize];
    ["Offset of field: spa_loop_control_methods::leave"]
        [::std::mem::offset_of!(spa_loop_control_methods, leave) - 32usize];
    ["Offset of field: spa_loop_control_methods::iterate"]
        [::std::mem::offset_of!(spa_loop_control_methods, iterate) - 40usize];
    ["Offset of field: spa_loop_control_methods::check"]
        [::std::mem::offset_of!(spa_loop_control_methods, check) - 48usize];
};
unsafe extern "C" {
    #[link_name = "spa_loop_control_get_fd_libspa_rs"]
    pub fn spa_loop_control_get_fd(object: *mut spa_loop_control) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_control_add_hook_libspa_rs"]
    pub fn spa_loop_control_add_hook(
        object: *mut spa_loop_control,
        hook: *mut spa_hook,
        hooks: *const spa_loop_control_hooks,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[link_name = "spa_loop_control_enter_libspa_rs"]
    pub fn spa_loop_control_enter(object: *mut spa_loop_control);
}
unsafe extern "C" {
    #[link_name = "spa_loop_control_leave_libspa_rs"]
    pub fn spa_loop_control_leave(object: *mut spa_loop_control);
}
unsafe extern "C" {
    #[link_name = "spa_loop_control_iterate_libspa_rs"]
    pub fn spa_loop_control_iterate(
        object: *mut spa_loop_control,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_control_iterate_fast_libspa_rs"]
    pub fn spa_loop_control_iterate_fast(
        object: *mut spa_loop_control,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_control_check_libspa_rs"]
    pub fn spa_loop_control_check(object: *mut spa_loop_control) -> ::std::os::raw::c_int;
}
pub type spa_source_io_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, fd: ::std::os::raw::c_int, mask: u32),
>;
pub type spa_source_idle_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>;
pub type spa_source_event_func_t =
    ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, count: u64)>;
pub type spa_source_timer_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, expirations: u64),
>;
pub type spa_source_signal_func_t = ::std::option::Option<
    unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, signal_number: ::std::os::raw::c_int),
>;
#[doc = " Create sources for an event loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_loop_utils_methods {
    pub version: u32,
    pub add_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            fd: ::std::os::raw::c_int,
            mask: u32,
            close: bool,
            func: spa_source_io_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_io: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            mask: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            enabled: bool,
            func: spa_source_idle_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub enable_idle: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            enabled: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_event_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub signal_event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            func: spa_source_timer_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    pub update_timer: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            source: *mut spa_source,
            value: *mut timespec,
            interval: *mut timespec,
            absolute: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub add_signal: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            signal_number: ::std::os::raw::c_int,
            func: spa_source_signal_func_t,
            data: *mut ::std::os::raw::c_void,
        ) -> *mut spa_source,
    >,
    #[doc = " destroy a source allocated with this interface. This function\n should only be called when the loop is not running or from the\n context of the running loop"]
    pub destroy_source: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, source: *mut spa_source),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_loop_utils_methods"][::std::mem::size_of::<spa_loop_utils_methods>() - 88usize];
    ["Alignment of spa_loop_utils_methods"]
        [::std::mem::align_of::<spa_loop_utils_methods>() - 8usize];
    ["Offset of field: spa_loop_utils_methods::version"]
        [::std::mem::offset_of!(spa_loop_utils_methods, version) - 0usize];
    ["Offset of field: spa_loop_utils_methods::add_io"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_io) - 8usize];
    ["Offset of field: spa_loop_utils_methods::update_io"]
        [::std::mem::offset_of!(spa_loop_utils_methods, update_io) - 16usize];
    ["Offset of field: spa_loop_utils_methods::add_idle"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_idle) - 24usize];
    ["Offset of field: spa_loop_utils_methods::enable_idle"]
        [::std::mem::offset_of!(spa_loop_utils_methods, enable_idle) - 32usize];
    ["Offset of field: spa_loop_utils_methods::add_event"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_event) - 40usize];
    ["Offset of field: spa_loop_utils_methods::signal_event"]
        [::std::mem::offset_of!(spa_loop_utils_methods, signal_event) - 48usize];
    ["Offset of field: spa_loop_utils_methods::add_timer"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_timer) - 56usize];
    ["Offset of field: spa_loop_utils_methods::update_timer"]
        [::std::mem::offset_of!(spa_loop_utils_methods, update_timer) - 64usize];
    ["Offset of field: spa_loop_utils_methods::add_signal"]
        [::std::mem::offset_of!(spa_loop_utils_methods, add_signal) - 72usize];
    ["Offset of field: spa_loop_utils_methods::destroy_source"]
        [::std::mem::offset_of!(spa_loop_utils_methods, destroy_source) - 80usize];
};
unsafe extern "C" {
    #[link_name = "spa_loop_utils_add_io_libspa_rs"]
    pub fn spa_loop_utils_add_io(
        object: *mut spa_loop_utils,
        fd: ::std::os::raw::c_int,
        mask: u32,
        close: bool,
        func: spa_source_io_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut spa_source;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_update_io_libspa_rs"]
    pub fn spa_loop_utils_update_io(
        object: *mut spa_loop_utils,
        source: *mut spa_source,
        mask: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_add_idle_libspa_rs"]
    pub fn spa_loop_utils_add_idle(
        object: *mut spa_loop_utils,
        enabled: bool,
        func: spa_source_idle_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut spa_source;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_enable_idle_libspa_rs"]
    pub fn spa_loop_utils_enable_idle(
        object: *mut spa_loop_utils,
        source: *mut spa_source,
        enabled: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_add_event_libspa_rs"]
    pub fn spa_loop_utils_add_event(
        object: *mut spa_loop_utils,
        func: spa_source_event_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut spa_source;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_signal_event_libspa_rs"]
    pub fn spa_loop_utils_signal_event(
        object: *mut spa_loop_utils,
        source: *mut spa_source,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_add_timer_libspa_rs"]
    pub fn spa_loop_utils_add_timer(
        object: *mut spa_loop_utils,
        func: spa_source_timer_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut spa_source;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_update_timer_libspa_rs"]
    pub fn spa_loop_utils_update_timer(
        object: *mut spa_loop_utils,
        source: *mut spa_source,
        value: *mut timespec,
        interval: *mut timespec,
        absolute: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_add_signal_libspa_rs"]
    pub fn spa_loop_utils_add_signal(
        object: *mut spa_loop_utils,
        signal_number: ::std::os::raw::c_int,
        func: spa_source_signal_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut spa_source;
}
unsafe extern "C" {
    #[link_name = "spa_loop_utils_destroy_source_libspa_rs"]
    pub fn spa_loop_utils_destroy_source(object: *mut spa_loop_utils, source: *mut spa_source);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus"][::std::mem::size_of::<spa_dbus>() - 32usize];
    ["Alignment of spa_dbus"][::std::mem::align_of::<spa_dbus>() - 8usize];
    ["Offset of field: spa_dbus::iface"][::std::mem::offset_of!(spa_dbus, iface) - 0usize];
};
#[doc = "< The login session bus"]
pub const SPA_DBUS_TYPE_SESSION: spa_dbus_type = 0;
#[doc = "< The systemwide bus"]
pub const SPA_DBUS_TYPE_SYSTEM: spa_dbus_type = 1;
#[doc = "< The bus that started us, if any"]
pub const SPA_DBUS_TYPE_STARTER: spa_dbus_type = 2;
pub type spa_dbus_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus_connection_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    pub disconnected:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus_connection_events"]
        [::std::mem::size_of::<spa_dbus_connection_events>() - 24usize];
    ["Alignment of spa_dbus_connection_events"]
        [::std::mem::align_of::<spa_dbus_connection_events>() - 8usize];
    ["Offset of field: spa_dbus_connection_events::version"]
        [::std::mem::offset_of!(spa_dbus_connection_events, version) - 0usize];
    ["Offset of field: spa_dbus_connection_events::destroy"]
        [::std::mem::offset_of!(spa_dbus_connection_events, destroy) - 8usize];
    ["Offset of field: spa_dbus_connection_events::disconnected"]
        [::std::mem::offset_of!(spa_dbus_connection_events, disconnected) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus_connection {
    pub version: u32,
    #[doc = " Get the DBusConnection from a wrapper\n\n Note that the returned handle is closed and unref'd by spa_dbus\n immediately before emitting the asynchronous \"disconnected\" event.\n The caller must either deal with the invalidation, or keep an extra\n ref on the handle returned.\n\n \\param conn the spa_dbus_connection wrapper\n \\return a pointer of type DBusConnection"]
    pub get: ::std::option::Option<
        unsafe extern "C" fn(conn: *mut spa_dbus_connection) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroy a dbus connection wrapper\n\n \\param conn the wrapper to destroy"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(conn: *mut spa_dbus_connection)>,
    #[doc = " Add a listener for events\n\n Since version 1"]
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            conn: *mut spa_dbus_connection,
            listener: *mut spa_hook,
            events: *const spa_dbus_connection_events,
            data: *mut ::std::os::raw::c_void,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus_connection"][::std::mem::size_of::<spa_dbus_connection>() - 32usize];
    ["Alignment of spa_dbus_connection"][::std::mem::align_of::<spa_dbus_connection>() - 8usize];
    ["Offset of field: spa_dbus_connection::version"]
        [::std::mem::offset_of!(spa_dbus_connection, version) - 0usize];
    ["Offset of field: spa_dbus_connection::get"]
        [::std::mem::offset_of!(spa_dbus_connection, get) - 8usize];
    ["Offset of field: spa_dbus_connection::destroy"]
        [::std::mem::offset_of!(spa_dbus_connection, destroy) - 16usize];
    ["Offset of field: spa_dbus_connection::add_listener"]
        [::std::mem::offset_of!(spa_dbus_connection, add_listener) - 24usize];
};
unsafe extern "C" {
    #[doc = " \\copydoc spa_dbus_connection.get\n \\sa spa_dbus_connection.get"]
    #[link_name = "spa_dbus_connection_get_libspa_rs"]
    pub fn spa_dbus_connection_get(conn: *mut spa_dbus_connection) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " \\copydoc spa_dbus_connection.destroy\n \\sa spa_dbus_connection.destroy"]
    #[link_name = "spa_dbus_connection_destroy_libspa_rs"]
    pub fn spa_dbus_connection_destroy(conn: *mut spa_dbus_connection);
}
unsafe extern "C" {
    #[doc = " \\copydoc spa_dbus_connection.add_listener\n \\sa spa_dbus_connection.add_listener"]
    #[link_name = "spa_dbus_connection_add_listener_libspa_rs"]
    pub fn spa_dbus_connection_add_listener(
        conn: *mut spa_dbus_connection,
        listener: *mut spa_hook,
        events: *const spa_dbus_connection_events,
        data: *mut ::std::os::raw::c_void,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_dbus_methods {
    pub version: u32,
    #[doc = " Get a new connection wrapper for the given bus type.\n\n The connection wrapper is completely configured to operate\n in the main context of the handle that manages the spa_dbus\n interface.\n\n \\param dbus the dbus manager\n \\param type the bus type to wrap\n \\param error location for the DBusError\n \\return a new dbus connection wrapper or NULL on error"]
    pub get_connection: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            type_: spa_dbus_type,
        ) -> *mut spa_dbus_connection,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_dbus_methods"][::std::mem::size_of::<spa_dbus_methods>() - 16usize];
    ["Alignment of spa_dbus_methods"][::std::mem::align_of::<spa_dbus_methods>() - 8usize];
    ["Offset of field: spa_dbus_methods::version"]
        [::std::mem::offset_of!(spa_dbus_methods, version) - 0usize];
    ["Offset of field: spa_dbus_methods::get_connection"]
        [::std::mem::offset_of!(spa_dbus_methods, get_connection) - 8usize];
};
unsafe extern "C" {
    #[doc = " \\copydoc spa_dbus_methods.get_connection\n \\sa spa_dbus_methods.get_connection"]
    #[link_name = "spa_dbus_get_connection_libspa_rs"]
    pub fn spa_dbus_get_connection(
        dbus: *mut spa_dbus,
        type_: spa_dbus_type,
    ) -> *mut spa_dbus_connection;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_i18n {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_i18n"][::std::mem::size_of::<spa_i18n>() - 32usize];
    ["Alignment of spa_i18n"][::std::mem::align_of::<spa_i18n>() - 8usize];
    ["Offset of field: spa_i18n::iface"][::std::mem::offset_of!(spa_i18n, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_i18n_methods {
    pub version: u32,
    #[doc = " Translate a message\n\n \\param object the i18n interface\n \\param msgid the message\n \\return a translated message"]
    pub text: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msgid: *const ::std::os::raw::c_char,
        ) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Translate a message for a number\n\n \\param object the i18n interface\n \\param msgid the message to translate\n \\param msgid_plural the plural form of \\a msgid\n \\param n a number\n \\return a translated message for the number \\a n"]
    pub ntext: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msgid: *const ::std::os::raw::c_char,
            msgid_plural: *const ::std::os::raw::c_char,
            n: ::std::os::raw::c_ulong,
        ) -> *const ::std::os::raw::c_char,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_i18n_methods"][::std::mem::size_of::<spa_i18n_methods>() - 24usize];
    ["Alignment of spa_i18n_methods"][::std::mem::align_of::<spa_i18n_methods>() - 8usize];
    ["Offset of field: spa_i18n_methods::version"]
        [::std::mem::offset_of!(spa_i18n_methods, version) - 0usize];
    ["Offset of field: spa_i18n_methods::text"]
        [::std::mem::offset_of!(spa_i18n_methods, text) - 8usize];
    ["Offset of field: spa_i18n_methods::ntext"]
        [::std::mem::offset_of!(spa_i18n_methods, ntext) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_i18n_text_libspa_rs"]
    pub fn spa_i18n_text(
        i18n: *mut spa_i18n,
        msgid: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_i18n_ntext_libspa_rs"]
    pub fn spa_i18n_ntext(
        i18n: *mut spa_i18n,
        msgid: *const ::std::os::raw::c_char,
        msgid_plural: *const ::std::os::raw::c_char,
        n: ::std::os::raw::c_ulong,
    ) -> *const ::std::os::raw::c_char;
}
pub const SPA_LOG_LEVEL_NONE: spa_log_level = 0;
pub const SPA_LOG_LEVEL_ERROR: spa_log_level = 1;
pub const SPA_LOG_LEVEL_WARN: spa_log_level = 2;
pub const SPA_LOG_LEVEL_INFO: spa_log_level = 3;
pub const SPA_LOG_LEVEL_DEBUG: spa_log_level = 4;
pub const SPA_LOG_LEVEL_TRACE: spa_log_level = 5;
pub type spa_log_level = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_log {
    pub iface: spa_interface,
    #[doc = " Logging level, everything above this level is not logged"]
    pub level: spa_log_level,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log"][::std::mem::size_of::<spa_log>() - 40usize];
    ["Alignment of spa_log"][::std::mem::align_of::<spa_log>() - 8usize];
    ["Offset of field: spa_log::iface"][::std::mem::offset_of!(spa_log, iface) - 0usize];
    ["Offset of field: spa_log::level"][::std::mem::offset_of!(spa_log, level) - 32usize];
};
#[doc = " \\struct spa_log_topic\n\n Identifier for a topic. Topics are string-based filters that logically\n group messages together. An implementation may decide to filter different\n topics on different levels, for example the \"protocol\" topic may require\n debug level TRACE while the \"core\" topic defaults to debug level INFO.\n\n spa_log_topics require a spa_log_methods version of 1 or higher."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_log_topic {
    #[doc = " the version of this topic. This can be used to expand this\n structure in the future"]
    pub version: u32,
    #[doc = " The string identifier for the topic"]
    pub topic: *const ::std::os::raw::c_char,
    #[doc = " Logging level set for this topic"]
    pub level: spa_log_level,
    #[doc = " False if this topic follows the \\ref spa_log level"]
    pub has_custom_level: bool,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_topic"][::std::mem::size_of::<spa_log_topic>() - 24usize];
    ["Alignment of spa_log_topic"][::std::mem::align_of::<spa_log_topic>() - 8usize];
    ["Offset of field: spa_log_topic::version"]
        [::std::mem::offset_of!(spa_log_topic, version) - 0usize];
    ["Offset of field: spa_log_topic::topic"]
        [::std::mem::offset_of!(spa_log_topic, topic) - 8usize];
    ["Offset of field: spa_log_topic::level"]
        [::std::mem::offset_of!(spa_log_topic, level) - 16usize];
    ["Offset of field: spa_log_topic::has_custom_level"]
        [::std::mem::offset_of!(spa_log_topic, has_custom_level) - 20usize];
};
#[doc = " Enumeration of log topics in a plugin\n\n \\since 1.1.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_log_topic_enum {
    pub version: u32,
    #[doc = " Array of pointers to log topics"]
    pub topics: *const *mut spa_log_topic,
    #[doc = " End of topics array"]
    pub topics_end: *const *mut spa_log_topic,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_topic_enum"][::std::mem::size_of::<spa_log_topic_enum>() - 24usize];
    ["Alignment of spa_log_topic_enum"][::std::mem::align_of::<spa_log_topic_enum>() - 8usize];
    ["Offset of field: spa_log_topic_enum::version"]
        [::std::mem::offset_of!(spa_log_topic_enum, version) - 0usize];
    ["Offset of field: spa_log_topic_enum::topics"]
        [::std::mem::offset_of!(spa_log_topic_enum, topics) - 8usize];
    ["Offset of field: spa_log_topic_enum::topics_end"]
        [::std::mem::offset_of!(spa_log_topic_enum, topics_end) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_log_methods {
    pub version: u32,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logt() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments"]
    pub log: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level.\n\n \\note If compiled with this header, this function is only called\n for implementations of version 0. For versions 1 and above, see\n logtv() instead.\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments"]
    pub logv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note Callers that do not use topic-based logging (version 0), the \\a\n topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param ... format arguments\n\n \\since 1"]
    pub logt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            ...
        ),
    >,
    #[doc = " Log a message with the given log level for the given topic.\n\n \\note For callers that do not use topic-based logging (version 0),\n the \\a topic is NULL\n\n \\param log a spa_log\n \\param level a spa_log_level\n \\param topic the topic for this message, may be NULL\n \\param file the file name\n \\param line the line number\n \\param func the function name\n \\param fmt printf style format\n \\param args format arguments\n\n \\since 1"]
    pub logtv: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            level: spa_log_level,
            topic: *const spa_log_topic,
            file: *const ::std::os::raw::c_char,
            line: ::std::os::raw::c_int,
            func: *const ::std::os::raw::c_char,
            fmt: *const ::std::os::raw::c_char,
            args: *mut __va_list_tag,
        ),
    >,
    #[doc = " Initializes a \\ref spa_log_topic to the correct logging level.\n\n \\deprecated\n Plugin host should obtain log topics from \\ref SPA_LOG_TOPIC_ENUM_NAME\n and update them itself.\n\n \\since 1"]
    pub topic_init: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, topic: *mut spa_log_topic),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_log_methods"][::std::mem::size_of::<spa_log_methods>() - 48usize];
    ["Alignment of spa_log_methods"][::std::mem::align_of::<spa_log_methods>() - 8usize];
    ["Offset of field: spa_log_methods::version"]
        [::std::mem::offset_of!(spa_log_methods, version) - 0usize];
    ["Offset of field: spa_log_methods::log"]
        [::std::mem::offset_of!(spa_log_methods, log) - 8usize];
    ["Offset of field: spa_log_methods::logv"]
        [::std::mem::offset_of!(spa_log_methods, logv) - 16usize];
    ["Offset of field: spa_log_methods::logt"]
        [::std::mem::offset_of!(spa_log_methods, logt) - 24usize];
    ["Offset of field: spa_log_methods::logtv"]
        [::std::mem::offset_of!(spa_log_methods, logtv) - 32usize];
    ["Offset of field: spa_log_methods::topic_init"]
        [::std::mem::offset_of!(spa_log_methods, topic_init) - 40usize];
};
unsafe extern "C" {
    #[link_name = "spa_log_topic_init_libspa_rs"]
    pub fn spa_log_topic_init(log: *mut spa_log, topic: *mut spa_log_topic);
}
unsafe extern "C" {
    #[link_name = "spa_log_level_topic_enabled_libspa_rs"]
    pub fn spa_log_level_topic_enabled(
        log: *const spa_log,
        topic: *const spa_log_topic,
        level: spa_log_level,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_log_logtv_libspa_rs"]
    pub fn spa_log_logtv(
        l: *mut spa_log,
        level: spa_log_level,
        topic: *const spa_log_topic,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " \\addtogroup spa_log\n \\{"]
    #[link_name = "spa_log_impl_logtv_libspa_rs"]
    pub fn spa_log_impl_logtv(
        object: *mut ::std::os::raw::c_void,
        level: spa_log_level,
        topic: *const spa_log_topic,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[link_name = "spa_log_impl_logv_libspa_rs"]
    pub fn spa_log_impl_logv(
        object: *mut ::std::os::raw::c_void,
        level: spa_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[link_name = "spa_log_impl_topic_init_libspa_rs"]
    pub fn spa_log_impl_topic_init(object: *mut ::std::os::raw::c_void, topic: *mut spa_log_topic);
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_plugin_loader {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_plugin_loader"][::std::mem::size_of::<spa_plugin_loader>() - 32usize];
    ["Alignment of spa_plugin_loader"][::std::mem::align_of::<spa_plugin_loader>() - 8usize];
    ["Offset of field: spa_plugin_loader::iface"]
        [::std::mem::offset_of!(spa_plugin_loader, iface) - 0usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_plugin_loader_methods {
    pub version: u32,
    #[doc = " Load a SPA plugin.\n\n \\param factory_name Plugin factory name\n \\param info Info dictionary for plugin. NULL if none.\n \\return plugin handle, or NULL on error"]
    pub load: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            factory_name: *const ::std::os::raw::c_char,
            info: *const spa_dict,
        ) -> *mut spa_handle,
    >,
    #[doc = " Unload a SPA plugin.\n\n \\param handle Plugin handle.\n \\return 0 on success, < 0 on error"]
    pub unload: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            handle: *mut spa_handle,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_plugin_loader_methods"]
        [::std::mem::size_of::<spa_plugin_loader_methods>() - 24usize];
    ["Alignment of spa_plugin_loader_methods"]
        [::std::mem::align_of::<spa_plugin_loader_methods>() - 8usize];
    ["Offset of field: spa_plugin_loader_methods::version"]
        [::std::mem::offset_of!(spa_plugin_loader_methods, version) - 0usize];
    ["Offset of field: spa_plugin_loader_methods::load"]
        [::std::mem::offset_of!(spa_plugin_loader_methods, load) - 8usize];
    ["Offset of field: spa_plugin_loader_methods::unload"]
        [::std::mem::offset_of!(spa_plugin_loader_methods, unload) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_plugin_loader_load_libspa_rs"]
    pub fn spa_plugin_loader_load(
        loader: *mut spa_plugin_loader,
        factory_name: *const ::std::os::raw::c_char,
        info: *const spa_dict,
    ) -> *mut spa_handle;
}
unsafe extern "C" {
    #[link_name = "spa_plugin_loader_unload_libspa_rs"]
    pub fn spa_plugin_loader_unload(
        loader: *mut spa_plugin_loader,
        handle: *mut spa_handle,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup spa_handle\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_handle {
    pub version: u32,
    #[doc = " Get the interface provided by \\a handle with \\a type.\n\n \\a interface is always a struct spa_interface but depending on\n \\a type, the struct might contain other information.\n\n \\param handle a spa_handle\n \\param type the interface type\n \\param iface result to hold the interface.\n \\return 0 on success\n         -ENOTSUP when there are no interfaces\n         -EINVAL when handle or info is NULL"]
    pub get_interface: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut spa_handle,
            type_: *const ::std::os::raw::c_char,
            iface: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Clean up the memory of \\a handle. After this, \\a handle should not be used\n anymore.\n\n \\param handle a pointer to memory\n \\return 0 on success"]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut spa_handle) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_handle"][::std::mem::size_of::<spa_handle>() - 24usize];
    ["Alignment of spa_handle"][::std::mem::align_of::<spa_handle>() - 8usize];
    ["Offset of field: spa_handle::version"][::std::mem::offset_of!(spa_handle, version) - 0usize];
    ["Offset of field: spa_handle::get_interface"]
        [::std::mem::offset_of!(spa_handle, get_interface) - 8usize];
    ["Offset of field: spa_handle::clear"][::std::mem::offset_of!(spa_handle, clear) - 16usize];
};
unsafe extern "C" {
    #[link_name = "spa_handle_get_interface_libspa_rs"]
    pub fn spa_handle_get_interface(
        object: *mut spa_handle,
        type_: *const ::std::os::raw::c_char,
        iface: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_handle_clear_libspa_rs"]
    pub fn spa_handle_clear(object: *mut spa_handle) -> ::std::os::raw::c_int;
}
#[doc = " This structure lists the information about available interfaces on\n handles."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_interface_info {
    pub type_: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_interface_info"][::std::mem::size_of::<spa_interface_info>() - 8usize];
    ["Alignment of spa_interface_info"][::std::mem::align_of::<spa_interface_info>() - 8usize];
    ["Offset of field: spa_interface_info::type_"]
        [::std::mem::offset_of!(spa_interface_info, type_) - 0usize];
};
#[doc = " Extra supporting infrastructure passed to the init() function of\n a factory. It can be extra information or interfaces such as logging."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_support {
    pub type_: *const ::std::os::raw::c_char,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_support"][::std::mem::size_of::<spa_support>() - 16usize];
    ["Alignment of spa_support"][::std::mem::align_of::<spa_support>() - 8usize];
    ["Offset of field: spa_support::type_"][::std::mem::offset_of!(spa_support, type_) - 0usize];
    ["Offset of field: spa_support::data"][::std::mem::offset_of!(spa_support, data) - 8usize];
};
unsafe extern "C" {
    #[doc = " Find a support item of the given type"]
    #[link_name = "spa_support_find_libspa_rs"]
    pub fn spa_support_find(
        support: *const spa_support,
        n_support: u32,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_handle_factory {
    pub version: u32,
    #[doc = " The name of the factory contains a logical name that describes\n the function of the handle. Other plugins might contain an alternative\n implementation with the same name.\n\n See utils/names.h for the list of standard names.\n\n Examples include:\n\n  api.alsa.pcm.sink: an object to write PCM samples to an alsa PLAYBACK\n\t\t\tdevice\n  api.v4l2.source: an object to read from a v4l2 source."]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Extra information about the handles of this factory."]
    pub info: *const spa_dict,
    #[doc = " Get the size of handles from this factory.\n\n \\param factory a spa_handle_factory\n \\param params extra parameters that determine the size of the\n handle."]
    pub get_size: ::std::option::Option<
        unsafe extern "C" fn(factory: *const spa_handle_factory, params: *const spa_dict) -> usize,
    >,
    #[doc = " Initialize an instance of this factory. The caller should allocate\n memory at least size bytes and pass this as \\a handle.\n\n \\a support can optionally contain extra interfaces or data items that the\n plugin can use such as a logger.\n\n \\param factory a spa_handle_factory\n \\param handle a pointer to memory\n \\param info extra handle specific information, usually obtained\n        from a spa_device. This can be used to configure the handle.\n \\param support support items\n \\param n_support number of elements in \\a support\n \\return 0 on success\n\t   < 0 errno type error"]
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            handle: *mut spa_handle,
            info: *const spa_dict,
            support: *const spa_support,
            n_support: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " spa_handle_factory::enum_interface_info:\n \\param factory: a #spa_handle_factory\n \\param info: result to hold spa_interface_info.\n \\param index: index to keep track of the enumeration, 0 for first item\n\n Enumerate the interface information for \\a factory.\n\n \\return 1 when an item is available\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub enum_interface_info: ::std::option::Option<
        unsafe extern "C" fn(
            factory: *const spa_handle_factory,
            info: *mut *const spa_interface_info,
            index: *mut u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_handle_factory"][::std::mem::size_of::<spa_handle_factory>() - 48usize];
    ["Alignment of spa_handle_factory"][::std::mem::align_of::<spa_handle_factory>() - 8usize];
    ["Offset of field: spa_handle_factory::version"]
        [::std::mem::offset_of!(spa_handle_factory, version) - 0usize];
    ["Offset of field: spa_handle_factory::name"]
        [::std::mem::offset_of!(spa_handle_factory, name) - 8usize];
    ["Offset of field: spa_handle_factory::info"]
        [::std::mem::offset_of!(spa_handle_factory, info) - 16usize];
    ["Offset of field: spa_handle_factory::get_size"]
        [::std::mem::offset_of!(spa_handle_factory, get_size) - 24usize];
    ["Offset of field: spa_handle_factory::init"]
        [::std::mem::offset_of!(spa_handle_factory, init) - 32usize];
    ["Offset of field: spa_handle_factory::enum_interface_info"]
        [::std::mem::offset_of!(spa_handle_factory, enum_interface_info) - 40usize];
};
unsafe extern "C" {
    #[link_name = "spa_handle_factory_get_size_libspa_rs"]
    pub fn spa_handle_factory_get_size(
        object: *const spa_handle_factory,
        params: *const spa_dict,
    ) -> usize;
}
unsafe extern "C" {
    #[link_name = "spa_handle_factory_init_libspa_rs"]
    pub fn spa_handle_factory_init(
        object: *const spa_handle_factory,
        handle: *mut spa_handle,
        info: *const spa_dict,
        support: *const spa_support,
        n_support: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_handle_factory_enum_interface_info_libspa_rs"]
    pub fn spa_handle_factory_enum_interface_info(
        object: *const spa_handle_factory,
        info: *mut *const spa_interface_info,
        index: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[doc = " The function signature of the entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n         0 when there are no more factories\n         -EINVAL when factory is NULL"]
pub type spa_handle_factory_enum_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " The entry point in a plugin.\n\n \\param factory a location to hold the factory result\n \\param index index to keep track of the enumeration\n \\return 1 on success\n\t   0 when no more items are available\n\t   < 0 errno type error"]
    pub fn spa_handle_factory_enum(
        factory: *mut *const spa_handle_factory,
        index: *mut u32,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spa_thread {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_thread_utils {
    pub iface: spa_interface,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_thread_utils"][::std::mem::size_of::<spa_thread_utils>() - 32usize];
    ["Alignment of spa_thread_utils"][::std::mem::align_of::<spa_thread_utils>() - 8usize];
    ["Offset of field: spa_thread_utils::iface"]
        [::std::mem::offset_of!(spa_thread_utils, iface) - 0usize];
};
#[doc = " thread utils"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_thread_utils_methods {
    pub version: u32,
    #[doc = " create a new thread that runs \\a start with \\a arg"]
    pub create: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            start: ::std::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut ::std::os::raw::c_void,
                ) -> *mut ::std::os::raw::c_void,
            >,
            arg: *mut ::std::os::raw::c_void,
        ) -> *mut spa_thread,
    >,
    #[doc = " stop and join a thread"]
    pub join: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            retval: *mut *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get realtime priority range for threads created with \\a props"]
    pub get_rt_range: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
            min: *mut ::std::os::raw::c_int,
            max: *mut ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " acquire realtime priority, a priority of -1 refers to the priority\n configured in the realtime module"]
    pub acquire_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
            priority: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " drop realtime priority"]
    pub drop_rt: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            thread: *mut spa_thread,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_thread_utils_methods"]
        [::std::mem::size_of::<spa_thread_utils_methods>() - 48usize];
    ["Alignment of spa_thread_utils_methods"]
        [::std::mem::align_of::<spa_thread_utils_methods>() - 8usize];
    ["Offset of field: spa_thread_utils_methods::version"]
        [::std::mem::offset_of!(spa_thread_utils_methods, version) - 0usize];
    ["Offset of field: spa_thread_utils_methods::create"]
        [::std::mem::offset_of!(spa_thread_utils_methods, create) - 8usize];
    ["Offset of field: spa_thread_utils_methods::join"]
        [::std::mem::offset_of!(spa_thread_utils_methods, join) - 16usize];
    ["Offset of field: spa_thread_utils_methods::get_rt_range"]
        [::std::mem::offset_of!(spa_thread_utils_methods, get_rt_range) - 24usize];
    ["Offset of field: spa_thread_utils_methods::acquire_rt"]
        [::std::mem::offset_of!(spa_thread_utils_methods, acquire_rt) - 32usize];
    ["Offset of field: spa_thread_utils_methods::drop_rt"]
        [::std::mem::offset_of!(spa_thread_utils_methods, drop_rt) - 40usize];
};
unsafe extern "C" {
    #[doc = " \\copydoc spa_thread_utils_methods.create\n \\sa spa_thread_utils_methods.create"]
    #[link_name = "spa_thread_utils_create_libspa_rs"]
    pub fn spa_thread_utils_create(
        o: *mut spa_thread_utils,
        props: *const spa_dict,
        start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut spa_thread;
}
unsafe extern "C" {
    #[doc = " \\copydoc spa_thread_utils_methods.join\n \\sa spa_thread_utils_methods.join"]
    #[link_name = "spa_thread_utils_join_libspa_rs"]
    pub fn spa_thread_utils_join(
        o: *mut spa_thread_utils,
        thread: *mut spa_thread,
        retval: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc spa_thread_utils_methods.get_rt_range\n \\sa spa_thread_utils_methods.get_rt_range"]
    #[link_name = "spa_thread_utils_get_rt_range_libspa_rs"]
    pub fn spa_thread_utils_get_rt_range(
        o: *mut spa_thread_utils,
        props: *const spa_dict,
        min: *mut ::std::os::raw::c_int,
        max: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc spa_thread_utils_methods.acquire_rt\n \\sa spa_thread_utils_methods.acquire_rt"]
    #[link_name = "spa_thread_utils_acquire_rt_libspa_rs"]
    pub fn spa_thread_utils_acquire_rt(
        o: *mut spa_thread_utils,
        thread: *mut spa_thread,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\copydoc spa_thread_utils_methods.drop_rt\n \\sa spa_thread_utils_methods.drop_rt"]
    #[link_name = "spa_thread_utils_drop_rt_libspa_rs"]
    pub fn spa_thread_utils_drop_rt(
        o: *mut spa_thread_utils,
        thread: *mut spa_thread,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup spa_json\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_json {
    pub cur: *const ::std::os::raw::c_char,
    pub end: *const ::std::os::raw::c_char,
    pub parent: *mut spa_json,
    pub state: u32,
    pub depth: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_json"][::std::mem::size_of::<spa_json>() - 32usize];
    ["Alignment of spa_json"][::std::mem::align_of::<spa_json>() - 8usize];
    ["Offset of field: spa_json::cur"][::std::mem::offset_of!(spa_json, cur) - 0usize];
    ["Offset of field: spa_json::end"][::std::mem::offset_of!(spa_json, end) - 8usize];
    ["Offset of field: spa_json::parent"][::std::mem::offset_of!(spa_json, parent) - 16usize];
    ["Offset of field: spa_json::state"][::std::mem::offset_of!(spa_json, state) - 24usize];
    ["Offset of field: spa_json::depth"][::std::mem::offset_of!(spa_json, depth) - 28usize];
};
unsafe extern "C" {
    #[link_name = "spa_json_init_libspa_rs"]
    pub fn spa_json_init(iter: *mut spa_json, data: *const ::std::os::raw::c_char, size: usize);
}
unsafe extern "C" {
    #[link_name = "spa_json_enter_libspa_rs"]
    pub fn spa_json_enter(iter: *mut spa_json, sub: *mut spa_json);
}
unsafe extern "C" {
    #[link_name = "spa_json_save_libspa_rs"]
    pub fn spa_json_save(iter: *mut spa_json, save: *mut spa_json);
}
unsafe extern "C" {
    #[link_name = "spa_json_start_libspa_rs"]
    pub fn spa_json_start(
        iter: *mut spa_json,
        sub: *mut spa_json,
        pos: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    #[doc = " Get the next token. \\a value points to the token and the return value\n is the length. Returns -1 on parse error, 0 on end of input."]
    #[link_name = "spa_json_next_libspa_rs"]
    pub fn spa_json_next(
        iter: *mut spa_json,
        value: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return if there was a parse error, and its possible location.\n\n \\since 1.1.0"]
    #[link_name = "spa_json_get_error_libspa_rs"]
    pub fn spa_json_get_error(
        iter: *mut spa_json,
        start: *const ::std::os::raw::c_char,
        loc: *mut spa_error_location,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_container_libspa_rs"]
    pub fn spa_json_is_container(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_object_libspa_rs"]
    pub fn spa_json_is_object(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_array_libspa_rs"]
    pub fn spa_json_is_array(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_null_libspa_rs"]
    pub fn spa_json_is_null(val: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int)
    -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_parse_float_libspa_rs"]
    pub fn spa_json_parse_float(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        result: *mut f32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_float_libspa_rs"]
    pub fn spa_json_is_float(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_format_float_libspa_rs"]
    pub fn spa_json_format_float(
        str_: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        val: f32,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[link_name = "spa_json_parse_int_libspa_rs"]
    pub fn spa_json_parse_int(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_int_libspa_rs"]
    pub fn spa_json_is_int(val: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_true_libspa_rs"]
    pub fn spa_json_is_true(val: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int)
    -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_false_libspa_rs"]
    pub fn spa_json_is_false(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_bool_libspa_rs"]
    pub fn spa_json_is_bool(val: *const ::std::os::raw::c_char, len: ::std::os::raw::c_int)
    -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_parse_bool_libspa_rs"]
    pub fn spa_json_parse_bool(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        result: *mut bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_is_string_libspa_rs"]
    pub fn spa_json_is_string(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[link_name = "spa_json_parse_hex_libspa_rs"]
    pub fn spa_json_parse_hex(
        p: *const ::std::os::raw::c_char,
        num: ::std::os::raw::c_int,
        res: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_parse_stringn_libspa_rs"]
    pub fn spa_json_parse_stringn(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_parse_string_libspa_rs"]
    pub fn spa_json_parse_string(
        val: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        result: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_encode_string_libspa_rs"]
    pub fn spa_json_encode_string(
        str_: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_int,
        val: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " \\addtogroup spa_json\n \\{"]
    #[link_name = "spa_json_begin_libspa_rs"]
    pub fn spa_json_begin(
        iter: *mut spa_json,
        data: *const ::std::os::raw::c_char,
        size: usize,
        val: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_get_float_libspa_rs"]
    pub fn spa_json_get_float(iter: *mut spa_json, res: *mut f32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_get_int_libspa_rs"]
    pub fn spa_json_get_int(
        iter: *mut spa_json,
        res: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_get_bool_libspa_rs"]
    pub fn spa_json_get_bool(iter: *mut spa_json, res: *mut bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_get_string_libspa_rs"]
    pub fn spa_json_get_string(
        iter: *mut spa_json,
        res: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_enter_container_libspa_rs"]
    pub fn spa_json_enter_container(
        iter: *mut spa_json,
        sub: *mut spa_json,
        type_: ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_begin_container_libspa_rs"]
    pub fn spa_json_begin_container(
        iter: *mut spa_json,
        data: *const ::std::os::raw::c_char,
        size: usize,
        type_: ::std::os::raw::c_char,
        relax: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return length of container at current position, starting at \\a value.\n\n \\return Length of container including {} or [], or 0 on error."]
    #[link_name = "spa_json_container_len_libspa_rs"]
    pub fn spa_json_container_len(
        iter: *mut spa_json,
        value: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_enter_object_libspa_rs"]
    pub fn spa_json_enter_object(iter: *mut spa_json, sub: *mut spa_json) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_begin_object_relax_libspa_rs"]
    pub fn spa_json_begin_object_relax(
        iter: *mut spa_json,
        data: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_begin_object_libspa_rs"]
    pub fn spa_json_begin_object(
        iter: *mut spa_json,
        data: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_object_next_libspa_rs"]
    pub fn spa_json_object_next(
        iter: *mut spa_json,
        key: *mut ::std::os::raw::c_char,
        maxkeylen: ::std::os::raw::c_int,
        value: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_object_find_libspa_rs"]
    pub fn spa_json_object_find(
        iter: *mut spa_json,
        key: *const ::std::os::raw::c_char,
        value: *mut *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_str_object_find_libspa_rs"]
    pub fn spa_json_str_object_find(
        obj: *const ::std::os::raw::c_char,
        obj_len: usize,
        key: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        maxlen: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_enter_array_libspa_rs"]
    pub fn spa_json_enter_array(iter: *mut spa_json, sub: *mut spa_json) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_begin_array_relax_libspa_rs"]
    pub fn spa_json_begin_array_relax(
        iter: *mut spa_json,
        data: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_begin_array_libspa_rs"]
    pub fn spa_json_begin_array(
        iter: *mut spa_json,
        data: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_json_str_array_uint32_libspa_rs"]
    pub fn spa_json_str_array_uint32(
        arr: *const ::std::os::raw::c_char,
        arr_len: usize,
        values: *mut u32,
        max: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[link_name = "spa_strerror_libspa_rs"]
    pub fn spa_strerror(err: ::std::os::raw::c_int) -> *const ::std::os::raw::c_char;
}
#[doc = " \\addtogroup spa_ringbuffer\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct spa_ringbuffer {
    pub readindex: u32,
    pub writeindex: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of spa_ringbuffer"][::std::mem::size_of::<spa_ringbuffer>() - 8usize];
    ["Alignment of spa_ringbuffer"][::std::mem::align_of::<spa_ringbuffer>() - 4usize];
    ["Offset of field: spa_ringbuffer::readindex"]
        [::std::mem::offset_of!(spa_ringbuffer, readindex) - 0usize];
    ["Offset of field: spa_ringbuffer::writeindex"]
        [::std::mem::offset_of!(spa_ringbuffer, writeindex) - 4usize];
};
unsafe extern "C" {
    #[doc = " Initialize a spa_ringbuffer with \\a size.\n\n \\param rbuf a spa_ringbuffer"]
    #[link_name = "spa_ringbuffer_init_libspa_rs"]
    pub fn spa_ringbuffer_init(rbuf: *mut spa_ringbuffer);
}
unsafe extern "C" {
    #[doc = " Sets the pointers so that the ringbuffer contains \\a size bytes.\n\n \\param rbuf a spa_ringbuffer\n \\param size the target size of \\a rbuf"]
    #[link_name = "spa_ringbuffer_set_avail_libspa_rs"]
    pub fn spa_ringbuffer_set_avail(rbuf: *mut spa_ringbuffer, size: u32);
}
unsafe extern "C" {
    #[doc = " Get the read index and available bytes for reading.\n\n \\param rbuf a  spa_ringbuffer\n \\param index the value of readindex, should be taken modulo the size of the\n         ringbuffer memory to get the offset in the ringbuffer memory\n \\return number of available bytes to read. values < 0 mean\n         there was an underrun. values > rbuf->size means there\n         was an overrun."]
    #[link_name = "spa_ringbuffer_get_read_index_libspa_rs"]
    pub fn spa_ringbuffer_get_read_index(rbuf: *mut spa_ringbuffer, index: *mut u32) -> i32;
}
unsafe extern "C" {
    #[doc = " Read \\a len bytes from \\a rbuf starting \\a offset. \\a offset must be taken\n modulo \\a size and len should be smaller than \\a size.\n\n \\param rbuf a struct \\ref spa_ringbuffer\n \\param buffer memory to read from\n \\param size the size of \\a buffer\n \\param offset offset in \\a buffer to read from\n \\param data destination memory\n \\param len number of bytes to read"]
    #[link_name = "spa_ringbuffer_read_data_libspa_rs"]
    pub fn spa_ringbuffer_read_data(
        rbuf: *mut spa_ringbuffer,
        buffer: *const ::std::os::raw::c_void,
        size: u32,
        offset: u32,
        data: *mut ::std::os::raw::c_void,
        len: u32,
    );
}
unsafe extern "C" {
    #[doc = " Update the read pointer to \\a index.\n\n \\param rbuf a spa_ringbuffer\n \\param index new index"]
    #[link_name = "spa_ringbuffer_read_update_libspa_rs"]
    pub fn spa_ringbuffer_read_update(rbuf: *mut spa_ringbuffer, index: i32);
}
unsafe extern "C" {
    #[doc = " Get the write index and the number of bytes inside the ringbuffer.\n\n \\param rbuf a  spa_ringbuffer\n \\param index the value of writeindex, should be taken modulo the size of the\n         ringbuffer memory to get the offset in the ringbuffer memory\n \\return the fill level of \\a rbuf. values < 0 mean\n         there was an underrun. values > rbuf->size means there\n         was an overrun. Subtract from the buffer size to get\n         the number of bytes available for writing."]
    #[link_name = "spa_ringbuffer_get_write_index_libspa_rs"]
    pub fn spa_ringbuffer_get_write_index(rbuf: *mut spa_ringbuffer, index: *mut u32) -> i32;
}
unsafe extern "C" {
    #[doc = " Write \\a len bytes to \\a buffer starting \\a offset. \\a offset must be taken\n modulo \\a size and len should be smaller than \\a size.\n\n \\param rbuf a spa_ringbuffer\n \\param buffer memory to write to\n \\param size the size of \\a buffer\n \\param offset offset in \\a buffer to write to\n \\param data source memory\n \\param len number of bytes to write"]
    #[link_name = "spa_ringbuffer_write_data_libspa_rs"]
    pub fn spa_ringbuffer_write_data(
        rbuf: *mut spa_ringbuffer,
        buffer: *mut ::std::os::raw::c_void,
        size: u32,
        offset: u32,
        data: *const ::std::os::raw::c_void,
        len: u32,
    );
}
unsafe extern "C" {
    #[doc = " Update the write pointer to \\a index\n\n \\param rbuf a spa_ringbuffer\n \\param index new index"]
    #[link_name = "spa_ringbuffer_write_update_libspa_rs"]
    pub fn spa_ringbuffer_write_update(rbuf: *mut spa_ringbuffer, index: i32);
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
