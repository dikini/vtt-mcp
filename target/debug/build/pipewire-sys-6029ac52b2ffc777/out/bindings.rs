/* automatically generated by rust-bindgen 0.72.1 */

use spa_sys::*;

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    fn extract_bit(byte: u8, index: usize) -> bool {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        Self::extract_bit(byte, index)
    }
    #[inline]
    pub unsafe fn raw_get_bit(this: *const Self, index: usize) -> bool {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            *(core::ptr::addr_of!((*this).storage) as *const u8).offset(byte_index as isize)
        };
        Self::extract_bit(byte, index)
    }
    #[inline]
    fn change_bit(byte: u8, index: usize, val: bool) -> u8 {
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val { byte | mask } else { byte & !mask }
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        *byte = Self::change_bit(*byte, index, val);
    }
    #[inline]
    pub unsafe fn raw_set_bit(this: *mut Self, index: usize, val: bool) {
        debug_assert!(index / 8 < core::mem::size_of::<Storage>());
        let byte_index = index / 8;
        let byte = unsafe {
            (core::ptr::addr_of_mut!((*this).storage) as *mut u8).offset(byte_index as isize)
        };
        unsafe { *byte = Self::change_bit(*byte, index, val) };
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub unsafe fn raw_get(this: *const Self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if unsafe { Self::raw_get_bit(this, i + bit_offset) } {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
    #[inline]
    pub unsafe fn raw_set(this: *mut Self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < core::mem::size_of::<Storage>());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= core::mem::size_of::<Storage>());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            unsafe { Self::raw_set_bit(this, index + bit_offset, val_bit_is_set) };
        }
    }
}
pub const PW_TYPE_INFO_BASE: &[u8; 10] = b"PipeWire:\0";
pub const PW_TYPE_INFO_Object: &[u8; 16] = b"PipeWire:Object\0";
pub const PW_TYPE_INFO_OBJECT_BASE: &[u8; 17] = b"PipeWire:Object:\0";
pub const PW_TYPE_INFO_Interface: &[u8; 19] = b"PipeWire:Interface\0";
pub const PW_TYPE_INFO_INTERFACE_BASE: &[u8; 20] = b"PipeWire:Interface:\0";
pub const PW_TYPE_INTERFACE_Core: &[u8; 24] = b"PipeWire:Interface:Core\0";
pub const PW_TYPE_INTERFACE_Registry: &[u8; 28] = b"PipeWire:Interface:Registry\0";
pub const PW_VERSION_CORE: u32 = 4;
pub const PW_VERSION_REGISTRY: u32 = 3;
pub const PW_DEFAULT_REMOTE: &[u8; 11] = b"pipewire-0\0";
pub const PW_ID_CORE: u32 = 0;
pub const PW_CORE_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_CORE_CHANGE_MASK_ALL: u32 = 1;
pub const PW_PROPERTIES_FLAG_NL: u32 = 1;
pub const PW_PROPERTIES_FLAG_RECURSE: u32 = 2;
pub const PW_PROPERTIES_FLAG_ENCLOSE: u32 = 4;
pub const PW_PROPERTIES_FLAG_ARRAY: u32 = 8;
pub const PW_PROPERTIES_FLAG_COLORS: u32 = 16;
pub const PW_CORE_EVENT_INFO: u32 = 0;
pub const PW_CORE_EVENT_DONE: u32 = 1;
pub const PW_CORE_EVENT_PING: u32 = 2;
pub const PW_CORE_EVENT_ERROR: u32 = 3;
pub const PW_CORE_EVENT_REMOVE_ID: u32 = 4;
pub const PW_CORE_EVENT_BOUND_ID: u32 = 5;
pub const PW_CORE_EVENT_ADD_MEM: u32 = 6;
pub const PW_CORE_EVENT_REMOVE_MEM: u32 = 7;
pub const PW_CORE_EVENT_BOUND_PROPS: u32 = 8;
pub const PW_CORE_EVENT_NUM: u32 = 9;
pub const PW_VERSION_CORE_EVENTS: u32 = 1;
pub const PW_CORE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CORE_METHOD_HELLO: u32 = 1;
pub const PW_CORE_METHOD_SYNC: u32 = 2;
pub const PW_CORE_METHOD_PONG: u32 = 3;
pub const PW_CORE_METHOD_ERROR: u32 = 4;
pub const PW_CORE_METHOD_GET_REGISTRY: u32 = 5;
pub const PW_CORE_METHOD_CREATE_OBJECT: u32 = 6;
pub const PW_CORE_METHOD_DESTROY: u32 = 7;
pub const PW_CORE_METHOD_NUM: u32 = 8;
pub const PW_VERSION_CORE_METHODS: u32 = 0;
pub const PW_REGISTRY_EVENT_GLOBAL: u32 = 0;
pub const PW_REGISTRY_EVENT_GLOBAL_REMOVE: u32 = 1;
pub const PW_REGISTRY_EVENT_NUM: u32 = 2;
pub const PW_VERSION_REGISTRY_EVENTS: u32 = 0;
pub const PW_REGISTRY_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_REGISTRY_METHOD_BIND: u32 = 1;
pub const PW_REGISTRY_METHOD_DESTROY: u32 = 2;
pub const PW_REGISTRY_METHOD_NUM: u32 = 3;
pub const PW_VERSION_REGISTRY_METHODS: u32 = 0;
pub const PW_VERSION_CONTEXT_EVENTS: u32 = 1;
pub const PW_TYPE_INFO_Protocol: &[u8; 18] = b"PipeWire:Protocol\0";
pub const PW_TYPE_INFO_PROTOCOL_BASE: &[u8; 19] = b"PipeWire:Protocol:\0";
pub const PW_PROTOCOL_MARSHAL_FLAG_IMPL: u32 = 1;
pub const PW_VERSION_PROTOCOL_IMPLEMENTATION: u32 = 1;
pub const PW_VERSION_PROTOCOL_EVENTS: u32 = 0;
pub const PW_VERSION_PROXY_EVENTS: u32 = 1;
pub const PW_PERM_R: u32 = 256;
pub const PW_PERM_W: u32 = 128;
pub const PW_PERM_X: u32 = 64;
pub const PW_PERM_M: u32 = 8;
pub const PW_PERM_L: u32 = 16;
pub const PW_PERM_RW: u32 = 384;
pub const PW_PERM_RWX: u32 = 448;
pub const PW_PERM_RWXM: u32 = 456;
pub const PW_PERM_RWXML: u32 = 472;
pub const PW_PERM_ALL: u32 = 456;
pub const PW_PERMISSION_FORMAT: &[u8; 11] = b"%c%c%c%c%c\0";
pub const PW_TYPE_INTERFACE_Client: &[u8; 26] = b"PipeWire:Interface:Client\0";
pub const PW_CLIENT_PERM_MASK: u32 = 456;
pub const PW_VERSION_CLIENT: u32 = 3;
pub const PW_ID_CLIENT: u32 = 1;
pub const PW_CLIENT_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_CLIENT_CHANGE_MASK_ALL: u32 = 1;
pub const PW_CLIENT_EVENT_INFO: u32 = 0;
pub const PW_CLIENT_EVENT_PERMISSIONS: u32 = 1;
pub const PW_CLIENT_EVENT_NUM: u32 = 2;
pub const PW_VERSION_CLIENT_EVENTS: u32 = 0;
pub const PW_CLIENT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_METHOD_ERROR: u32 = 1;
pub const PW_CLIENT_METHOD_UPDATE_PROPERTIES: u32 = 2;
pub const PW_CLIENT_METHOD_GET_PERMISSIONS: u32 = 3;
pub const PW_CLIENT_METHOD_UPDATE_PERMISSIONS: u32 = 4;
pub const PW_CLIENT_METHOD_NUM: u32 = 5;
pub const PW_VERSION_CLIENT_METHODS: u32 = 0;
pub const PW_TYPE_INTERFACE_Device: &[u8; 26] = b"PipeWire:Interface:Device\0";
pub const PW_DEVICE_PERM_MASK: u32 = 456;
pub const PW_VERSION_DEVICE: u32 = 3;
pub const PW_DEVICE_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_DEVICE_CHANGE_MASK_PARAMS: u32 = 2;
pub const PW_DEVICE_CHANGE_MASK_ALL: u32 = 3;
pub const PW_DEVICE_EVENT_INFO: u32 = 0;
pub const PW_DEVICE_EVENT_PARAM: u32 = 1;
pub const PW_DEVICE_EVENT_NUM: u32 = 2;
pub const PW_VERSION_DEVICE_EVENTS: u32 = 0;
pub const PW_DEVICE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_DEVICE_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_DEVICE_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_DEVICE_METHOD_SET_PARAM: u32 = 3;
pub const PW_DEVICE_METHOD_NUM: u32 = 4;
pub const PW_VERSION_DEVICE_METHODS: u32 = 0;
pub const PW_VERSION_MEMPOOL_EVENTS: u32 = 0;
pub const PW_BUFFERS_FLAG_NONE: u32 = 0;
pub const PW_BUFFERS_FLAG_NO_MEM: u32 = 1;
pub const PW_BUFFERS_FLAG_SHARED: u32 = 2;
pub const PW_BUFFERS_FLAG_DYNAMIC: u32 = 4;
pub const PW_BUFFERS_FLAG_SHARED_MEM: u32 = 8;
pub const PW_BUFFERS_FLAG_IN_PRIORITY: u32 = 16;
pub const PW_BUFFERS_FLAG_ASYNC: u32 = 32;
pub const PW_TYPE_INTERFACE_Factory: &[u8; 27] = b"PipeWire:Interface:Factory\0";
pub const PW_FACTORY_PERM_MASK: u32 = 264;
pub const PW_VERSION_FACTORY: u32 = 3;
pub const PW_FACTORY_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_FACTORY_CHANGE_MASK_ALL: u32 = 1;
pub const PW_FACTORY_EVENT_INFO: u32 = 0;
pub const PW_FACTORY_EVENT_NUM: u32 = 1;
pub const PW_VERSION_FACTORY_EVENTS: u32 = 0;
pub const PW_FACTORY_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_FACTORY_METHOD_NUM: u32 = 1;
pub const PW_VERSION_FACTORY_METHODS: u32 = 0;
pub const PW_KEY_PROTOCOL: &[u8; 18] = b"pipewire.protocol\0";
pub const PW_KEY_ACCESS: &[u8; 16] = b"pipewire.access\0";
pub const PW_KEY_CLIENT_ACCESS: &[u8; 23] = b"pipewire.client.access\0";
pub const PW_KEY_SEC_PID: &[u8; 17] = b"pipewire.sec.pid\0";
pub const PW_KEY_SEC_UID: &[u8; 17] = b"pipewire.sec.uid\0";
pub const PW_KEY_SEC_GID: &[u8; 17] = b"pipewire.sec.gid\0";
pub const PW_KEY_SEC_LABEL: &[u8; 19] = b"pipewire.sec.label\0";
pub const PW_KEY_SEC_SOCKET: &[u8; 20] = b"pipewire.sec.socket\0";
pub const PW_KEY_SEC_ENGINE: &[u8; 20] = b"pipewire.sec.engine\0";
pub const PW_KEY_SEC_APP_ID: &[u8; 20] = b"pipewire.sec.app-id\0";
pub const PW_KEY_SEC_INSTANCE_ID: &[u8; 25] = b"pipewire.sec.instance-id\0";
pub const PW_KEY_LIBRARY_NAME_SYSTEM: &[u8; 20] = b"library.name.system\0";
pub const PW_KEY_LIBRARY_NAME_LOOP: &[u8; 18] = b"library.name.loop\0";
pub const PW_KEY_LIBRARY_NAME_DBUS: &[u8; 18] = b"library.name.dbus\0";
pub const PW_KEY_OBJECT_PATH: &[u8; 12] = b"object.path\0";
pub const PW_KEY_OBJECT_ID: &[u8; 10] = b"object.id\0";
pub const PW_KEY_OBJECT_SERIAL: &[u8; 14] = b"object.serial\0";
pub const PW_KEY_OBJECT_LINGER: &[u8; 14] = b"object.linger\0";
pub const PW_KEY_OBJECT_REGISTER: &[u8; 16] = b"object.register\0";
pub const PW_KEY_OBJECT_EXPORT: &[u8; 14] = b"object.export\0";
pub const PW_KEY_CONFIG_PREFIX: &[u8; 14] = b"config.prefix\0";
pub const PW_KEY_CONFIG_NAME: &[u8; 12] = b"config.name\0";
pub const PW_KEY_CONFIG_OVERRIDE_PREFIX: &[u8; 23] = b"config.override.prefix\0";
pub const PW_KEY_CONFIG_OVERRIDE_NAME: &[u8; 21] = b"config.override.name\0";
pub const PW_KEY_LOOP_NAME: &[u8; 10] = b"loop.name\0";
pub const PW_KEY_LOOP_CLASS: &[u8; 11] = b"loop.class\0";
pub const PW_KEY_LOOP_RT_PRIO: &[u8; 13] = b"loop.rt-prio\0";
pub const PW_KEY_LOOP_CANCEL: &[u8; 12] = b"loop.cancel\0";
pub const PW_KEY_CONTEXT_PROFILE_MODULES: &[u8; 24] = b"context.profile.modules\0";
pub const PW_KEY_USER_NAME: &[u8; 18] = b"context.user-name\0";
pub const PW_KEY_HOST_NAME: &[u8; 18] = b"context.host-name\0";
pub const PW_KEY_CORE_NAME: &[u8; 10] = b"core.name\0";
pub const PW_KEY_CORE_VERSION: &[u8; 13] = b"core.version\0";
pub const PW_KEY_CORE_DAEMON: &[u8; 12] = b"core.daemon\0";
pub const PW_KEY_CORE_ID: &[u8; 8] = b"core.id\0";
pub const PW_KEY_CORE_MONITORS: &[u8; 14] = b"core.monitors\0";
pub const PW_KEY_CPU_MAX_ALIGN: &[u8; 14] = b"cpu.max-align\0";
pub const PW_KEY_CPU_CORES: &[u8; 10] = b"cpu.cores\0";
pub const PW_KEY_PRIORITY_SESSION: &[u8; 17] = b"priority.session\0";
pub const PW_KEY_PRIORITY_DRIVER: &[u8; 16] = b"priority.driver\0";
pub const PW_KEY_REMOTE_NAME: &[u8; 12] = b"remote.name\0";
pub const PW_KEY_REMOTE_INTENTION: &[u8; 17] = b"remote.intention\0";
pub const PW_KEY_APP_NAME: &[u8; 17] = b"application.name\0";
pub const PW_KEY_APP_ID: &[u8; 15] = b"application.id\0";
pub const PW_KEY_APP_VERSION: &[u8; 20] = b"application.version\0";
pub const PW_KEY_APP_ICON: &[u8; 17] = b"application.icon\0";
pub const PW_KEY_APP_ICON_NAME: &[u8; 22] = b"application.icon-name\0";
pub const PW_KEY_APP_LANGUAGE: &[u8; 21] = b"application.language\0";
pub const PW_KEY_APP_PROCESS_ID: &[u8; 23] = b"application.process.id\0";
pub const PW_KEY_APP_PROCESS_BINARY: &[u8; 27] = b"application.process.binary\0";
pub const PW_KEY_APP_PROCESS_USER: &[u8; 25] = b"application.process.user\0";
pub const PW_KEY_APP_PROCESS_HOST: &[u8; 25] = b"application.process.host\0";
pub const PW_KEY_APP_PROCESS_MACHINE_ID: &[u8; 31] = b"application.process.machine-id\0";
pub const PW_KEY_APP_PROCESS_SESSION_ID: &[u8; 31] = b"application.process.session-id\0";
pub const PW_KEY_WINDOW_X11_DISPLAY: &[u8; 19] = b"window.x11.display\0";
pub const PW_KEY_CLIENT_ID: &[u8; 10] = b"client.id\0";
pub const PW_KEY_CLIENT_NAME: &[u8; 12] = b"client.name\0";
pub const PW_KEY_CLIENT_API: &[u8; 11] = b"client.api\0";
pub const PW_KEY_NODE_ID: &[u8; 8] = b"node.id\0";
pub const PW_KEY_NODE_NAME: &[u8; 10] = b"node.name\0";
pub const PW_KEY_NODE_NICK: &[u8; 10] = b"node.nick\0";
pub const PW_KEY_NODE_DESCRIPTION: &[u8; 17] = b"node.description\0";
pub const PW_KEY_NODE_PLUGGED: &[u8; 13] = b"node.plugged\0";
pub const PW_KEY_NODE_SESSION: &[u8; 13] = b"node.session\0";
pub const PW_KEY_NODE_GROUP: &[u8; 11] = b"node.group\0";
pub const PW_KEY_NODE_SYNC_GROUP: &[u8; 16] = b"node.sync-group\0";
pub const PW_KEY_NODE_SYNC: &[u8; 10] = b"node.sync\0";
pub const PW_KEY_NODE_TRANSPORT: &[u8; 15] = b"node.transport\0";
pub const PW_KEY_NODE_EXCLUSIVE: &[u8; 15] = b"node.exclusive\0";
pub const PW_KEY_NODE_AUTOCONNECT: &[u8; 17] = b"node.autoconnect\0";
pub const PW_KEY_NODE_LATENCY: &[u8; 13] = b"node.latency\0";
pub const PW_KEY_NODE_MAX_LATENCY: &[u8; 17] = b"node.max-latency\0";
pub const PW_KEY_NODE_LOCK_QUANTUM: &[u8; 18] = b"node.lock-quantum\0";
pub const PW_KEY_NODE_FORCE_QUANTUM: &[u8; 19] = b"node.force-quantum\0";
pub const PW_KEY_NODE_RATE: &[u8; 10] = b"node.rate\0";
pub const PW_KEY_NODE_LOCK_RATE: &[u8; 15] = b"node.lock-rate\0";
pub const PW_KEY_NODE_FORCE_RATE: &[u8; 16] = b"node.force-rate\0";
pub const PW_KEY_NODE_DONT_RECONNECT: &[u8; 20] = b"node.dont-reconnect\0";
pub const PW_KEY_NODE_ALWAYS_PROCESS: &[u8; 20] = b"node.always-process\0";
pub const PW_KEY_NODE_WANT_DRIVER: &[u8; 17] = b"node.want-driver\0";
pub const PW_KEY_NODE_PAUSE_ON_IDLE: &[u8; 19] = b"node.pause-on-idle\0";
pub const PW_KEY_NODE_SUSPEND_ON_IDLE: &[u8; 21] = b"node.suspend-on-idle\0";
pub const PW_KEY_NODE_CACHE_PARAMS: &[u8; 18] = b"node.cache-params\0";
pub const PW_KEY_NODE_TRANSPORT_SYNC: &[u8; 20] = b"node.transport.sync\0";
pub const PW_KEY_NODE_DRIVER: &[u8; 12] = b"node.driver\0";
pub const PW_KEY_NODE_SUPPORTS_LAZY: &[u8; 19] = b"node.supports-lazy\0";
pub const PW_KEY_NODE_SUPPORTS_REQUEST: &[u8; 22] = b"node.supports-request\0";
pub const PW_KEY_NODE_DRIVER_ID: &[u8; 15] = b"node.driver-id\0";
pub const PW_KEY_NODE_ASYNC: &[u8; 11] = b"node.async\0";
pub const PW_KEY_NODE_LOOP_NAME: &[u8; 15] = b"node.loop.name\0";
pub const PW_KEY_NODE_LOOP_CLASS: &[u8; 16] = b"node.loop.class\0";
pub const PW_KEY_NODE_STREAM: &[u8; 12] = b"node.stream\0";
pub const PW_KEY_NODE_VIRTUAL: &[u8; 13] = b"node.virtual\0";
pub const PW_KEY_NODE_PASSIVE: &[u8; 13] = b"node.passive\0";
pub const PW_KEY_NODE_LINK_GROUP: &[u8; 16] = b"node.link-group\0";
pub const PW_KEY_NODE_NETWORK: &[u8; 13] = b"node.network\0";
pub const PW_KEY_NODE_TRIGGER: &[u8; 13] = b"node.trigger\0";
pub const PW_KEY_NODE_CHANNELNAMES: &[u8; 19] = b"node.channel-names\0";
pub const PW_KEY_NODE_DEVICE_PORT_NAME_PREFIX: &[u8; 29] = b"node.device-port-name-prefix\0";
pub const PW_KEY_PORT_ID: &[u8; 8] = b"port.id\0";
pub const PW_KEY_PORT_NAME: &[u8; 10] = b"port.name\0";
pub const PW_KEY_PORT_DIRECTION: &[u8; 15] = b"port.direction\0";
pub const PW_KEY_PORT_ALIAS: &[u8; 11] = b"port.alias\0";
pub const PW_KEY_PORT_PHYSICAL: &[u8; 14] = b"port.physical\0";
pub const PW_KEY_PORT_TERMINAL: &[u8; 14] = b"port.terminal\0";
pub const PW_KEY_PORT_CONTROL: &[u8; 13] = b"port.control\0";
pub const PW_KEY_PORT_MONITOR: &[u8; 13] = b"port.monitor\0";
pub const PW_KEY_PORT_CACHE_PARAMS: &[u8; 18] = b"port.cache-params\0";
pub const PW_KEY_PORT_EXTRA: &[u8; 11] = b"port.extra\0";
pub const PW_KEY_PORT_PASSIVE: &[u8; 13] = b"port.passive\0";
pub const PW_KEY_PORT_IGNORE_LATENCY: &[u8; 20] = b"port.ignore-latency\0";
pub const PW_KEY_PORT_GROUP: &[u8; 11] = b"port.group\0";
pub const PW_KEY_LINK_ID: &[u8; 8] = b"link.id\0";
pub const PW_KEY_LINK_INPUT_NODE: &[u8; 16] = b"link.input.node\0";
pub const PW_KEY_LINK_INPUT_PORT: &[u8; 16] = b"link.input.port\0";
pub const PW_KEY_LINK_OUTPUT_NODE: &[u8; 17] = b"link.output.node\0";
pub const PW_KEY_LINK_OUTPUT_PORT: &[u8; 17] = b"link.output.port\0";
pub const PW_KEY_LINK_PASSIVE: &[u8; 13] = b"link.passive\0";
pub const PW_KEY_LINK_FEEDBACK: &[u8; 14] = b"link.feedback\0";
pub const PW_KEY_LINK_ASYNC: &[u8; 11] = b"link.async\0";
pub const PW_KEY_DEVICE_ID: &[u8; 10] = b"device.id\0";
pub const PW_KEY_DEVICE_NAME: &[u8; 12] = b"device.name\0";
pub const PW_KEY_DEVICE_PLUGGED: &[u8; 15] = b"device.plugged\0";
pub const PW_KEY_DEVICE_NICK: &[u8; 12] = b"device.nick\0";
pub const PW_KEY_DEVICE_STRING: &[u8; 14] = b"device.string\0";
pub const PW_KEY_DEVICE_API: &[u8; 11] = b"device.api\0";
pub const PW_KEY_DEVICE_DESCRIPTION: &[u8; 19] = b"device.description\0";
pub const PW_KEY_DEVICE_BUS_PATH: &[u8; 16] = b"device.bus-path\0";
pub const PW_KEY_DEVICE_SERIAL: &[u8; 14] = b"device.serial\0";
pub const PW_KEY_DEVICE_VENDOR_ID: &[u8; 17] = b"device.vendor.id\0";
pub const PW_KEY_DEVICE_VENDOR_NAME: &[u8; 19] = b"device.vendor.name\0";
pub const PW_KEY_DEVICE_PRODUCT_ID: &[u8; 18] = b"device.product.id\0";
pub const PW_KEY_DEVICE_PRODUCT_NAME: &[u8; 20] = b"device.product.name\0";
pub const PW_KEY_DEVICE_CLASS: &[u8; 13] = b"device.class\0";
pub const PW_KEY_DEVICE_FORM_FACTOR: &[u8; 19] = b"device.form-factor\0";
pub const PW_KEY_DEVICE_BUS: &[u8; 11] = b"device.bus\0";
pub const PW_KEY_DEVICE_SUBSYSTEM: &[u8; 17] = b"device.subsystem\0";
pub const PW_KEY_DEVICE_SYSFS_PATH: &[u8; 18] = b"device.sysfs.path\0";
pub const PW_KEY_DEVICE_ICON: &[u8; 12] = b"device.icon\0";
pub const PW_KEY_DEVICE_ICON_NAME: &[u8; 17] = b"device.icon-name\0";
pub const PW_KEY_DEVICE_INTENDED_ROLES: &[u8; 22] = b"device.intended-roles\0";
pub const PW_KEY_DEVICE_CACHE_PARAMS: &[u8; 20] = b"device.cache-params\0";
pub const PW_KEY_MODULE_ID: &[u8; 10] = b"module.id\0";
pub const PW_KEY_MODULE_NAME: &[u8; 12] = b"module.name\0";
pub const PW_KEY_MODULE_AUTHOR: &[u8; 14] = b"module.author\0";
pub const PW_KEY_MODULE_DESCRIPTION: &[u8; 19] = b"module.description\0";
pub const PW_KEY_MODULE_USAGE: &[u8; 13] = b"module.usage\0";
pub const PW_KEY_MODULE_VERSION: &[u8; 15] = b"module.version\0";
pub const PW_KEY_MODULE_DEPRECATED: &[u8; 18] = b"module.deprecated\0";
pub const PW_KEY_FACTORY_ID: &[u8; 11] = b"factory.id\0";
pub const PW_KEY_FACTORY_NAME: &[u8; 13] = b"factory.name\0";
pub const PW_KEY_FACTORY_USAGE: &[u8; 14] = b"factory.usage\0";
pub const PW_KEY_FACTORY_TYPE_NAME: &[u8; 18] = b"factory.type.name\0";
pub const PW_KEY_FACTORY_TYPE_VERSION: &[u8; 21] = b"factory.type.version\0";
pub const PW_KEY_STREAM_IS_LIVE: &[u8; 15] = b"stream.is-live\0";
pub const PW_KEY_STREAM_LATENCY_MIN: &[u8; 19] = b"stream.latency.min\0";
pub const PW_KEY_STREAM_LATENCY_MAX: &[u8; 19] = b"stream.latency.max\0";
pub const PW_KEY_STREAM_MONITOR: &[u8; 15] = b"stream.monitor\0";
pub const PW_KEY_STREAM_DONT_REMIX: &[u8; 18] = b"stream.dont-remix\0";
pub const PW_KEY_STREAM_CAPTURE_SINK: &[u8; 20] = b"stream.capture.sink\0";
pub const PW_KEY_MEDIA_TYPE: &[u8; 11] = b"media.type\0";
pub const PW_KEY_MEDIA_CATEGORY: &[u8; 15] = b"media.category\0";
pub const PW_KEY_MEDIA_ROLE: &[u8; 11] = b"media.role\0";
pub const PW_KEY_MEDIA_CLASS: &[u8; 12] = b"media.class\0";
pub const PW_KEY_MEDIA_NAME: &[u8; 11] = b"media.name\0";
pub const PW_KEY_MEDIA_TITLE: &[u8; 12] = b"media.title\0";
pub const PW_KEY_MEDIA_ARTIST: &[u8; 13] = b"media.artist\0";
pub const PW_KEY_MEDIA_ALBUM: &[u8; 12] = b"media.album\0";
pub const PW_KEY_MEDIA_COPYRIGHT: &[u8; 16] = b"media.copyright\0";
pub const PW_KEY_MEDIA_SOFTWARE: &[u8; 15] = b"media.software\0";
pub const PW_KEY_MEDIA_LANGUAGE: &[u8; 15] = b"media.language\0";
pub const PW_KEY_MEDIA_FILENAME: &[u8; 15] = b"media.filename\0";
pub const PW_KEY_MEDIA_ICON: &[u8; 11] = b"media.icon\0";
pub const PW_KEY_MEDIA_ICON_NAME: &[u8; 16] = b"media.icon-name\0";
pub const PW_KEY_MEDIA_COMMENT: &[u8; 14] = b"media.comment\0";
pub const PW_KEY_MEDIA_DATE: &[u8; 11] = b"media.date\0";
pub const PW_KEY_MEDIA_FORMAT: &[u8; 13] = b"media.format\0";
pub const PW_KEY_FORMAT_DSP: &[u8; 11] = b"format.dsp\0";
pub const PW_KEY_AUDIO_CHANNEL: &[u8; 14] = b"audio.channel\0";
pub const PW_KEY_AUDIO_RATE: &[u8; 11] = b"audio.rate\0";
pub const PW_KEY_AUDIO_CHANNELS: &[u8; 15] = b"audio.channels\0";
pub const PW_KEY_AUDIO_FORMAT: &[u8; 13] = b"audio.format\0";
pub const PW_KEY_AUDIO_ALLOWED_RATES: &[u8; 20] = b"audio.allowed-rates\0";
pub const PW_KEY_VIDEO_RATE: &[u8; 16] = b"video.framerate\0";
pub const PW_KEY_VIDEO_FORMAT: &[u8; 13] = b"video.format\0";
pub const PW_KEY_VIDEO_SIZE: &[u8; 11] = b"video.size\0";
pub const PW_KEY_TARGET_OBJECT: &[u8; 14] = b"target.object\0";
pub const PW_TYPE_INTERFACE_Link: &[u8; 24] = b"PipeWire:Interface:Link\0";
pub const PW_LINK_PERM_MASK: u32 = 320;
pub const PW_VERSION_LINK: u32 = 3;
pub const PW_LINK_CHANGE_MASK_STATE: u32 = 1;
pub const PW_LINK_CHANGE_MASK_FORMAT: u32 = 2;
pub const PW_LINK_CHANGE_MASK_PROPS: u32 = 4;
pub const PW_LINK_CHANGE_MASK_ALL: u32 = 7;
pub const PW_LINK_EVENT_INFO: u32 = 0;
pub const PW_LINK_EVENT_NUM: u32 = 1;
pub const PW_VERSION_LINK_EVENTS: u32 = 0;
pub const PW_LINK_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_LINK_METHOD_NUM: u32 = 1;
pub const PW_VERSION_LINK_METHODS: u32 = 0;
pub const PW_VERSION_MAIN_LOOP_EVENTS: u32 = 0;
pub const PW_TYPE_INTERFACE_Module: &[u8; 26] = b"PipeWire:Interface:Module\0";
pub const PW_MODULE_PERM_MASK: u32 = 264;
pub const PW_VERSION_MODULE: u32 = 3;
pub const PW_MODULE_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_MODULE_CHANGE_MASK_ALL: u32 = 1;
pub const PW_MODULE_EVENT_INFO: u32 = 0;
pub const PW_MODULE_EVENT_NUM: u32 = 1;
pub const PW_VERSION_MODULE_EVENTS: u32 = 0;
pub const PW_MODULE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_MODULE_METHOD_NUM: u32 = 1;
pub const PW_VERSION_MODULE_METHODS: u32 = 0;
pub const PW_TYPE_INTERFACE_Node: &[u8; 24] = b"PipeWire:Interface:Node\0";
pub const PW_NODE_PERM_MASK: u32 = 472;
pub const PW_VERSION_NODE: u32 = 3;
pub const PW_NODE_CHANGE_MASK_INPUT_PORTS: u32 = 1;
pub const PW_NODE_CHANGE_MASK_OUTPUT_PORTS: u32 = 2;
pub const PW_NODE_CHANGE_MASK_STATE: u32 = 4;
pub const PW_NODE_CHANGE_MASK_PROPS: u32 = 8;
pub const PW_NODE_CHANGE_MASK_PARAMS: u32 = 16;
pub const PW_NODE_CHANGE_MASK_ALL: u32 = 31;
pub const PW_NODE_EVENT_INFO: u32 = 0;
pub const PW_NODE_EVENT_PARAM: u32 = 1;
pub const PW_NODE_EVENT_NUM: u32 = 2;
pub const PW_VERSION_NODE_EVENTS: u32 = 0;
pub const PW_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_NODE_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_NODE_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_NODE_METHOD_SET_PARAM: u32 = 3;
pub const PW_NODE_METHOD_SEND_COMMAND: u32 = 4;
pub const PW_NODE_METHOD_NUM: u32 = 5;
pub const PW_VERSION_NODE_METHODS: u32 = 0;
pub const PW_TYPE_INTERFACE_Port: &[u8; 24] = b"PipeWire:Interface:Port\0";
pub const PW_PORT_PERM_MASK: u32 = 328;
pub const PW_VERSION_PORT: u32 = 3;
pub const PW_PORT_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_PORT_CHANGE_MASK_PARAMS: u32 = 2;
pub const PW_PORT_CHANGE_MASK_ALL: u32 = 3;
pub const PW_PORT_EVENT_INFO: u32 = 0;
pub const PW_PORT_EVENT_PARAM: u32 = 1;
pub const PW_PORT_EVENT_NUM: u32 = 2;
pub const PW_VERSION_PORT_EVENTS: u32 = 0;
pub const PW_PORT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_PORT_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_PORT_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_PORT_METHOD_NUM: u32 = 3;
pub const PW_VERSION_PORT_METHODS: u32 = 0;
pub const PW_VERSION_STREAM_EVENTS: u32 = 2;
pub const PW_VERSION_FILTER_EVENTS: u32 = 1;
pub const PW_VERSION_THREAD_LOOP_EVENTS: u32 = 0;
pub const PW_VERSION_DATA_LOOP_EVENTS: u32 = 0;
pub const PW_API_VERSION: &[u8; 4] = b"0.3\0";
pub const PW_MAJOR: u32 = 1;
pub const PW_MINOR: u32 = 4;
pub const PW_MICRO: u32 = 7;
pub const PW_TYPE_INTERFACE_ClientNode: &[u8; 30] = b"PipeWire:Interface:ClientNode\0";
pub const PW_VERSION_CLIENT_NODE: u32 = 6;
pub const PW_CLIENT_NODE_EVENT_TRANSPORT: u32 = 0;
pub const PW_CLIENT_NODE_EVENT_SET_PARAM: u32 = 1;
pub const PW_CLIENT_NODE_EVENT_SET_IO: u32 = 2;
pub const PW_CLIENT_NODE_EVENT_EVENT: u32 = 3;
pub const PW_CLIENT_NODE_EVENT_COMMAND: u32 = 4;
pub const PW_CLIENT_NODE_EVENT_ADD_PORT: u32 = 5;
pub const PW_CLIENT_NODE_EVENT_REMOVE_PORT: u32 = 6;
pub const PW_CLIENT_NODE_EVENT_PORT_SET_PARAM: u32 = 7;
pub const PW_CLIENT_NODE_EVENT_PORT_USE_BUFFERS: u32 = 8;
pub const PW_CLIENT_NODE_EVENT_PORT_SET_IO: u32 = 9;
pub const PW_CLIENT_NODE_EVENT_SET_ACTIVATION: u32 = 10;
pub const PW_CLIENT_NODE_EVENT_PORT_SET_MIX_INFO: u32 = 11;
pub const PW_CLIENT_NODE_EVENT_NUM: u32 = 12;
pub const PW_VERSION_CLIENT_NODE_EVENTS: u32 = 1;
pub const PW_CLIENT_NODE_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_NODE_METHOD_GET_NODE: u32 = 1;
pub const PW_CLIENT_NODE_METHOD_UPDATE: u32 = 2;
pub const PW_CLIENT_NODE_METHOD_PORT_UPDATE: u32 = 3;
pub const PW_CLIENT_NODE_METHOD_SET_ACTIVE: u32 = 4;
pub const PW_CLIENT_NODE_METHOD_EVENT: u32 = 5;
pub const PW_CLIENT_NODE_METHOD_PORT_BUFFERS: u32 = 6;
pub const PW_CLIENT_NODE_METHOD_NUM: u32 = 7;
pub const PW_VERSION_CLIENT_NODE_METHODS: u32 = 0;
pub const PW_CLIENT_NODE_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_NODE_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_NODE_PORT_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_NODE_PORT_UPDATE_INFO: u32 = 2;
pub const PW_TYPE_INTERFACE_Metadata: &[u8; 28] = b"PipeWire:Interface:Metadata\0";
pub const PW_METADATA_PERM_MASK: u32 = 448;
pub const PW_VERSION_METADATA: u32 = 3;
pub const PW_METADATA_EVENT_PROPERTY: u32 = 0;
pub const PW_METADATA_EVENT_NUM: u32 = 1;
pub const PW_VERSION_METADATA_EVENTS: u32 = 0;
pub const PW_METADATA_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_METADATA_METHOD_SET_PROPERTY: u32 = 1;
pub const PW_METADATA_METHOD_CLEAR: u32 = 2;
pub const PW_METADATA_METHOD_NUM: u32 = 3;
pub const PW_VERSION_METADATA_METHODS: u32 = 0;
pub const PW_KEY_METADATA_NAME: &[u8; 14] = b"metadata.name\0";
pub const PW_KEY_METADATA_VALUES: &[u8; 16] = b"metadata.values\0";
pub const PW_TYPE_INTERFACE_Profiler: &[u8; 28] = b"PipeWire:Interface:Profiler\0";
pub const PW_VERSION_PROFILER: u32 = 3;
pub const PW_PROFILER_PERM_MASK: u32 = 256;
pub const PW_PROFILER_EVENT_PROFILE: u32 = 0;
pub const PW_PROFILER_EVENT_NUM: u32 = 1;
pub const PW_VERSION_PROFILER_EVENTS: u32 = 0;
pub const PW_PROFILER_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_PROFILER_METHOD_NUM: u32 = 1;
pub const PW_VERSION_PROFILER_METHODS: u32 = 0;
pub const PW_KEY_PROFILER_NAME: &[u8; 14] = b"profiler.name\0";
pub const PW_VERSION_CONTROL_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_CORE_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_DEVICE_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_FACTORY_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_FACTORY_IMPLEMENTATION: u32 = 0;
pub const PW_VERSION_IMPL_LINK_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_METADATA_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_MODULE_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_NODE_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_NODE_RT_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_PORT_EVENTS: u32 = 3;
pub const PW_VERSION_GLOBAL_EVENTS: u32 = 0;
pub const PW_VERSION_IMPL_CLIENT_EVENTS: u32 = 0;
pub const PW_VERSION_RESOURCE_EVENTS: u32 = 0;
pub const PW_TYPE_INFO_PROTOCOL_Native: &[u8; 25] = b"PipeWire:Protocol:Native\0";
pub const PW_VERSION_PROTOCOL_NATIVE_EXT: u32 = 0;
pub const PW_VERSION_SESSION_INFO: u32 = 0;
pub const PW_SESSION_CHANGE_MASK_PROPS: u32 = 1;
pub const PW_SESSION_CHANGE_MASK_PARAMS: u32 = 2;
pub const PW_SESSION_CHANGE_MASK_ALL: u32 = 3;
pub const PW_VERSION_ENDPOINT_INFO: u32 = 0;
pub const PW_ENDPOINT_FLAG_PROVIDES_SESSION: u32 = 1;
pub const PW_ENDPOINT_CHANGE_MASK_STREAMS: u32 = 1;
pub const PW_ENDPOINT_CHANGE_MASK_SESSION: u32 = 2;
pub const PW_ENDPOINT_CHANGE_MASK_PROPS: u32 = 4;
pub const PW_ENDPOINT_CHANGE_MASK_PARAMS: u32 = 8;
pub const PW_ENDPOINT_CHANGE_MASK_ALL: u32 = 15;
pub const PW_VERSION_ENDPOINT_STREAM_INFO: u32 = 0;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_LINK_PARAMS: u32 = 1;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_PROPS: u32 = 2;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_PARAMS: u32 = 4;
pub const PW_ENDPOINT_STREAM_CHANGE_MASK_ALL: u32 = 7;
pub const PW_VERSION_ENDPOINT_LINK_INFO: u32 = 0;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_STATE: u32 = 1;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_PROPS: u32 = 2;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_PARAMS: u32 = 4;
pub const PW_ENDPOINT_LINK_CHANGE_MASK_ALL: u32 = 7;
pub const PW_TYPE_INTERFACE_Session: &[u8; 27] = b"PipeWire:Interface:Session\0";
pub const PW_SESSION_PERM_MASK: u32 = 448;
pub const PW_VERSION_SESSION: u32 = 0;
pub const PW_TYPE_INTERFACE_Endpoint: &[u8; 28] = b"PipeWire:Interface:Endpoint\0";
pub const PW_ENDPOINT_PERM_MASK: u32 = 448;
pub const PW_VERSION_ENDPOINT: u32 = 0;
pub const PW_TYPE_INTERFACE_EndpointStream: &[u8; 34] = b"PipeWire:Interface:EndpointStream\0";
pub const PW_ENDPOINT_STREAM_PERM_MASK: u32 = 448;
pub const PW_VERSION_ENDPOINT_STREAM: u32 = 0;
pub const PW_TYPE_INTERFACE_EndpointLink: &[u8; 32] = b"PipeWire:Interface:EndpointLink\0";
pub const PW_ENDPOINT_LINK_PERM_MASK: u32 = 448;
pub const PW_VERSION_ENDPOINT_LINK: u32 = 0;
pub const PW_SESSION_EVENT_INFO: u32 = 0;
pub const PW_SESSION_EVENT_PARAM: u32 = 1;
pub const PW_SESSION_EVENT_NUM: u32 = 2;
pub const PW_VERSION_SESSION_EVENTS: u32 = 0;
pub const PW_SESSION_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_SESSION_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_SESSION_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_SESSION_METHOD_SET_PARAM: u32 = 3;
pub const PW_SESSION_METHOD_CREATE_LINK: u32 = 4;
pub const PW_SESSION_METHOD_NUM: u32 = 5;
pub const PW_VERSION_SESSION_METHODS: u32 = 0;
pub const PW_ENDPOINT_EVENT_INFO: u32 = 0;
pub const PW_ENDPOINT_EVENT_PARAM: u32 = 1;
pub const PW_ENDPOINT_EVENT_NUM: u32 = 2;
pub const PW_VERSION_ENDPOINT_EVENTS: u32 = 0;
pub const PW_ENDPOINT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_ENDPOINT_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_ENDPOINT_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_ENDPOINT_METHOD_SET_PARAM: u32 = 3;
pub const PW_ENDPOINT_METHOD_CREATE_LINK: u32 = 4;
pub const PW_ENDPOINT_METHOD_NUM: u32 = 5;
pub const PW_VERSION_ENDPOINT_METHODS: u32 = 0;
pub const PW_ENDPOINT_STREAM_EVENT_INFO: u32 = 0;
pub const PW_ENDPOINT_STREAM_EVENT_PARAM: u32 = 1;
pub const PW_ENDPOINT_STREAM_EVENT_NUM: u32 = 2;
pub const PW_VERSION_ENDPOINT_STREAM_EVENTS: u32 = 0;
pub const PW_ENDPOINT_STREAM_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_ENDPOINT_STREAM_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_ENDPOINT_STREAM_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_ENDPOINT_STREAM_METHOD_SET_PARAM: u32 = 3;
pub const PW_ENDPOINT_STREAM_METHOD_NUM: u32 = 4;
pub const PW_VERSION_ENDPOINT_STREAM_METHODS: u32 = 0;
pub const PW_ENDPOINT_LINK_EVENT_INFO: u32 = 0;
pub const PW_ENDPOINT_LINK_EVENT_PARAM: u32 = 1;
pub const PW_ENDPOINT_LINK_EVENT_NUM: u32 = 2;
pub const PW_VERSION_ENDPOINT_LINK_EVENTS: u32 = 0;
pub const PW_ENDPOINT_LINK_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_ENDPOINT_LINK_METHOD_SUBSCRIBE_PARAMS: u32 = 1;
pub const PW_ENDPOINT_LINK_METHOD_ENUM_PARAMS: u32 = 2;
pub const PW_ENDPOINT_LINK_METHOD_SET_PARAM: u32 = 3;
pub const PW_ENDPOINT_LINK_METHOD_REQUEST_STATE: u32 = 4;
pub const PW_ENDPOINT_LINK_METHOD_DESTROY: u32 = 5;
pub const PW_ENDPOINT_LINK_METHOD_NUM: u32 = 6;
pub const PW_VERSION_ENDPOINT_LINK_METHODS: u32 = 0;
pub const PW_TYPE_INTERFACE_ClientEndpoint: &[u8; 34] = b"PipeWire:Interface:ClientEndpoint\0";
pub const PW_VERSION_CLIENT_ENDPOINT: u32 = 0;
pub const PW_CLIENT_ENDPOINT_EVENT_SET_SESSION_ID: u32 = 0;
pub const PW_CLIENT_ENDPOINT_EVENT_SET_PARAM: u32 = 1;
pub const PW_CLIENT_ENDPOINT_EVENT_STREAM_SET_PARAM: u32 = 2;
pub const PW_CLIENT_ENDPOINT_EVENT_CREATE_LINK: u32 = 3;
pub const PW_CLIENT_ENDPOINT_EVENT_NUM: u32 = 4;
pub const PW_VERSION_CLIENT_ENDPOINT_EVENTS: u32 = 0;
pub const PW_CLIENT_ENDPOINT_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_ENDPOINT_METHOD_UPDATE: u32 = 1;
pub const PW_CLIENT_ENDPOINT_METHOD_STREAM_UPDATE: u32 = 2;
pub const PW_CLIENT_ENDPOINT_METHOD_NUM: u32 = 3;
pub const PW_VERSION_CLIENT_ENDPOINT_METHODS: u32 = 0;
pub const PW_CLIENT_ENDPOINT_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_ENDPOINT_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_ENDPOINT_STREAM_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_ENDPOINT_STREAM_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_ENDPOINT_STREAM_UPDATE_DESTROYED: u32 = 4;
pub const PW_TYPE_INTERFACE_ClientSession: &[u8; 33] = b"PipeWire:Interface:ClientSession\0";
pub const PW_VERSION_CLIENT_SESSION: u32 = 0;
pub const PW_CLIENT_SESSION_EVENT_SET_PARAM: u32 = 0;
pub const PW_CLIENT_SESSION_EVENT_LINK_SET_PARAM: u32 = 1;
pub const PW_CLIENT_SESSION_EVENT_LINK_REQUEST_STATE: u32 = 2;
pub const PW_CLIENT_SESSION_EVENT_NUM: u32 = 3;
pub const PW_VERSION_CLIENT_SESSION_EVENTS: u32 = 0;
pub const PW_CLIENT_SESSION_METHOD_ADD_LISTENER: u32 = 0;
pub const PW_CLIENT_SESSION_METHOD_UPDATE: u32 = 1;
pub const PW_CLIENT_SESSION_METHOD_LINK_UPDATE: u32 = 2;
pub const PW_CLIENT_SESSION_METHOD_NUM: u32 = 3;
pub const PW_VERSION_CLIENT_SESSION_METHODS: u32 = 0;
pub const PW_CLIENT_SESSION_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_SESSION_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_SESSION_LINK_UPDATE_PARAMS: u32 = 1;
pub const PW_CLIENT_SESSION_LINK_UPDATE_INFO: u32 = 2;
pub const PW_CLIENT_SESSION_LINK_UPDATE_DESTROYED: u32 = 4;
pub const PW_KEY_SESSION_ID: &[u8; 11] = b"session.id\0";
pub const PW_KEY_ENDPOINT_ID: &[u8; 12] = b"endpoint.id\0";
pub const PW_KEY_ENDPOINT_NAME: &[u8; 14] = b"endpoint.name\0";
pub const PW_KEY_ENDPOINT_MONITOR: &[u8; 17] = b"endpoint.monitor\0";
pub const PW_KEY_ENDPOINT_CLIENT_ID: &[u8; 19] = b"endpoint.client.id\0";
pub const PW_KEY_ENDPOINT_ICON_NAME: &[u8; 19] = b"endpoint.icon-name\0";
pub const PW_KEY_ENDPOINT_AUTOCONNECT: &[u8; 21] = b"endpoint.autoconnect\0";
pub const PW_KEY_ENDPOINT_TARGET: &[u8; 16] = b"endpoint.target\0";
pub const PW_KEY_ENDPOINT_STREAM_ID: &[u8; 19] = b"endpoint-stream.id\0";
pub const PW_KEY_ENDPOINT_STREAM_NAME: &[u8; 21] = b"endpoint-stream.name\0";
pub const PW_KEY_ENDPOINT_STREAM_DESCRIPTION: &[u8; 28] = b"endpoint-stream.description\0";
pub const PW_KEY_ENDPOINT_LINK_OUTPUT_ENDPOINT: &[u8; 30] = b"endpoint-link.output.endpoint\0";
pub const PW_KEY_ENDPOINT_LINK_OUTPUT_STREAM: &[u8; 28] = b"endpoint-link.output.stream\0";
pub const PW_KEY_ENDPOINT_LINK_INPUT_ENDPOINT: &[u8; 29] = b"endpoint-link.input.endpoint\0";
pub const PW_KEY_ENDPOINT_LINK_INPUT_STREAM: &[u8; 27] = b"endpoint-link.input.stream\0";
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of timespec"][::std::mem::size_of::<timespec>() - 16usize];
    ["Alignment of timespec"][::std::mem::align_of::<timespec>() - 8usize];
    ["Offset of field: timespec::tv_sec"][::std::mem::offset_of!(timespec, tv_sec) - 0usize];
    ["Offset of field: timespec::tv_nsec"][::std::mem::offset_of!(timespec, tv_nsec) - 8usize];
};
pub type __gnuc_va_list = __builtin_va_list;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _bitfield_align_1: [u32; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub _short_backupbuf: [::std::os::raw::c_char; 1usize],
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub _prevchain: *mut *mut _IO_FILE,
    pub _mode: ::std::os::raw::c_int,
    pub _unused3: ::std::os::raw::c_int,
    pub _total_written: __uint64_t,
    pub _unused2: [::std::os::raw::c_char; 8usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of _IO_FILE"][::std::mem::size_of::<_IO_FILE>() - 216usize];
    ["Alignment of _IO_FILE"][::std::mem::align_of::<_IO_FILE>() - 8usize];
    ["Offset of field: _IO_FILE::_flags"][::std::mem::offset_of!(_IO_FILE, _flags) - 0usize];
    ["Offset of field: _IO_FILE::_IO_read_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_ptr) - 8usize];
    ["Offset of field: _IO_FILE::_IO_read_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_end) - 16usize];
    ["Offset of field: _IO_FILE::_IO_read_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_read_base) - 24usize];
    ["Offset of field: _IO_FILE::_IO_write_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_base) - 32usize];
    ["Offset of field: _IO_FILE::_IO_write_ptr"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_ptr) - 40usize];
    ["Offset of field: _IO_FILE::_IO_write_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_write_end) - 48usize];
    ["Offset of field: _IO_FILE::_IO_buf_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_base) - 56usize];
    ["Offset of field: _IO_FILE::_IO_buf_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_buf_end) - 64usize];
    ["Offset of field: _IO_FILE::_IO_save_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_base) - 72usize];
    ["Offset of field: _IO_FILE::_IO_backup_base"]
        [::std::mem::offset_of!(_IO_FILE, _IO_backup_base) - 80usize];
    ["Offset of field: _IO_FILE::_IO_save_end"]
        [::std::mem::offset_of!(_IO_FILE, _IO_save_end) - 88usize];
    ["Offset of field: _IO_FILE::_markers"][::std::mem::offset_of!(_IO_FILE, _markers) - 96usize];
    ["Offset of field: _IO_FILE::_chain"][::std::mem::offset_of!(_IO_FILE, _chain) - 104usize];
    ["Offset of field: _IO_FILE::_fileno"][::std::mem::offset_of!(_IO_FILE, _fileno) - 112usize];
    ["Offset of field: _IO_FILE::_short_backupbuf"]
        [::std::mem::offset_of!(_IO_FILE, _short_backupbuf) - 119usize];
    ["Offset of field: _IO_FILE::_old_offset"]
        [::std::mem::offset_of!(_IO_FILE, _old_offset) - 120usize];
    ["Offset of field: _IO_FILE::_cur_column"]
        [::std::mem::offset_of!(_IO_FILE, _cur_column) - 128usize];
    ["Offset of field: _IO_FILE::_vtable_offset"]
        [::std::mem::offset_of!(_IO_FILE, _vtable_offset) - 130usize];
    ["Offset of field: _IO_FILE::_shortbuf"]
        [::std::mem::offset_of!(_IO_FILE, _shortbuf) - 131usize];
    ["Offset of field: _IO_FILE::_lock"][::std::mem::offset_of!(_IO_FILE, _lock) - 136usize];
    ["Offset of field: _IO_FILE::_offset"][::std::mem::offset_of!(_IO_FILE, _offset) - 144usize];
    ["Offset of field: _IO_FILE::_codecvt"][::std::mem::offset_of!(_IO_FILE, _codecvt) - 152usize];
    ["Offset of field: _IO_FILE::_wide_data"]
        [::std::mem::offset_of!(_IO_FILE, _wide_data) - 160usize];
    ["Offset of field: _IO_FILE::_freeres_list"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_list) - 168usize];
    ["Offset of field: _IO_FILE::_freeres_buf"]
        [::std::mem::offset_of!(_IO_FILE, _freeres_buf) - 176usize];
    ["Offset of field: _IO_FILE::_prevchain"]
        [::std::mem::offset_of!(_IO_FILE, _prevchain) - 184usize];
    ["Offset of field: _IO_FILE::_mode"][::std::mem::offset_of!(_IO_FILE, _mode) - 192usize];
    ["Offset of field: _IO_FILE::_unused3"][::std::mem::offset_of!(_IO_FILE, _unused3) - 196usize];
    ["Offset of field: _IO_FILE::_total_written"]
        [::std::mem::offset_of!(_IO_FILE, _total_written) - 200usize];
    ["Offset of field: _IO_FILE::_unused2"][::std::mem::offset_of!(_IO_FILE, _unused2) - 208usize];
};
impl _IO_FILE {
    #[inline]
    pub fn _flags2(&self) -> ::std::os::raw::c_int {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 24u8) as u32) }
    }
    #[inline]
    pub fn set__flags2(&mut self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 24u8, val as u64)
        }
    }
    #[inline]
    pub unsafe fn _flags2_raw(this: *const Self) -> ::std::os::raw::c_int {
        unsafe {
            ::std::mem::transmute(<__BindgenBitfieldUnit<[u8; 3usize]>>::raw_get(
                ::std::ptr::addr_of!((*this)._bitfield_1),
                0usize,
                24u8,
            ) as u32)
        }
    }
    #[inline]
    pub unsafe fn set__flags2_raw(this: *mut Self, val: ::std::os::raw::c_int) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            <__BindgenBitfieldUnit<[u8; 3usize]>>::raw_set(
                ::std::ptr::addr_of_mut!((*this)._bitfield_1),
                0usize,
                24u8,
                val as u64,
            )
        }
    }
    #[inline]
    pub fn new_bitfield_1(_flags2: ::std::os::raw::c_int) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 24u8, {
            let _flags2: u32 = unsafe { ::std::mem::transmute(_flags2) };
            _flags2 as u64
        });
        __bindgen_bitfield_unit
    }
}
pub type va_list = __gnuc_va_list;
#[doc = " \\addtogroup pw_array\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_array {
    #[doc = "< pointer to array data"]
    pub data: *mut ::std::os::raw::c_void,
    #[doc = "< length of array in bytes"]
    pub size: usize,
    #[doc = "< number of allocated memory in \\a data"]
    pub alloc: usize,
    #[doc = "< number of bytes to extend with, 0 when the\n  data should not expand"]
    pub extend: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_array"][::std::mem::size_of::<pw_array>() - 32usize];
    ["Alignment of pw_array"][::std::mem::align_of::<pw_array>() - 8usize];
    ["Offset of field: pw_array::data"][::std::mem::offset_of!(pw_array, data) - 0usize];
    ["Offset of field: pw_array::size"][::std::mem::offset_of!(pw_array, size) - 8usize];
    ["Offset of field: pw_array::alloc"][::std::mem::offset_of!(pw_array, alloc) - 16usize];
    ["Offset of field: pw_array::extend"][::std::mem::offset_of!(pw_array, extend) - 24usize];
};
pub const PW_TYPE_FIRST: _bindgen_ty_11 = 33554432;
#[doc = " \\addtogroup pw_type\n \\{"]
pub type _bindgen_ty_11 = ::std::os::raw::c_uint;
unsafe extern "C" {
    pub fn pw_type_info() -> *const spa_type_info;
}
#[doc = " \\addtogroup pw_proxy\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_proxy {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_protocol\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_context\n @{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_context {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_global\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_global {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup api_pw_impl"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_client {
    _unused: [u8; 0],
}
#[doc = " \\defgroup pw_impl_node Node Impl\n\n The node object processes data. The node has a list of\n input and output ports (\\ref pw_impl_port) on which it\n will receive and send out buffers respectively.\n/\n/**\n \\addtogroup pw_impl_node\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_node {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_registry {
    _unused: [u8; 0],
}
#[doc = "  The core information. Extra information may be added in later versions,\n clients must not assume a constant struct size"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< a random cookie for identifying this instance of PipeWire"]
    pub cookie: u32,
    #[doc = "< name of the user that started the core"]
    pub user_name: *const ::std::os::raw::c_char,
    #[doc = "< name of the machine the core is running on"]
    pub host_name: *const ::std::os::raw::c_char,
    #[doc = "< version of the core"]
    pub version: *const ::std::os::raw::c_char,
    #[doc = "< name of the core"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_core_info"][::std::mem::size_of::<pw_core_info>() - 56usize];
    ["Alignment of pw_core_info"][::std::mem::align_of::<pw_core_info>() - 8usize];
    ["Offset of field: pw_core_info::id"][::std::mem::offset_of!(pw_core_info, id) - 0usize];
    ["Offset of field: pw_core_info::cookie"]
        [::std::mem::offset_of!(pw_core_info, cookie) - 4usize];
    ["Offset of field: pw_core_info::user_name"]
        [::std::mem::offset_of!(pw_core_info, user_name) - 8usize];
    ["Offset of field: pw_core_info::host_name"]
        [::std::mem::offset_of!(pw_core_info, host_name) - 16usize];
    ["Offset of field: pw_core_info::version"]
        [::std::mem::offset_of!(pw_core_info, version) - 24usize];
    ["Offset of field: pw_core_info::name"][::std::mem::offset_of!(pw_core_info, name) - 32usize];
    ["Offset of field: pw_core_info::change_mask"]
        [::std::mem::offset_of!(pw_core_info, change_mask) - 40usize];
    ["Offset of field: pw_core_info::props"][::std::mem::offset_of!(pw_core_info, props) - 48usize];
};
#[doc = " \\addtogroup pw_properties\n \\{"]
#[repr(C)]
pub struct pw_properties {
    #[doc = "< dictionary of key/values"]
    pub dict: spa_dict,
    #[doc = "< extra flags"]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_properties"][::std::mem::size_of::<pw_properties>() - 24usize];
    ["Alignment of pw_properties"][::std::mem::align_of::<pw_properties>() - 8usize];
    ["Offset of field: pw_properties::dict"][::std::mem::offset_of!(pw_properties, dict) - 0usize];
    ["Offset of field: pw_properties::flags"]
        [::std::mem::offset_of!(pw_properties, flags) - 16usize];
};
unsafe extern "C" {
    pub fn pw_properties_new(key: *const ::std::os::raw::c_char, ...) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_new_dict(dict: *const spa_dict) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_new_string(args: *const ::std::os::raw::c_char) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_new_string_checked(
        args: *const ::std::os::raw::c_char,
        size: usize,
        loc: *mut spa_error_location,
    ) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_copy(properties: *const pw_properties) -> *mut pw_properties;
}
unsafe extern "C" {
    pub fn pw_properties_update_keys(
        props: *mut pw_properties,
        dict: *const spa_dict,
        keys: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update_ignore(
        props: *mut pw_properties,
        dict: *const spa_dict,
        ignore: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update(
        props: *mut pw_properties,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update_string(
        props: *mut pw_properties,
        str_: *const ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_update_string_checked(
        props: *mut pw_properties,
        str_: *const ::std::os::raw::c_char,
        size: usize,
        loc: *mut spa_error_location,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_add(
        oldprops: *mut pw_properties,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_add_keys(
        oldprops: *mut pw_properties,
        dict: *const spa_dict,
        keys: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_clear(properties: *mut pw_properties);
}
unsafe extern "C" {
    pub fn pw_properties_free(properties: *mut pw_properties);
}
unsafe extern "C" {
    pub fn pw_properties_set(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_setf(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_setva(
        properties: *mut pw_properties,
        key: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_get(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_uint32(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_int32(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut i32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_uint64(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_int64(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_fetch_bool(
        properties: *const pw_properties,
        key: *const ::std::os::raw::c_char,
        value: *mut bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_properties_iterate(
        properties: *const pw_properties,
        state: *mut *mut ::std::os::raw::c_void,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_properties_serialize_dict(
        f: *mut FILE,
        dict: *const spa_dict,
        flags: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update an existing \\ref pw_core_info with \\a update with reset. When info is NULL,\n a new one will be allocated. Returns NULL on failure."]
    pub fn pw_core_info_update(
        info: *mut pw_core_info,
        update: *const pw_core_info,
    ) -> *mut pw_core_info;
}
unsafe extern "C" {
    #[doc = " Update an existing \\ref pw_core_info with \\a update. When info is NULL, a new one\n will be allocated. Returns NULL on failure"]
    pub fn pw_core_info_merge(
        info: *mut pw_core_info,
        update: *const pw_core_info,
        reset: bool,
    ) -> *mut pw_core_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_core_info"]
    pub fn pw_core_info_free(info: *mut pw_core_info);
}
#[doc = " \\struct pw_core_events\n  \\brief Core events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core_events {
    pub version: u32,
    #[doc = " Notify new core info\n\n This event is emitted when first bound to the core or when the\n hello method is called.\n\n \\param info new core info"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_core_info),
    >,
    #[doc = " Emit a done event\n\n The done event is emitted as a result of a sync method with the\n same seq number.\n\n \\param seq the seq number passed to the sync method call"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Emit a ping event\n\n The client should reply with a pong reply with the same seq\n number."]
    pub ping: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ),
    >,
    #[doc = " Fatal error event\n\n The error event is sent out when a fatal (non-recoverable)\n error has occurred. The id argument is the proxy object where\n the error occurred, most often in response to a request to that\n object. The message is a brief description of the error,\n for (debugging) convenience.\n\n This event is usually also emitted on the proxy object with\n \\a id.\n\n \\param id object where the error occurred\n \\param seq the sequence number that generated the error\n \\param res error code\n \\param message error description"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Remove an object ID\n\n This event is used internally by the object ID management\n logic. When a client deletes an object, the server will send\n this event to acknowledge that it has seen the delete request.\n When the client receives this event, it will know that it can\n safely reuse the object ID.\n\n \\param id deleted object ID"]
    pub remove_id:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
    #[doc = " Notify an object binding\n\n This event is emitted when a local object ID is bound to a\n global ID. It is emitted before the global becomes visible in the\n registry.\n\n The bound_props event is an enhanced version of this event that\n also contains the extra global properties.\n\n \\param id bound object ID\n \\param global_id the global id bound to"]
    pub bound_id: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32, global_id: u32),
    >,
    #[doc = " Add memory for a client\n\n Memory is given to a client as \\a fd of a certain\n memory \\a type.\n\n Further references to this fd will be made with the per memory\n unique identifier \\a id.\n\n \\param id the unique id of the memory\n \\param type the memory type, one of enum spa_data_type\n \\param fd the file descriptor\n \\param flags extra flags"]
    pub add_mem: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            type_: u32,
            fd: ::std::os::raw::c_int,
            flags: u32,
        ),
    >,
    #[doc = " Remove memory for a client\n\n \\param id the memory id to remove"]
    pub remove_mem:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
    #[doc = " Notify an object binding\n\n This event is emitted when a local object ID is bound to a\n global ID. It is emitted before the global becomes visible in the\n registry.\n\n This is an enhanced version of the bound_id event.\n\n \\param id bound object ID\n \\param global_id the global id bound to\n \\param props The properties of the new global object.\n\n Since version 4:1"]
    pub bound_props: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            global_id: u32,
            props: *const spa_dict,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_core_events"][::std::mem::size_of::<pw_core_events>() - 80usize];
    ["Alignment of pw_core_events"][::std::mem::align_of::<pw_core_events>() - 8usize];
    ["Offset of field: pw_core_events::version"]
        [::std::mem::offset_of!(pw_core_events, version) - 0usize];
    ["Offset of field: pw_core_events::info"]
        [::std::mem::offset_of!(pw_core_events, info) - 8usize];
    ["Offset of field: pw_core_events::done"]
        [::std::mem::offset_of!(pw_core_events, done) - 16usize];
    ["Offset of field: pw_core_events::ping"]
        [::std::mem::offset_of!(pw_core_events, ping) - 24usize];
    ["Offset of field: pw_core_events::error"]
        [::std::mem::offset_of!(pw_core_events, error) - 32usize];
    ["Offset of field: pw_core_events::remove_id"]
        [::std::mem::offset_of!(pw_core_events, remove_id) - 40usize];
    ["Offset of field: pw_core_events::bound_id"]
        [::std::mem::offset_of!(pw_core_events, bound_id) - 48usize];
    ["Offset of field: pw_core_events::add_mem"]
        [::std::mem::offset_of!(pw_core_events, add_mem) - 56usize];
    ["Offset of field: pw_core_events::remove_mem"]
        [::std::mem::offset_of!(pw_core_events, remove_mem) - 64usize];
    ["Offset of field: pw_core_events::bound_props"]
        [::std::mem::offset_of!(pw_core_events, bound_props) - 72usize];
};
#[doc = " \\struct pw_core_methods\n \\brief Core methods\n\n The core global object. This is a singleton object used for\n creating new objects in the remote PipeWire instance. It is\n also used for internal features."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_core_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_core_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Start a conversation with the server. This will send\n the core info and will destroy all resources for the client\n (except the core and client resource).\n\n This requires X permissions on the core."]
    pub hello: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Do server roundtrip\n\n Ask the server to emit the 'done' event with \\a seq.\n\n Since methods are handled in-order and events are delivered\n in-order, this can be used as a barrier to ensure all previous\n methods and the resulting events have been handled.\n\n \\param seq the seq number passed to the done event\n\n This requires X permissions on the core."]
    pub sync: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Reply to a server ping event.\n\n Reply to the server ping event with the same seq.\n\n \\param seq the seq number received in the ping event\n\n This requires X permissions on the core."]
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Fatal error event\n\n The error method is sent out when a fatal (non-recoverable)\n error has occurred. The id argument is the proxy object where\n the error occurred, most often in response to an event on that\n object. The message is a brief description of the error,\n for (debugging) convenience.\n\n This method is usually also emitted on the resource object with\n \\a id.\n\n \\param id resource id where the error occurred\n \\param res error code\n \\param message error description\n\n This requires X permissions on the core."]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get the registry object\n\n Create a registry object that allows the client to list and bind\n the global objects available from the PipeWire server\n \\param version the client version\n \\param user_data_size extra size\n\n This requires X permissions on the core."]
    pub get_registry: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
            user_data_size: usize,
        ) -> *mut pw_registry,
    >,
    #[doc = " Create a new object on the PipeWire server from a factory.\n\n \\param factory_name the factory name to use\n \\param type the interface to bind to\n \\param version the version of the interface\n \\param props extra properties\n \\param user_data_size extra size\n\n This requires X permissions on the core."]
    pub create_object: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            factory_name: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            props: *const spa_dict,
            user_data_size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Destroy an resource\n\n Destroy the server resource for the given proxy.\n\n \\param obj the proxy to destroy\n\n This requires X permissions on the core."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            proxy: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_core_methods"][::std::mem::size_of::<pw_core_methods>() - 72usize];
    ["Alignment of pw_core_methods"][::std::mem::align_of::<pw_core_methods>() - 8usize];
    ["Offset of field: pw_core_methods::version"]
        [::std::mem::offset_of!(pw_core_methods, version) - 0usize];
    ["Offset of field: pw_core_methods::add_listener"]
        [::std::mem::offset_of!(pw_core_methods, add_listener) - 8usize];
    ["Offset of field: pw_core_methods::hello"]
        [::std::mem::offset_of!(pw_core_methods, hello) - 16usize];
    ["Offset of field: pw_core_methods::sync"]
        [::std::mem::offset_of!(pw_core_methods, sync) - 24usize];
    ["Offset of field: pw_core_methods::pong"]
        [::std::mem::offset_of!(pw_core_methods, pong) - 32usize];
    ["Offset of field: pw_core_methods::error"]
        [::std::mem::offset_of!(pw_core_methods, error) - 40usize];
    ["Offset of field: pw_core_methods::get_registry"]
        [::std::mem::offset_of!(pw_core_methods, get_registry) - 48usize];
    ["Offset of field: pw_core_methods::create_object"]
        [::std::mem::offset_of!(pw_core_methods, create_object) - 56usize];
    ["Offset of field: pw_core_methods::destroy"]
        [::std::mem::offset_of!(pw_core_methods, destroy) - 64usize];
};
#[doc = " Registry events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_registry_events {
    pub version: u32,
    #[doc = " Notify of a new global object\n\n The registry emits this event when a new global object is\n available.\n\n \\param id the global object id\n \\param permissions the permissions of the object\n \\param type the type of the interface\n \\param version the version of the interface\n \\param props extra properties of the global"]
    pub global: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            permissions: u32,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            props: *const spa_dict,
        ),
    >,
    #[doc = " Notify of a global object removal\n\n Emitted when a global object was removed from the registry.\n If the client has any bindings to the global, it should destroy\n those.\n\n \\param id the id of the global that was removed"]
    pub global_remove:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_registry_events"][::std::mem::size_of::<pw_registry_events>() - 24usize];
    ["Alignment of pw_registry_events"][::std::mem::align_of::<pw_registry_events>() - 8usize];
    ["Offset of field: pw_registry_events::version"]
        [::std::mem::offset_of!(pw_registry_events, version) - 0usize];
    ["Offset of field: pw_registry_events::global"]
        [::std::mem::offset_of!(pw_registry_events, global) - 8usize];
    ["Offset of field: pw_registry_events::global_remove"]
        [::std::mem::offset_of!(pw_registry_events, global_remove) - 16usize];
};
#[doc = " Registry methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_registry_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_registry_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Bind to a global object\n\n Bind to the global object with \\a id and use the client proxy\n with new_id as the proxy. After this call, methods can be\n send to the remote global object and events can be received\n\n \\param id the global id to bind to\n \\param type the interface type to bind to\n \\param version the interface version to use\n \\returns the new object"]
    pub bind: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            use_data_size: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    #[doc = " Attempt to destroy a global object\n\n Try to destroy the global object.\n\n \\param id the global id to destroy. The client needs X permissions\n on the global."]
    pub destroy: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void, id: u32) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_registry_methods"][::std::mem::size_of::<pw_registry_methods>() - 32usize];
    ["Alignment of pw_registry_methods"][::std::mem::align_of::<pw_registry_methods>() - 8usize];
    ["Offset of field: pw_registry_methods::version"]
        [::std::mem::offset_of!(pw_registry_methods, version) - 0usize];
    ["Offset of field: pw_registry_methods::add_listener"]
        [::std::mem::offset_of!(pw_registry_methods, add_listener) - 8usize];
    ["Offset of field: pw_registry_methods::bind"]
        [::std::mem::offset_of!(pw_registry_methods, bind) - 16usize];
    ["Offset of field: pw_registry_methods::destroy"]
        [::std::mem::offset_of!(pw_registry_methods, destroy) - 24usize];
};
unsafe extern "C" {
    #[doc = " Connect to a PipeWire instance\n\n \\param context a \\ref pw_context\n \\param properties optional properties, ownership of the properties is\n\ttaken.\n \\param user_data_size extra user data size\n\n \\return a \\ref pw_core on success or NULL with errno set on error. The core\n will have an id of \\ref PW_ID_CORE (0)"]
    pub fn pw_context_connect(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Connect to a PipeWire instance on the given socket\n\n \\param context a \\ref pw_context\n \\param fd the connected socket to use, the socket will be closed\n\tautomatically on disconnect or error.\n \\param properties optional properties, ownership of the properties is\n\ttaken.\n \\param user_data_size extra user data size\n\n \\return a \\ref pw_core on success or NULL with errno set on error"]
    pub fn pw_context_connect_fd(
        context: *mut pw_context,
        fd: ::std::os::raw::c_int,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Connect to a given PipeWire instance\n\n \\param context a \\ref pw_context to connect to\n \\param properties optional properties, ownership of the properties is\n\ttaken.\n \\param user_data_size extra user data size\n\n \\return a \\ref pw_core on success or NULL with errno set on error"]
    pub fn pw_context_connect_self(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Steal the fd of the core connection or < 0 on error. The core\n will be disconnected after this call."]
    pub fn pw_core_steal_fd(core: *mut pw_core) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Pause or resume the core. When the core is paused, no new events\n  will be dispatched until the core is resumed again."]
    pub fn pw_core_set_paused(core: *mut pw_core, paused: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " disconnect and destroy a core"]
    pub fn pw_core_disconnect(core: *mut pw_core) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the user_data. It is of the size specified when this object was\n constructed"]
    pub fn pw_core_get_user_data(core: *mut pw_core) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the client proxy of the connected core. This will have the id\n of PW_ID_CLIENT (1)"]
    pub fn pw_core_get_client(core: *mut pw_core) -> *mut pw_client;
}
unsafe extern "C" {
    #[doc = " Get the context object used to created this core"]
    pub fn pw_core_get_context(core: *mut pw_core) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get properties from the core"]
    pub fn pw_core_get_properties(core: *mut pw_core) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the core properties. This updates the properties\n of the associated client.\n \\return the number of properties that were updated"]
    pub fn pw_core_update_properties(
        core: *mut pw_core,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the core mempool object"]
    pub fn pw_core_get_mempool(core: *mut pw_core) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " Get the proxy with the given id"]
    pub fn pw_core_find_proxy(core: *mut pw_core, id: u32) -> *mut pw_proxy;
}
unsafe extern "C" {
    #[doc = " Export an object into the PipeWire instance associated with core"]
    pub fn pw_core_export(
        core: *mut pw_core,
        type_: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        object: *mut ::std::os::raw::c_void,
        user_data_size: usize,
    ) -> *mut pw_proxy;
}
#[doc = " \\addtogroup pw_loop\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_loop {
    #[doc = "< system utils"]
    pub system: *mut spa_system,
    #[doc = "< wrapped loop"]
    pub loop_: *mut spa_loop,
    #[doc = "< loop control"]
    pub control: *mut spa_loop_control,
    #[doc = "< loop utils"]
    pub utils: *mut spa_loop_utils,
    pub name: *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_loop"][::std::mem::size_of::<pw_loop>() - 40usize];
    ["Alignment of pw_loop"][::std::mem::align_of::<pw_loop>() - 8usize];
    ["Offset of field: pw_loop::system"][::std::mem::offset_of!(pw_loop, system) - 0usize];
    ["Offset of field: pw_loop::loop_"][::std::mem::offset_of!(pw_loop, loop_) - 8usize];
    ["Offset of field: pw_loop::control"][::std::mem::offset_of!(pw_loop, control) - 16usize];
    ["Offset of field: pw_loop::utils"][::std::mem::offset_of!(pw_loop, utils) - 24usize];
    ["Offset of field: pw_loop::name"][::std::mem::offset_of!(pw_loop, name) - 32usize];
};
unsafe extern "C" {
    pub fn pw_loop_new(props: *const spa_dict) -> *mut pw_loop;
}
unsafe extern "C" {
    pub fn pw_loop_destroy(loop_: *mut pw_loop);
}
unsafe extern "C" {
    pub fn pw_loop_set_name(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[doc = " context events emitted by the context object added with \\ref pw_context_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_context_events {
    pub version: u32,
    #[doc = " The context is being destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The context is being freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a new client object is added"]
    pub check_access: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, client: *mut pw_impl_client),
    >,
    #[doc = " a new global object was added"]
    pub global_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global: *mut pw_global),
    >,
    #[doc = " a global object was removed"]
    pub global_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global: *mut pw_global),
    >,
    #[doc = " a driver was added, since 0.3.75 version:1"]
    pub driver_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, node: *mut pw_impl_node),
    >,
    #[doc = " a driver was removed, since 0.3.75 version:1"]
    pub driver_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, node: *mut pw_impl_node),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_context_events"][::std::mem::size_of::<pw_context_events>() - 64usize];
    ["Alignment of pw_context_events"][::std::mem::align_of::<pw_context_events>() - 8usize];
    ["Offset of field: pw_context_events::version"]
        [::std::mem::offset_of!(pw_context_events, version) - 0usize];
    ["Offset of field: pw_context_events::destroy"]
        [::std::mem::offset_of!(pw_context_events, destroy) - 8usize];
    ["Offset of field: pw_context_events::free"]
        [::std::mem::offset_of!(pw_context_events, free) - 16usize];
    ["Offset of field: pw_context_events::check_access"]
        [::std::mem::offset_of!(pw_context_events, check_access) - 24usize];
    ["Offset of field: pw_context_events::global_added"]
        [::std::mem::offset_of!(pw_context_events, global_added) - 32usize];
    ["Offset of field: pw_context_events::global_removed"]
        [::std::mem::offset_of!(pw_context_events, global_removed) - 40usize];
    ["Offset of field: pw_context_events::driver_added"]
        [::std::mem::offset_of!(pw_context_events, driver_added) - 48usize];
    ["Offset of field: pw_context_events::driver_removed"]
        [::std::mem::offset_of!(pw_context_events, driver_removed) - 56usize];
};
unsafe extern "C" {
    #[doc = " Make a new context object for a given main_loop. Ownership of the properties is taken, even\n if the function returns NULL.\n\n \\param main_loop A main loop to run in. This must stay alive unil pw_context_destroy() is called.\n \\param props extra properties\n \\param user_data_size extra user data size\n \\return The context object on success, or NULL on failure, in which case errno is set."]
    pub fn pw_context_new(
        main_loop: *mut pw_loop,
        props: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " destroy a context object, all resources except the main_loop will be destroyed"]
    pub fn pw_context_destroy(context: *mut pw_context);
}
unsafe extern "C" {
    #[doc = " Get the context user data"]
    pub fn pw_context_get_user_data(context: *mut pw_context) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Add a new event listener to a context"]
    pub fn pw_context_add_listener(
        context: *mut pw_context,
        listener: *mut spa_hook,
        events: *const pw_context_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the context properties"]
    pub fn pw_context_get_properties(context: *mut pw_context) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the context properties"]
    pub fn pw_context_update_properties(
        context: *mut pw_context,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a config section for this context. Since 0.3.22, deprecated,\n use pw_context_conf_section_for_each()."]
    pub fn pw_context_get_conf_section(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Parse a standard config section for this context. Since 0.3.22"]
    pub fn pw_context_parse_conf_section(
        context: *mut pw_context,
        conf: *mut pw_properties,
        section: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " update properties from a section into props. Since 0.3.45"]
    pub fn pw_context_conf_update_props(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " emit callback for all config sections. Since 0.3.45"]
    pub fn pw_context_conf_section_for_each(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                section: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " emit callback for all matched properties. Since 0.3.46"]
    pub fn pw_context_conf_section_match_rules(
        context: *mut pw_context,
        section: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                action: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the context support objects"]
    pub fn pw_context_get_support(
        context: *mut pw_context,
        n_support: *mut u32,
    ) -> *const spa_support;
}
unsafe extern "C" {
    #[doc = " Get the context main loop. Returns the value passed to pw_context_new()."]
    pub fn pw_context_get_main_loop(context: *mut pw_context) -> *mut pw_loop;
}
#[doc = " \\addtogroup pw_data_loop\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_data_loop {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the context data loop. This loop runs on the realtime thread. This\n acquires a loop from the generic data.rt class. Use pw_context_acquire_loop() instead.\n Since 0.3.56"]
    pub fn pw_context_get_data_loop(context: *mut pw_context) -> *mut pw_data_loop;
}
unsafe extern "C" {
    #[doc = " Get a data-loop.\n Since 1.1.0"]
    pub fn pw_context_acquire_loop(
        context: *mut pw_context,
        props: *const spa_dict,
    ) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Release a data-loop.\n Since 1.1.0"]
    pub fn pw_context_release_loop(context: *mut pw_context, loop_: *mut pw_loop);
}
#[doc = " \\addtogroup pw_work_queue\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_work_queue {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Get the work queue from the context: Since 0.3.26"]
    pub fn pw_context_get_work_queue(context: *mut pw_context) -> *mut pw_work_queue;
}
unsafe extern "C" {
    #[doc = " Get the memory pool from the context: Since 0.3.74"]
    pub fn pw_context_get_mempool(context: *mut pw_context) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " Iterate the globals of the context. The callback should return\n 0 to fetch the next item, any other value stops the iteration and returns\n the value. When all callbacks return 0, this function returns 0 when all\n globals are iterated."]
    pub fn pw_context_for_each_global(
        context: *mut pw_context,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                global: *mut pw_global,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find a context global by id.\n\n \\return The global on success, or NULL on failure. If id is \\ref PW_ID_CORE,\n         this function will always return a non-NULL value."]
    pub fn pw_context_find_global(context: *mut pw_context, id: u32) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " add a spa library for the given factory_name regex"]
    pub fn pw_context_add_spa_lib(
        context: *mut pw_context,
        factory_regex: *const ::std::os::raw::c_char,
        lib: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " find the library name for a spa factory"]
    pub fn pw_context_find_spa_lib(
        context: *mut pw_context,
        factory_name: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Load a SPA handle from a context. On failure returns NULL and sets errno."]
    pub fn pw_context_load_spa_handle(
        context: *mut pw_context,
        factory_name: *const ::std::os::raw::c_char,
        info: *const spa_dict,
    ) -> *mut spa_handle;
}
#[doc = " data for registering export functions"]
#[repr(C)]
pub struct pw_export_type {
    pub link: spa_list,
    pub type_: *const ::std::os::raw::c_char,
    pub func: ::std::option::Option<
        unsafe extern "C" fn(
            core: *mut pw_core,
            type_: *const ::std::os::raw::c_char,
            props: *const spa_dict,
            object: *mut ::std::os::raw::c_void,
            user_data_size: usize,
        ) -> *mut pw_proxy,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_export_type"][::std::mem::size_of::<pw_export_type>() - 32usize];
    ["Alignment of pw_export_type"][::std::mem::align_of::<pw_export_type>() - 8usize];
    ["Offset of field: pw_export_type::link"]
        [::std::mem::offset_of!(pw_export_type, link) - 0usize];
    ["Offset of field: pw_export_type::type_"]
        [::std::mem::offset_of!(pw_export_type, type_) - 16usize];
    ["Offset of field: pw_export_type::func"]
        [::std::mem::offset_of!(pw_export_type, func) - 24usize];
};
unsafe extern "C" {
    #[doc = " register a type that can be exported on a context_proxy. This is usually used by\n extension modules"]
    pub fn pw_context_register_export_type(
        context: *mut pw_context,
        type_: *mut pw_export_type,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " find information about registered export type"]
    pub fn pw_context_find_export_type(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
    ) -> *const pw_export_type;
}
unsafe extern "C" {
    #[doc = " add an object to the context\n\n \\param context The context.\n \\param type The type of the object, usually a `TYPE_INTERFACE_` value.\n \\param value The object value. Must last as long as the context and must\n              be of the type corresponding to the type.\n \\return A negative number on failure (out of memory)."]
    pub fn pw_context_set_object(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get an object from the context\n\n \\param context The context.\n \\param type The string corresponding to the object's interface.\n \\return The object, or NULL if the object does not exist."]
    pub fn pw_context_get_object(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void;
}
#[doc = " a function to destroy an item"]
pub type pw_destroy_t =
    ::std::option::Option<unsafe extern "C" fn(object: *mut ::std::os::raw::c_void)>;
unsafe extern "C" {
    pub fn pw_split_walk(
        str_: *const ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        len: *mut usize,
        state: *mut *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_split_strv(
        str_: *const ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        max_tokens: ::std::os::raw::c_int,
        n_tokens: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_split_ip(
        str_: *mut ::std::os::raw::c_char,
        delimiter: *const ::std::os::raw::c_char,
        max_tokens: ::std::os::raw::c_int,
        tokens: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_strv_parse(
        val: *const ::std::os::raw::c_char,
        len: usize,
        max_tokens: ::std::os::raw::c_int,
        n_tokens: *mut ::std::os::raw::c_int,
    ) -> *mut *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_strv_find(
        a: *mut *mut ::std::os::raw::c_char,
        b: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_strv_find_common(
        a: *mut *mut ::std::os::raw::c_char,
        b: *mut *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_free_strv(str_: *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn pw_strip(
        str_: *mut ::std::os::raw::c_char,
        whitespace: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_getrandom(
        buf: *mut ::std::os::raw::c_void,
        buflen: usize,
        flags: ::std::os::raw::c_uint,
    ) -> isize;
}
unsafe extern "C" {
    pub fn pw_random(buf: *mut ::std::os::raw::c_void, buflen: usize);
}
unsafe extern "C" {
    pub fn pw_reallocarray(
        ptr: *mut ::std::os::raw::c_void,
        nmemb: usize,
        size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
pub struct pw_protocol_client {
    #[doc = "< link in protocol client_list"]
    pub link: spa_list,
    #[doc = "< the owner protocol"]
    pub protocol: *mut pw_protocol,
    pub core: *mut pw_core,
    pub connect: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            props: *const spa_dict,
            done_callback: ::std::option::Option<
                unsafe extern "C" fn(
                    data: *mut ::std::os::raw::c_void,
                    result: ::std::os::raw::c_int,
                ),
            >,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    pub connect_fd: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            fd: ::std::os::raw::c_int,
            close: bool,
        ) -> ::std::os::raw::c_int,
    >,
    pub steal_fd: ::std::option::Option<
        unsafe extern "C" fn(client: *mut pw_protocol_client) -> ::std::os::raw::c_int,
    >,
    pub disconnect: ::std::option::Option<unsafe extern "C" fn(client: *mut pw_protocol_client)>,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(client: *mut pw_protocol_client)>,
    pub set_paused: ::std::option::Option<
        unsafe extern "C" fn(
            client: *mut pw_protocol_client,
            paused: bool,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_client"][::std::mem::size_of::<pw_protocol_client>() - 80usize];
    ["Alignment of pw_protocol_client"][::std::mem::align_of::<pw_protocol_client>() - 8usize];
    ["Offset of field: pw_protocol_client::link"]
        [::std::mem::offset_of!(pw_protocol_client, link) - 0usize];
    ["Offset of field: pw_protocol_client::protocol"]
        [::std::mem::offset_of!(pw_protocol_client, protocol) - 16usize];
    ["Offset of field: pw_protocol_client::core"]
        [::std::mem::offset_of!(pw_protocol_client, core) - 24usize];
    ["Offset of field: pw_protocol_client::connect"]
        [::std::mem::offset_of!(pw_protocol_client, connect) - 32usize];
    ["Offset of field: pw_protocol_client::connect_fd"]
        [::std::mem::offset_of!(pw_protocol_client, connect_fd) - 40usize];
    ["Offset of field: pw_protocol_client::steal_fd"]
        [::std::mem::offset_of!(pw_protocol_client, steal_fd) - 48usize];
    ["Offset of field: pw_protocol_client::disconnect"]
        [::std::mem::offset_of!(pw_protocol_client, disconnect) - 56usize];
    ["Offset of field: pw_protocol_client::destroy"]
        [::std::mem::offset_of!(pw_protocol_client, destroy) - 64usize];
    ["Offset of field: pw_protocol_client::set_paused"]
        [::std::mem::offset_of!(pw_protocol_client, set_paused) - 72usize];
};
#[repr(C)]
pub struct pw_protocol_server {
    #[doc = "< link in protocol server_list"]
    pub link: spa_list,
    #[doc = "< the owner protocol"]
    pub protocol: *mut pw_protocol,
    pub core: *mut pw_impl_core,
    #[doc = "< list of clients of this protocol"]
    pub client_list: spa_list,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(listen: *mut pw_protocol_server)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_server"][::std::mem::size_of::<pw_protocol_server>() - 56usize];
    ["Alignment of pw_protocol_server"][::std::mem::align_of::<pw_protocol_server>() - 8usize];
    ["Offset of field: pw_protocol_server::link"]
        [::std::mem::offset_of!(pw_protocol_server, link) - 0usize];
    ["Offset of field: pw_protocol_server::protocol"]
        [::std::mem::offset_of!(pw_protocol_server, protocol) - 16usize];
    ["Offset of field: pw_protocol_server::core"]
        [::std::mem::offset_of!(pw_protocol_server, core) - 24usize];
    ["Offset of field: pw_protocol_server::client_list"]
        [::std::mem::offset_of!(pw_protocol_server, client_list) - 32usize];
    ["Offset of field: pw_protocol_server::destroy"]
        [::std::mem::offset_of!(pw_protocol_server, destroy) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_marshal {
    #[doc = "< interface type"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< version"]
    pub version: u32,
    #[doc = "< version"]
    pub flags: u32,
    #[doc = "< number of client methods"]
    pub n_client_methods: u32,
    #[doc = "< number of server methods"]
    pub n_server_methods: u32,
    pub client_marshal: *const ::std::os::raw::c_void,
    pub server_demarshal: *const ::std::os::raw::c_void,
    pub server_marshal: *const ::std::os::raw::c_void,
    pub client_demarshal: *const ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_marshal"][::std::mem::size_of::<pw_protocol_marshal>() - 56usize];
    ["Alignment of pw_protocol_marshal"][::std::mem::align_of::<pw_protocol_marshal>() - 8usize];
    ["Offset of field: pw_protocol_marshal::type_"]
        [::std::mem::offset_of!(pw_protocol_marshal, type_) - 0usize];
    ["Offset of field: pw_protocol_marshal::version"]
        [::std::mem::offset_of!(pw_protocol_marshal, version) - 8usize];
    ["Offset of field: pw_protocol_marshal::flags"]
        [::std::mem::offset_of!(pw_protocol_marshal, flags) - 12usize];
    ["Offset of field: pw_protocol_marshal::n_client_methods"]
        [::std::mem::offset_of!(pw_protocol_marshal, n_client_methods) - 16usize];
    ["Offset of field: pw_protocol_marshal::n_server_methods"]
        [::std::mem::offset_of!(pw_protocol_marshal, n_server_methods) - 20usize];
    ["Offset of field: pw_protocol_marshal::client_marshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, client_marshal) - 24usize];
    ["Offset of field: pw_protocol_marshal::server_demarshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, server_demarshal) - 32usize];
    ["Offset of field: pw_protocol_marshal::server_marshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, server_marshal) - 40usize];
    ["Offset of field: pw_protocol_marshal::client_demarshal"]
        [::std::mem::offset_of!(pw_protocol_marshal, client_demarshal) - 48usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_implementation {
    pub version: u32,
    pub new_client: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_core,
            props: *const spa_dict,
        ) -> *mut pw_protocol_client,
    >,
    pub add_server: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_impl_core,
            props: *const spa_dict,
        ) -> *mut pw_protocol_server,
    >,
    pub add_fd_server: ::std::option::Option<
        unsafe extern "C" fn(
            protocol: *mut pw_protocol,
            core: *mut pw_impl_core,
            listen_fd: ::std::os::raw::c_int,
            close_fd: ::std::os::raw::c_int,
            props: *const spa_dict,
        ) -> *mut pw_protocol_server,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_implementation"]
        [::std::mem::size_of::<pw_protocol_implementation>() - 32usize];
    ["Alignment of pw_protocol_implementation"]
        [::std::mem::align_of::<pw_protocol_implementation>() - 8usize];
    ["Offset of field: pw_protocol_implementation::version"]
        [::std::mem::offset_of!(pw_protocol_implementation, version) - 0usize];
    ["Offset of field: pw_protocol_implementation::new_client"]
        [::std::mem::offset_of!(pw_protocol_implementation, new_client) - 8usize];
    ["Offset of field: pw_protocol_implementation::add_server"]
        [::std::mem::offset_of!(pw_protocol_implementation, add_server) - 16usize];
    ["Offset of field: pw_protocol_implementation::add_fd_server"]
        [::std::mem::offset_of!(pw_protocol_implementation, add_fd_server) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_events"][::std::mem::size_of::<pw_protocol_events>() - 16usize];
    ["Alignment of pw_protocol_events"][::std::mem::align_of::<pw_protocol_events>() - 8usize];
    ["Offset of field: pw_protocol_events::version"]
        [::std::mem::offset_of!(pw_protocol_events, version) - 0usize];
    ["Offset of field: pw_protocol_events::destroy"]
        [::std::mem::offset_of!(pw_protocol_events, destroy) - 8usize];
};
unsafe extern "C" {
    pub fn pw_protocol_new(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        user_data_size: usize,
    ) -> *mut pw_protocol;
}
unsafe extern "C" {
    pub fn pw_protocol_destroy(protocol: *mut pw_protocol);
}
unsafe extern "C" {
    pub fn pw_protocol_get_context(protocol: *mut pw_protocol) -> *mut pw_context;
}
unsafe extern "C" {
    pub fn pw_protocol_get_user_data(protocol: *mut pw_protocol) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pw_protocol_get_implementation(
        protocol: *mut pw_protocol,
    ) -> *const pw_protocol_implementation;
}
unsafe extern "C" {
    pub fn pw_protocol_get_extension(protocol: *mut pw_protocol) -> *const ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pw_protocol_add_listener(
        protocol: *mut pw_protocol,
        listener: *mut spa_hook,
        events: *const pw_protocol_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_protocol_add_marshal(
        protocol: *mut pw_protocol,
        marshal: *const pw_protocol_marshal,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_protocol_get_marshal(
        protocol: *mut pw_protocol,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        flags: u32,
    ) -> *const pw_protocol_marshal;
}
unsafe extern "C" {
    pub fn pw_context_find_protocol(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut pw_protocol;
}
#[doc = " Proxy events, use \\ref pw_proxy_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_proxy_events {
    pub version: u32,
    #[doc = " The proxy is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a proxy is bound to a global id"]
    pub bound: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, global_id: u32),
    >,
    #[doc = " a proxy is removed from the server. Use pw_proxy_destroy to\n free the proxy."]
    pub removed: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a reply to a sync method completed"]
    pub done: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seq: ::std::os::raw::c_int),
    >,
    #[doc = " an error occurred on the proxy"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
    pub bound_props: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            global_id: u32,
            props: *const spa_dict,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_proxy_events"][::std::mem::size_of::<pw_proxy_events>() - 56usize];
    ["Alignment of pw_proxy_events"][::std::mem::align_of::<pw_proxy_events>() - 8usize];
    ["Offset of field: pw_proxy_events::version"]
        [::std::mem::offset_of!(pw_proxy_events, version) - 0usize];
    ["Offset of field: pw_proxy_events::destroy"]
        [::std::mem::offset_of!(pw_proxy_events, destroy) - 8usize];
    ["Offset of field: pw_proxy_events::bound"]
        [::std::mem::offset_of!(pw_proxy_events, bound) - 16usize];
    ["Offset of field: pw_proxy_events::removed"]
        [::std::mem::offset_of!(pw_proxy_events, removed) - 24usize];
    ["Offset of field: pw_proxy_events::done"]
        [::std::mem::offset_of!(pw_proxy_events, done) - 32usize];
    ["Offset of field: pw_proxy_events::error"]
        [::std::mem::offset_of!(pw_proxy_events, error) - 40usize];
    ["Offset of field: pw_proxy_events::bound_props"]
        [::std::mem::offset_of!(pw_proxy_events, bound_props) - 48usize];
};
unsafe extern "C" {
    pub fn pw_proxy_new(
        factory: *mut pw_proxy,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        user_data_size: usize,
    ) -> *mut pw_proxy;
}
unsafe extern "C" {
    #[doc = " Add an event listener to proxy"]
    pub fn pw_proxy_add_listener(
        proxy: *mut pw_proxy,
        listener: *mut spa_hook,
        events: *const pw_proxy_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Add a listener for the events received from the remote object. The\n events depend on the type of the remote object type."]
    pub fn pw_proxy_add_object_listener(
        proxy: *mut pw_proxy,
        listener: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " destroy a proxy"]
    pub fn pw_proxy_destroy(proxy: *mut pw_proxy);
}
unsafe extern "C" {
    pub fn pw_proxy_ref(proxy: *mut pw_proxy);
}
unsafe extern "C" {
    pub fn pw_proxy_unref(proxy: *mut pw_proxy);
}
unsafe extern "C" {
    #[doc = " Get the user_data. The size was given in \\ref pw_proxy_new"]
    pub fn pw_proxy_get_user_data(proxy: *mut pw_proxy) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the local id of the proxy"]
    pub fn pw_proxy_get_id(proxy: *mut pw_proxy) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the type and version of the proxy"]
    pub fn pw_proxy_get_type(
        proxy: *mut pw_proxy,
        version: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the protocol used for the proxy"]
    pub fn pw_proxy_get_protocol(proxy: *mut pw_proxy) -> *mut pw_protocol;
}
unsafe extern "C" {
    #[doc = " Generate an sync method for a proxy. This will generate a done event\n with the same seq number of the reply."]
    pub fn pw_proxy_sync(proxy: *mut pw_proxy, seq: ::std::os::raw::c_int)
    -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the global id this proxy is bound to. This is usually used internally\n and will also emit the bound event"]
    pub fn pw_proxy_set_bound_id(proxy: *mut pw_proxy, global_id: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the global id bound to this proxy of SPA_ID_INVALID when not bound\n to a global"]
    pub fn pw_proxy_get_bound_id(proxy: *mut pw_proxy) -> u32;
}
unsafe extern "C" {
    #[doc = " Generate an error for a proxy"]
    pub fn pw_proxy_error(
        proxy: *mut pw_proxy,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_proxy_errorf(
        proxy: *mut pw_proxy,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the listener of proxy"]
    pub fn pw_proxy_get_object_listeners(proxy: *mut pw_proxy) -> *mut spa_hook_list;
}
unsafe extern "C" {
    #[doc = " Get the marshal functions for the proxy"]
    pub fn pw_proxy_get_marshal(proxy: *mut pw_proxy) -> *const pw_protocol_marshal;
}
unsafe extern "C" {
    #[doc = " Install a marshal function on a proxy"]
    pub fn pw_proxy_install_marshal(
        proxy: *mut pw_proxy,
        implementor: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_permission {
    #[doc = "< id of object, PW_ID_ANY for default permission"]
    pub id: u32,
    #[doc = "< bitmask of above permissions"]
    pub permissions: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_permission"][::std::mem::size_of::<pw_permission>() - 8usize];
    ["Alignment of pw_permission"][::std::mem::align_of::<pw_permission>() - 4usize];
    ["Offset of field: pw_permission::id"][::std::mem::offset_of!(pw_permission, id) - 0usize];
    ["Offset of field: pw_permission::permissions"]
        [::std::mem::offset_of!(pw_permission, permissions) - 4usize];
};
#[doc = " The client information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_info"][::std::mem::size_of::<pw_client_info>() - 24usize];
    ["Alignment of pw_client_info"][::std::mem::align_of::<pw_client_info>() - 8usize];
    ["Offset of field: pw_client_info::id"][::std::mem::offset_of!(pw_client_info, id) - 0usize];
    ["Offset of field: pw_client_info::change_mask"]
        [::std::mem::offset_of!(pw_client_info, change_mask) - 8usize];
    ["Offset of field: pw_client_info::props"]
        [::std::mem::offset_of!(pw_client_info, props) - 16usize];
};
unsafe extern "C" {
    #[doc = " Update an existing \\ref pw_client_info with \\a update with reset"]
    pub fn pw_client_info_update(
        info: *mut pw_client_info,
        update: *const pw_client_info,
    ) -> *mut pw_client_info;
}
unsafe extern "C" {
    #[doc = " Merge an existing \\ref pw_client_info with \\a update"]
    pub fn pw_client_info_merge(
        info: *mut pw_client_info,
        update: *const pw_client_info,
        reset: bool,
    ) -> *mut pw_client_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_client_info"]
    pub fn pw_client_info_free(info: *mut pw_client_info);
}
#[doc = " Client events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_events {
    pub version: u32,
    #[doc = " Notify client info\n\n \\param info info about the client"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_client_info),
    >,
    #[doc = " Notify a client permission\n\n Event emitted as a result of the get_permissions method.\n\n \\param default_permissions the default permissions\n \\param index the index of the first permission entry\n \\param n_permissions the number of permissions\n \\param permissions the permissions"]
    pub permissions: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            index: u32,
            n_permissions: u32,
            permissions: *const pw_permission,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_events"][::std::mem::size_of::<pw_client_events>() - 24usize];
    ["Alignment of pw_client_events"][::std::mem::align_of::<pw_client_events>() - 8usize];
    ["Offset of field: pw_client_events::version"]
        [::std::mem::offset_of!(pw_client_events, version) - 0usize];
    ["Offset of field: pw_client_events::info"]
        [::std::mem::offset_of!(pw_client_events, info) - 8usize];
    ["Offset of field: pw_client_events::permissions"]
        [::std::mem::offset_of!(pw_client_events, permissions) - 16usize];
};
#[doc = " Client methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send an error to a client\n\n \\param id the global id to report the error on\n \\param res an errno style error code\n \\param message an error string\n\n This requires W and X permissions on the client."]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update client properties\n\n \\param props new properties\n\n This requires W and X permissions on the client."]
    pub update_properties: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Get client permissions\n\n A permissions event will be emitted with the permissions.\n\n \\param index the first index to query, 0 for first\n \\param num the maximum number of items to get\n\n This requires W and X permissions on the client."]
    pub get_permissions: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            index: u32,
            num: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Manage the permissions of the global objects for this\n client\n\n Update the permissions of the global objects using the\n provided array with permissions\n\n Globals can use the default permissions or can have specific\n permissions assigned to them.\n\n \\param n_permissions number of permissions\n \\param permissions array of permissions\n\n This requires W and X permissions on the client."]
    pub update_permissions: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            n_permissions: u32,
            permissions: *const pw_permission,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_methods"][::std::mem::size_of::<pw_client_methods>() - 48usize];
    ["Alignment of pw_client_methods"][::std::mem::align_of::<pw_client_methods>() - 8usize];
    ["Offset of field: pw_client_methods::version"]
        [::std::mem::offset_of!(pw_client_methods, version) - 0usize];
    ["Offset of field: pw_client_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_methods::error"]
        [::std::mem::offset_of!(pw_client_methods, error) - 16usize];
    ["Offset of field: pw_client_methods::update_properties"]
        [::std::mem::offset_of!(pw_client_methods, update_properties) - 24usize];
    ["Offset of field: pw_client_methods::get_permissions"]
        [::std::mem::offset_of!(pw_client_methods, get_permissions) - 32usize];
    ["Offset of field: pw_client_methods::update_permissions"]
        [::std::mem::offset_of!(pw_client_methods, update_permissions) - 40usize];
};
unsafe extern "C" {
    #[doc = " \\addtogroup pw_conf\n \\{"]
    pub fn pw_conf_load_conf_for_context(
        props: *mut pw_properties,
        conf: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_load_conf(
        prefix: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        conf: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_load_state(
        prefix: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        conf: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_save_state(
        prefix: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        conf: *const pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_find_match(arr: *mut spa_json, props: *const spa_dict, condition: bool) -> bool;
}
unsafe extern "C" {
    pub fn pw_conf_section_update_props(
        conf: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_section_update_props_rules(
        conf: *const spa_dict,
        context: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_section_for_each(
        conf: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                section: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_match_rules(
        str_: *const ::std::os::raw::c_char,
        len: usize,
        location: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                action: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_conf_section_match_rules(
        conf: *const spa_dict,
        section: *const ::std::os::raw::c_char,
        props: *const spa_dict,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                location: *const ::std::os::raw::c_char,
                action: *const ::std::os::raw::c_char,
                str_: *const ::std::os::raw::c_char,
                len: usize,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device {
    _unused: [u8; 0],
}
#[doc = " The device information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_device_info"][::std::mem::size_of::<pw_device_info>() - 40usize];
    ["Alignment of pw_device_info"][::std::mem::align_of::<pw_device_info>() - 8usize];
    ["Offset of field: pw_device_info::id"][::std::mem::offset_of!(pw_device_info, id) - 0usize];
    ["Offset of field: pw_device_info::change_mask"]
        [::std::mem::offset_of!(pw_device_info, change_mask) - 8usize];
    ["Offset of field: pw_device_info::props"]
        [::std::mem::offset_of!(pw_device_info, props) - 16usize];
    ["Offset of field: pw_device_info::params"]
        [::std::mem::offset_of!(pw_device_info, params) - 24usize];
    ["Offset of field: pw_device_info::n_params"]
        [::std::mem::offset_of!(pw_device_info, n_params) - 32usize];
};
unsafe extern "C" {
    #[doc = " Update and existing \\ref pw_device_info with \\a update and reset"]
    pub fn pw_device_info_update(
        info: *mut pw_device_info,
        update: *const pw_device_info,
    ) -> *mut pw_device_info;
}
unsafe extern "C" {
    #[doc = " Merge and existing \\ref pw_device_info with \\a update"]
    pub fn pw_device_info_merge(
        info: *mut pw_device_info,
        update: *const pw_device_info,
        reset: bool,
    ) -> *mut pw_device_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_device_info"]
    pub fn pw_device_info_free(info: *mut pw_device_info);
}
#[doc = " Device events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device_events {
    pub version: u32,
    #[doc = " Notify device info\n\n \\param info info about the device"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_device_info),
    >,
    #[doc = " Notify a device param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_device_events"][::std::mem::size_of::<pw_device_events>() - 24usize];
    ["Alignment of pw_device_events"][::std::mem::align_of::<pw_device_events>() - 8usize];
    ["Offset of field: pw_device_events::version"]
        [::std::mem::offset_of!(pw_device_events, version) - 0usize];
    ["Offset of field: pw_device_events::info"]
        [::std::mem::offset_of!(pw_device_events, info) - 8usize];
    ["Offset of field: pw_device_events::param"]
        [::std::mem::offset_of!(pw_device_events, param) - 16usize];
};
#[doc = " Device methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_device_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_device_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions on the device."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate device parameters\n\n Start enumeration of device parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number to place in the reply\n \\param id the parameter id to enum or PW_ID_ANY for all\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions on the device."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the device\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires W and X permissions on the device."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_device_methods"][::std::mem::size_of::<pw_device_methods>() - 40usize];
    ["Alignment of pw_device_methods"][::std::mem::align_of::<pw_device_methods>() - 8usize];
    ["Offset of field: pw_device_methods::version"]
        [::std::mem::offset_of!(pw_device_methods, version) - 0usize];
    ["Offset of field: pw_device_methods::add_listener"]
        [::std::mem::offset_of!(pw_device_methods, add_listener) - 8usize];
    ["Offset of field: pw_device_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_device_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_device_methods::enum_params"]
        [::std::mem::offset_of!(pw_device_methods, enum_params) - 24usize];
    ["Offset of field: pw_device_methods::set_param"]
        [::std::mem::offset_of!(pw_device_methods, set_param) - 32usize];
};
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_NONE: pw_memblock_flags = 0;
#[doc = "< memory is readable"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_READABLE: pw_memblock_flags = 1;
#[doc = "< memory is writable"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_WRITABLE: pw_memblock_flags = 2;
#[doc = "< seal the fd"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_SEAL: pw_memblock_flags = 4;
#[doc = "< mmap the fd"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_MAP: pw_memblock_flags = 8;
#[doc = "< don't close fd"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_DONT_CLOSE: pw_memblock_flags = 16;
#[doc = "< don't notify events"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_DONT_NOTIFY: pw_memblock_flags = 32;
#[doc = "< the fd can not be mmapped"]
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_UNMAPPABLE: pw_memblock_flags = 64;
pub const pw_memblock_flags_PW_MEMBLOCK_FLAG_READWRITE: pw_memblock_flags = 3;
#[doc = " Flags passed to \\ref pw_mempool_alloc()"]
pub type pw_memblock_flags = ::std::os::raw::c_uint;
pub const pw_memmap_flags_PW_MEMMAP_FLAG_NONE: pw_memmap_flags = 0;
#[doc = "< map in read mode"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_READ: pw_memmap_flags = 1;
#[doc = "< map in write mode"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_WRITE: pw_memmap_flags = 2;
#[doc = "< map the same area twice after each other,\n  creating a circular ringbuffer"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_TWICE: pw_memmap_flags = 4;
#[doc = "< writes will be private"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_PRIVATE: pw_memmap_flags = 8;
#[doc = "< lock the memory into RAM"]
pub const pw_memmap_flags_PW_MEMMAP_FLAG_LOCKED: pw_memmap_flags = 16;
pub const pw_memmap_flags_PW_MEMMAP_FLAG_READWRITE: pw_memmap_flags = 3;
pub type pw_memmap_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_memchunk {
    _unused: [u8; 0],
}
#[doc = " A memory pool is a collection of pw_memblocks"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_mempool {
    pub props: *mut pw_properties,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_mempool"][::std::mem::size_of::<pw_mempool>() - 8usize];
    ["Alignment of pw_mempool"][::std::mem::align_of::<pw_mempool>() - 8usize];
    ["Offset of field: pw_mempool::props"][::std::mem::offset_of!(pw_mempool, props) - 0usize];
};
#[doc = " Memory block structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_memblock {
    #[doc = "< owner pool"]
    pub pool: *mut pw_mempool,
    #[doc = "< unique id"]
    pub id: u32,
    #[doc = "< refcount"]
    pub ref_: ::std::os::raw::c_int,
    #[doc = "< flags for the memory block on of enum pw_memblock_flags"]
    pub flags: u32,
    #[doc = "< type of the fd, one of enum spa_data_type"]
    pub type_: u32,
    #[doc = "< fd"]
    pub fd: ::std::os::raw::c_int,
    #[doc = "< size of memory"]
    pub size: u32,
    #[doc = "< optional map when PW_MEMBLOCK_FLAG_MAP was given"]
    pub map: *mut pw_memmap,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_memblock"][::std::mem::size_of::<pw_memblock>() - 40usize];
    ["Alignment of pw_memblock"][::std::mem::align_of::<pw_memblock>() - 8usize];
    ["Offset of field: pw_memblock::pool"][::std::mem::offset_of!(pw_memblock, pool) - 0usize];
    ["Offset of field: pw_memblock::id"][::std::mem::offset_of!(pw_memblock, id) - 8usize];
    ["Offset of field: pw_memblock::ref_"][::std::mem::offset_of!(pw_memblock, ref_) - 12usize];
    ["Offset of field: pw_memblock::flags"][::std::mem::offset_of!(pw_memblock, flags) - 16usize];
    ["Offset of field: pw_memblock::type_"][::std::mem::offset_of!(pw_memblock, type_) - 20usize];
    ["Offset of field: pw_memblock::fd"][::std::mem::offset_of!(pw_memblock, fd) - 24usize];
    ["Offset of field: pw_memblock::size"][::std::mem::offset_of!(pw_memblock, size) - 28usize];
    ["Offset of field: pw_memblock::map"][::std::mem::offset_of!(pw_memblock, map) - 32usize];
};
#[doc = " a mapped region of a pw_memblock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_memmap {
    #[doc = "< owner memblock"]
    pub block: *mut pw_memblock,
    #[doc = "< mapped pointer"]
    pub ptr: *mut ::std::os::raw::c_void,
    #[doc = "< flags for the mapping on of enum pw_memmap_flags"]
    pub flags: u32,
    #[doc = "< offset in memblock"]
    pub offset: u32,
    #[doc = "< size in memblock"]
    pub size: u32,
    #[doc = "< user tag"]
    pub tag: [u32; 5usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_memmap"][::std::mem::size_of::<pw_memmap>() - 48usize];
    ["Alignment of pw_memmap"][::std::mem::align_of::<pw_memmap>() - 8usize];
    ["Offset of field: pw_memmap::block"][::std::mem::offset_of!(pw_memmap, block) - 0usize];
    ["Offset of field: pw_memmap::ptr"][::std::mem::offset_of!(pw_memmap, ptr) - 8usize];
    ["Offset of field: pw_memmap::flags"][::std::mem::offset_of!(pw_memmap, flags) - 16usize];
    ["Offset of field: pw_memmap::offset"][::std::mem::offset_of!(pw_memmap, offset) - 20usize];
    ["Offset of field: pw_memmap::size"][::std::mem::offset_of!(pw_memmap, size) - 24usize];
    ["Offset of field: pw_memmap::tag"][::std::mem::offset_of!(pw_memmap, tag) - 28usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_mempool_events {
    pub version: u32,
    #[doc = " the pool is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a new memory block is added to the pool"]
    pub added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, block: *mut pw_memblock),
    >,
    #[doc = " a memory block is removed from the pool"]
    pub removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, block: *mut pw_memblock),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_mempool_events"][::std::mem::size_of::<pw_mempool_events>() - 32usize];
    ["Alignment of pw_mempool_events"][::std::mem::align_of::<pw_mempool_events>() - 8usize];
    ["Offset of field: pw_mempool_events::version"]
        [::std::mem::offset_of!(pw_mempool_events, version) - 0usize];
    ["Offset of field: pw_mempool_events::destroy"]
        [::std::mem::offset_of!(pw_mempool_events, destroy) - 8usize];
    ["Offset of field: pw_mempool_events::added"]
        [::std::mem::offset_of!(pw_mempool_events, added) - 16usize];
    ["Offset of field: pw_mempool_events::removed"]
        [::std::mem::offset_of!(pw_mempool_events, removed) - 24usize];
};
unsafe extern "C" {
    #[doc = " Create a new memory pool"]
    pub fn pw_mempool_new(props: *mut pw_properties) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " Listen for events"]
    pub fn pw_mempool_add_listener(
        pool: *mut pw_mempool,
        listener: *mut spa_hook,
        events: *const pw_mempool_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Clear a pool"]
    pub fn pw_mempool_clear(pool: *mut pw_mempool);
}
unsafe extern "C" {
    #[doc = " Clear and destroy a pool"]
    pub fn pw_mempool_destroy(pool: *mut pw_mempool);
}
unsafe extern "C" {
    #[doc = " Allocate a memory block from the pool"]
    pub fn pw_mempool_alloc(
        pool: *mut pw_mempool,
        flags: pw_memblock_flags,
        type_: u32,
        size: usize,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Import a block from another pool"]
    pub fn pw_mempool_import_block(
        pool: *mut pw_mempool,
        mem: *mut pw_memblock,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Import an fd into the pool"]
    pub fn pw_mempool_import(
        pool: *mut pw_mempool,
        flags: pw_memblock_flags,
        type_: u32,
        fd: ::std::os::raw::c_int,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Free a memblock regardless of the refcount and destroy all mappings"]
    pub fn pw_memblock_free(mem: *mut pw_memblock);
}
unsafe extern "C" {
    #[doc = " Remove a memblock for given \\a id"]
    pub fn pw_mempool_remove_id(pool: *mut pw_mempool, id: u32) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find memblock for given \\a ptr"]
    pub fn pw_mempool_find_ptr(
        pool: *mut pw_mempool,
        ptr: *const ::std::os::raw::c_void,
    ) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Find memblock for given \\a id"]
    pub fn pw_mempool_find_id(pool: *mut pw_mempool, id: u32) -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Find memblock for given \\a fd"]
    pub fn pw_mempool_find_fd(pool: *mut pw_mempool, fd: ::std::os::raw::c_int)
    -> *mut pw_memblock;
}
unsafe extern "C" {
    #[doc = " Map a region of a memory block"]
    pub fn pw_memblock_map(
        block: *mut pw_memblock,
        flags: pw_memmap_flags,
        offset: u32,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
unsafe extern "C" {
    #[doc = " Map a region of a memory block with \\a id"]
    pub fn pw_mempool_map_id(
        pool: *mut pw_mempool,
        id: u32,
        flags: pw_memmap_flags,
        offset: u32,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
unsafe extern "C" {
    pub fn pw_mempool_import_map(
        pool: *mut pw_mempool,
        other: *mut pw_mempool,
        data: *mut ::std::os::raw::c_void,
        size: u32,
        tag: *mut u32,
    ) -> *mut pw_memmap;
}
unsafe extern "C" {
    #[doc = " find a map with the given tag"]
    pub fn pw_mempool_find_tag(pool: *mut pw_mempool, tag: *mut u32, size: usize)
    -> *mut pw_memmap;
}
unsafe extern "C" {
    #[doc = " Unmap a region"]
    pub fn pw_memmap_free(map: *mut pw_memmap) -> ::std::os::raw::c_int;
}
#[doc = " parameters to map a memory range"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_map_range {
    pub start: u32,
    #[doc = " offset in first page with start of data"]
    pub offset: u32,
    #[doc = " page aligned offset to map"]
    pub size: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_map_range"][::std::mem::size_of::<pw_map_range>() - 12usize];
    ["Alignment of pw_map_range"][::std::mem::align_of::<pw_map_range>() - 4usize];
    ["Offset of field: pw_map_range::start"][::std::mem::offset_of!(pw_map_range, start) - 0usize];
    ["Offset of field: pw_map_range::offset"]
        [::std::mem::offset_of!(pw_map_range, offset) - 4usize];
    ["Offset of field: pw_map_range::size"][::std::mem::offset_of!(pw_map_range, size) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_buffers {
    #[doc = "< allocated buffer memory"]
    pub mem: *mut pw_memblock,
    #[doc = "< port buffers"]
    pub buffers: *mut *mut spa_buffer,
    #[doc = "< number of port buffers"]
    pub n_buffers: u32,
    #[doc = "< flags"]
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_buffers"][::std::mem::size_of::<pw_buffers>() - 24usize];
    ["Alignment of pw_buffers"][::std::mem::align_of::<pw_buffers>() - 8usize];
    ["Offset of field: pw_buffers::mem"][::std::mem::offset_of!(pw_buffers, mem) - 0usize];
    ["Offset of field: pw_buffers::buffers"][::std::mem::offset_of!(pw_buffers, buffers) - 8usize];
    ["Offset of field: pw_buffers::n_buffers"]
        [::std::mem::offset_of!(pw_buffers, n_buffers) - 16usize];
    ["Offset of field: pw_buffers::flags"][::std::mem::offset_of!(pw_buffers, flags) - 20usize];
};
unsafe extern "C" {
    pub fn pw_buffers_negotiate(
        context: *mut pw_context,
        flags: u32,
        outnode: *mut spa_node,
        out_port_id: u32,
        innode: *mut spa_node,
        in_port_id: u32,
        result: *mut pw_buffers,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_buffers_clear(buffers: *mut pw_buffers);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory {
    _unused: [u8; 0],
}
#[doc = " The factory information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< name the factory"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< type of the objects created by this factory"]
    pub type_: *const ::std::os::raw::c_char,
    #[doc = "< version of the objects"]
    pub version: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the properties of the factory"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_factory_info"][::std::mem::size_of::<pw_factory_info>() - 48usize];
    ["Alignment of pw_factory_info"][::std::mem::align_of::<pw_factory_info>() - 8usize];
    ["Offset of field: pw_factory_info::id"][::std::mem::offset_of!(pw_factory_info, id) - 0usize];
    ["Offset of field: pw_factory_info::name"]
        [::std::mem::offset_of!(pw_factory_info, name) - 8usize];
    ["Offset of field: pw_factory_info::type_"]
        [::std::mem::offset_of!(pw_factory_info, type_) - 16usize];
    ["Offset of field: pw_factory_info::version"]
        [::std::mem::offset_of!(pw_factory_info, version) - 24usize];
    ["Offset of field: pw_factory_info::change_mask"]
        [::std::mem::offset_of!(pw_factory_info, change_mask) - 32usize];
    ["Offset of field: pw_factory_info::props"]
        [::std::mem::offset_of!(pw_factory_info, props) - 40usize];
};
unsafe extern "C" {
    pub fn pw_factory_info_update(
        info: *mut pw_factory_info,
        update: *const pw_factory_info,
    ) -> *mut pw_factory_info;
}
unsafe extern "C" {
    pub fn pw_factory_info_merge(
        info: *mut pw_factory_info,
        update: *const pw_factory_info,
        reset: bool,
    ) -> *mut pw_factory_info;
}
unsafe extern "C" {
    pub fn pw_factory_info_free(info: *mut pw_factory_info);
}
#[doc = " Factory events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory_events {
    pub version: u32,
    #[doc = " Notify factory info\n\n \\param info info about the factory"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_factory_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_factory_events"][::std::mem::size_of::<pw_factory_events>() - 16usize];
    ["Alignment of pw_factory_events"][::std::mem::align_of::<pw_factory_events>() - 8usize];
    ["Offset of field: pw_factory_events::version"]
        [::std::mem::offset_of!(pw_factory_events, version) - 0usize];
    ["Offset of field: pw_factory_events::info"]
        [::std::mem::offset_of!(pw_factory_events, info) - 8usize];
};
#[doc = " Factory methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_factory_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_factory_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_factory_methods"][::std::mem::size_of::<pw_factory_methods>() - 16usize];
    ["Alignment of pw_factory_methods"][::std::mem::align_of::<pw_factory_methods>() - 8usize];
    ["Offset of field: pw_factory_methods::version"]
        [::std::mem::offset_of!(pw_factory_methods, version) - 0usize];
    ["Offset of field: pw_factory_methods::add_listener"]
        [::std::mem::offset_of!(pw_factory_methods, add_listener) - 8usize];
};
unsafe extern "C" {
    #[doc = " \\addtogroup pw_log\n \\{\n/\n/** The global log level"]
    pub static mut pw_log_level: spa_log_level;
}
unsafe extern "C" {
    pub static PW_LOG_TOPIC_DEFAULT: *mut spa_log_topic;
}
unsafe extern "C" {
    #[doc = " Configure a logging module. This is usually done automatically\n in pw_init() but you can install a custom logger before calling\n pw_init()."]
    pub fn pw_log_set(log: *mut spa_log);
}
unsafe extern "C" {
    #[doc = " Get the log interface"]
    pub fn pw_log_get() -> *mut spa_log;
}
unsafe extern "C" {
    #[doc = " Configure the logging level"]
    pub fn pw_log_set_level(level: spa_log_level);
}
unsafe extern "C" {
    #[doc = " Configure the logging level using a string\n in PIPEWIRE_DEBUG format.\n\n \\since 1.1.0"]
    pub fn pw_log_set_level_string(str_: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Log a message for a topic"]
    pub fn pw_log_logt(
        level: spa_log_level,
        topic: *const spa_log_topic,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Log a message for a topic"]
    pub fn pw_log_logtv(
        level: spa_log_level,
        topic: *const spa_log_topic,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " Log a message for the default topic"]
    pub fn pw_log_log(
        level: spa_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Log a message for the default topic"]
    pub fn pw_log_logv(
        level: spa_log_level,
        file: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_int,
        func: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        args: *mut __va_list_tag,
    );
}
unsafe extern "C" {
    #[doc = " Register log topic with the logger, to enable dynamic log levels.\n Topic must be unregistered before freeing it or plugin unload.\n May be used instead of \\ref PW_LOG_TOPIC_INIT\n This function is threadsafe.\n\n \\since 1.1.0"]
    pub fn pw_log_topic_register(t: *mut spa_log_topic);
}
unsafe extern "C" {
    #[doc = " Unregister log topic. This function is threadsafe.\n\n \\since 1.1.0"]
    pub fn pw_log_topic_unregister(t: *mut spa_log_topic);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link {
    _unused: [u8; 0],
}
#[doc = "< the link is in error"]
pub const pw_link_state_PW_LINK_STATE_ERROR: pw_link_state = -2;
#[doc = "< the link is unlinked"]
pub const pw_link_state_PW_LINK_STATE_UNLINKED: pw_link_state = -1;
#[doc = "< the link is initialized"]
pub const pw_link_state_PW_LINK_STATE_INIT: pw_link_state = 0;
#[doc = "< the link is negotiating formats"]
pub const pw_link_state_PW_LINK_STATE_NEGOTIATING: pw_link_state = 1;
#[doc = "< the link is allocating buffers"]
pub const pw_link_state_PW_LINK_STATE_ALLOCATING: pw_link_state = 2;
#[doc = "< the link is paused"]
pub const pw_link_state_PW_LINK_STATE_PAUSED: pw_link_state = 3;
#[doc = "< the link is active"]
pub const pw_link_state_PW_LINK_STATE_ACTIVE: pw_link_state = 4;
#[doc = " \\enum pw_link_state The different link states"]
pub type pw_link_state = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Convert a \\ref pw_link_state to a readable string"]
    pub fn pw_link_state_as_string(state: pw_link_state) -> *const ::std::os::raw::c_char;
}
#[doc = " The link information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< server side output node id"]
    pub output_node_id: u32,
    #[doc = "< output port id"]
    pub output_port_id: u32,
    #[doc = "< server side input node id"]
    pub input_node_id: u32,
    #[doc = "< input port id"]
    pub input_port_id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the current state of the link"]
    pub state: pw_link_state,
    #[doc = "< an error reason if \\a state is error"]
    pub error: *const ::std::os::raw::c_char,
    #[doc = "< format over link"]
    pub format: *mut spa_pod,
    #[doc = "< the properties of the link"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_link_info"][::std::mem::size_of::<pw_link_info>() - 64usize];
    ["Alignment of pw_link_info"][::std::mem::align_of::<pw_link_info>() - 8usize];
    ["Offset of field: pw_link_info::id"][::std::mem::offset_of!(pw_link_info, id) - 0usize];
    ["Offset of field: pw_link_info::output_node_id"]
        [::std::mem::offset_of!(pw_link_info, output_node_id) - 4usize];
    ["Offset of field: pw_link_info::output_port_id"]
        [::std::mem::offset_of!(pw_link_info, output_port_id) - 8usize];
    ["Offset of field: pw_link_info::input_node_id"]
        [::std::mem::offset_of!(pw_link_info, input_node_id) - 12usize];
    ["Offset of field: pw_link_info::input_port_id"]
        [::std::mem::offset_of!(pw_link_info, input_port_id) - 16usize];
    ["Offset of field: pw_link_info::change_mask"]
        [::std::mem::offset_of!(pw_link_info, change_mask) - 24usize];
    ["Offset of field: pw_link_info::state"][::std::mem::offset_of!(pw_link_info, state) - 32usize];
    ["Offset of field: pw_link_info::error"][::std::mem::offset_of!(pw_link_info, error) - 40usize];
    ["Offset of field: pw_link_info::format"]
        [::std::mem::offset_of!(pw_link_info, format) - 48usize];
    ["Offset of field: pw_link_info::props"][::std::mem::offset_of!(pw_link_info, props) - 56usize];
};
unsafe extern "C" {
    pub fn pw_link_info_update(
        info: *mut pw_link_info,
        update: *const pw_link_info,
    ) -> *mut pw_link_info;
}
unsafe extern "C" {
    pub fn pw_link_info_merge(
        info: *mut pw_link_info,
        update: *const pw_link_info,
        reset: bool,
    ) -> *mut pw_link_info;
}
unsafe extern "C" {
    pub fn pw_link_info_free(info: *mut pw_link_info);
}
#[doc = " Link events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link_events {
    pub version: u32,
    #[doc = " Notify link info\n\n \\param info info about the link"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_link_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_link_events"][::std::mem::size_of::<pw_link_events>() - 16usize];
    ["Alignment of pw_link_events"][::std::mem::align_of::<pw_link_events>() - 8usize];
    ["Offset of field: pw_link_events::version"]
        [::std::mem::offset_of!(pw_link_events, version) - 0usize];
    ["Offset of field: pw_link_events::info"]
        [::std::mem::offset_of!(pw_link_events, info) - 8usize];
};
#[doc = " Link methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_link_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_link_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_link_methods"][::std::mem::size_of::<pw_link_methods>() - 16usize];
    ["Alignment of pw_link_methods"][::std::mem::align_of::<pw_link_methods>() - 8usize];
    ["Offset of field: pw_link_methods::version"]
        [::std::mem::offset_of!(pw_link_methods, version) - 0usize];
    ["Offset of field: pw_link_methods::add_listener"]
        [::std::mem::offset_of!(pw_link_methods, add_listener) - 8usize];
};
#[doc = " A main loop object"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_main_loop {
    _unused: [u8; 0],
}
#[doc = " Events of the main loop"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_main_loop_events {
    pub version: u32,
    #[doc = " Emitted when the main loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_main_loop_events"][::std::mem::size_of::<pw_main_loop_events>() - 16usize];
    ["Alignment of pw_main_loop_events"][::std::mem::align_of::<pw_main_loop_events>() - 8usize];
    ["Offset of field: pw_main_loop_events::version"]
        [::std::mem::offset_of!(pw_main_loop_events, version) - 0usize];
    ["Offset of field: pw_main_loop_events::destroy"]
        [::std::mem::offset_of!(pw_main_loop_events, destroy) - 8usize];
};
unsafe extern "C" {
    #[doc = " Create a new main loop."]
    pub fn pw_main_loop_new(props: *const spa_dict) -> *mut pw_main_loop;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_main_loop_add_listener(
        loop_: *mut pw_main_loop,
        listener: *mut spa_hook,
        events: *const pw_main_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the loop implementation"]
    pub fn pw_main_loop_get_loop(loop_: *mut pw_main_loop) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Destroy a loop"]
    pub fn pw_main_loop_destroy(loop_: *mut pw_main_loop);
}
unsafe extern "C" {
    #[doc = " Run a main loop. This blocks until \\ref pw_main_loop_quit is called.\n\n @return 0 on success, otherwise a negative number."]
    pub fn pw_main_loop_run(loop_: *mut pw_main_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Quit a main loop"]
    pub fn pw_main_loop_quit(loop_: *mut pw_main_loop) -> ::std::os::raw::c_int;
}
#[doc = " \\private\n An entry in the map. This is used internally only. Each element in the\n backing pw_array is a union pw_map_item. For real items, the data pointer\n points to the item. If an element has been removed, pw_map->free_list\n is the index of the most recently removed item. That item contains\n the index of the next removed item until item->next is SPA_ID_INVALID.\n\n The free list is prepended only, the last item to be removed will be the\n first item to get re-used on the next insert."]
#[repr(C)]
#[derive(Copy, Clone)]
pub union pw_map_item {
    pub next: usize,
    pub data: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_map_item"][::std::mem::size_of::<pw_map_item>() - 8usize];
    ["Alignment of pw_map_item"][::std::mem::align_of::<pw_map_item>() - 8usize];
    ["Offset of field: pw_map_item::next"][::std::mem::offset_of!(pw_map_item, next) - 0usize];
    ["Offset of field: pw_map_item::data"][::std::mem::offset_of!(pw_map_item, data) - 0usize];
};
#[doc = " A map. This struct should be treated as opaque by the caller."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_map {
    pub items: pw_array,
    pub free_list: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_map"][::std::mem::size_of::<pw_map>() - 40usize];
    ["Alignment of pw_map"][::std::mem::align_of::<pw_map>() - 8usize];
    ["Offset of field: pw_map::items"][::std::mem::offset_of!(pw_map, items) - 0usize];
    ["Offset of field: pw_map::free_list"][::std::mem::offset_of!(pw_map, free_list) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module {
    _unused: [u8; 0],
}
#[doc = " The module information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< name of the module"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< filename of the module"]
    pub filename: *const ::std::os::raw::c_char,
    #[doc = "< arguments passed to the module"]
    pub args: *const ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_module_info"][::std::mem::size_of::<pw_module_info>() - 48usize];
    ["Alignment of pw_module_info"][::std::mem::align_of::<pw_module_info>() - 8usize];
    ["Offset of field: pw_module_info::id"][::std::mem::offset_of!(pw_module_info, id) - 0usize];
    ["Offset of field: pw_module_info::name"]
        [::std::mem::offset_of!(pw_module_info, name) - 8usize];
    ["Offset of field: pw_module_info::filename"]
        [::std::mem::offset_of!(pw_module_info, filename) - 16usize];
    ["Offset of field: pw_module_info::args"]
        [::std::mem::offset_of!(pw_module_info, args) - 24usize];
    ["Offset of field: pw_module_info::change_mask"]
        [::std::mem::offset_of!(pw_module_info, change_mask) - 32usize];
    ["Offset of field: pw_module_info::props"]
        [::std::mem::offset_of!(pw_module_info, props) - 40usize];
};
unsafe extern "C" {
    #[doc = " Update and existing \\ref pw_module_info with \\a update with reset"]
    pub fn pw_module_info_update(
        info: *mut pw_module_info,
        update: *const pw_module_info,
    ) -> *mut pw_module_info;
}
unsafe extern "C" {
    #[doc = " Merge and existing \\ref pw_module_info with \\a update"]
    pub fn pw_module_info_merge(
        info: *mut pw_module_info,
        update: *const pw_module_info,
        reset: bool,
    ) -> *mut pw_module_info;
}
unsafe extern "C" {
    #[doc = " Free a \\ref pw_module_info"]
    pub fn pw_module_info_free(info: *mut pw_module_info);
}
#[doc = " Module events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module_events {
    pub version: u32,
    #[doc = " Notify module info\n\n \\param info info about the module"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_module_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_module_events"][::std::mem::size_of::<pw_module_events>() - 16usize];
    ["Alignment of pw_module_events"][::std::mem::align_of::<pw_module_events>() - 8usize];
    ["Offset of field: pw_module_events::version"]
        [::std::mem::offset_of!(pw_module_events, version) - 0usize];
    ["Offset of field: pw_module_events::info"]
        [::std::mem::offset_of!(pw_module_events, info) - 8usize];
};
#[doc = " Module methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_module_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_module_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_module_methods"][::std::mem::size_of::<pw_module_methods>() - 16usize];
    ["Alignment of pw_module_methods"][::std::mem::align_of::<pw_module_methods>() - 8usize];
    ["Offset of field: pw_module_methods::version"]
        [::std::mem::offset_of!(pw_module_methods, version) - 0usize];
    ["Offset of field: pw_module_methods::add_listener"]
        [::std::mem::offset_of!(pw_module_methods, add_listener) - 8usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node {
    _unused: [u8; 0],
}
#[doc = "< error state"]
pub const pw_node_state_PW_NODE_STATE_ERROR: pw_node_state = -1;
#[doc = "< the node is being created"]
pub const pw_node_state_PW_NODE_STATE_CREATING: pw_node_state = 0;
#[doc = "< the node is suspended, the device might\n   be closed"]
pub const pw_node_state_PW_NODE_STATE_SUSPENDED: pw_node_state = 1;
#[doc = "< the node is running but there is no active\n   port"]
pub const pw_node_state_PW_NODE_STATE_IDLE: pw_node_state = 2;
#[doc = "< the node is running"]
pub const pw_node_state_PW_NODE_STATE_RUNNING: pw_node_state = 3;
#[doc = " \\enum pw_node_state The different node states"]
pub type pw_node_state = ::std::os::raw::c_int;
unsafe extern "C" {
    #[doc = " Convert a \\ref pw_node_state to a readable string"]
    pub fn pw_node_state_as_string(state: pw_node_state) -> *const ::std::os::raw::c_char;
}
#[doc = " The node information. Extra information can be added in later versions"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< maximum number of inputs"]
    pub max_input_ports: u32,
    #[doc = "< maximum number of outputs"]
    pub max_output_ports: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< number of inputs"]
    pub n_input_ports: u32,
    #[doc = "< number of outputs"]
    pub n_output_ports: u32,
    #[doc = "< the current state of the node"]
    pub state: pw_node_state,
    #[doc = "< an error reason if \\a state is error"]
    pub error: *const ::std::os::raw::c_char,
    #[doc = "< the properties of the node"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_node_info"][::std::mem::size_of::<pw_node_info>() - 72usize];
    ["Alignment of pw_node_info"][::std::mem::align_of::<pw_node_info>() - 8usize];
    ["Offset of field: pw_node_info::id"][::std::mem::offset_of!(pw_node_info, id) - 0usize];
    ["Offset of field: pw_node_info::max_input_ports"]
        [::std::mem::offset_of!(pw_node_info, max_input_ports) - 4usize];
    ["Offset of field: pw_node_info::max_output_ports"]
        [::std::mem::offset_of!(pw_node_info, max_output_ports) - 8usize];
    ["Offset of field: pw_node_info::change_mask"]
        [::std::mem::offset_of!(pw_node_info, change_mask) - 16usize];
    ["Offset of field: pw_node_info::n_input_ports"]
        [::std::mem::offset_of!(pw_node_info, n_input_ports) - 24usize];
    ["Offset of field: pw_node_info::n_output_ports"]
        [::std::mem::offset_of!(pw_node_info, n_output_ports) - 28usize];
    ["Offset of field: pw_node_info::state"][::std::mem::offset_of!(pw_node_info, state) - 32usize];
    ["Offset of field: pw_node_info::error"][::std::mem::offset_of!(pw_node_info, error) - 40usize];
    ["Offset of field: pw_node_info::props"][::std::mem::offset_of!(pw_node_info, props) - 48usize];
    ["Offset of field: pw_node_info::params"]
        [::std::mem::offset_of!(pw_node_info, params) - 56usize];
    ["Offset of field: pw_node_info::n_params"]
        [::std::mem::offset_of!(pw_node_info, n_params) - 64usize];
};
unsafe extern "C" {
    pub fn pw_node_info_update(
        info: *mut pw_node_info,
        update: *const pw_node_info,
    ) -> *mut pw_node_info;
}
unsafe extern "C" {
    pub fn pw_node_info_merge(
        info: *mut pw_node_info,
        update: *const pw_node_info,
        reset: bool,
    ) -> *mut pw_node_info;
}
unsafe extern "C" {
    pub fn pw_node_info_free(info: *mut pw_node_info);
}
#[doc = " Node events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node_events {
    pub version: u32,
    #[doc = " Notify node info\n\n \\param info info about the node"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_node_info),
    >,
    #[doc = " Notify a node param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_node_events"][::std::mem::size_of::<pw_node_events>() - 24usize];
    ["Alignment of pw_node_events"][::std::mem::align_of::<pw_node_events>() - 8usize];
    ["Offset of field: pw_node_events::version"]
        [::std::mem::offset_of!(pw_node_events, version) - 0usize];
    ["Offset of field: pw_node_events::info"]
        [::std::mem::offset_of!(pw_node_events, info) - 8usize];
    ["Offset of field: pw_node_events::param"]
        [::std::mem::offset_of!(pw_node_events, param) - 16usize];
};
#[doc = " Node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_node_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions on the node."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate node parameters\n\n Start enumeration of node parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number to place in the reply\n \\param id the parameter id to enum or PW_ID_ANY for all\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions on the node."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the node\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions on the node."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send a command to the node\n\n \\param command the command to send\n\n This requires X and W permissions on the node."]
    pub send_command: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_node_methods"][::std::mem::size_of::<pw_node_methods>() - 48usize];
    ["Alignment of pw_node_methods"][::std::mem::align_of::<pw_node_methods>() - 8usize];
    ["Offset of field: pw_node_methods::version"]
        [::std::mem::offset_of!(pw_node_methods, version) - 0usize];
    ["Offset of field: pw_node_methods::add_listener"]
        [::std::mem::offset_of!(pw_node_methods, add_listener) - 8usize];
    ["Offset of field: pw_node_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_node_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_node_methods::enum_params"]
        [::std::mem::offset_of!(pw_node_methods, enum_params) - 24usize];
    ["Offset of field: pw_node_methods::set_param"]
        [::std::mem::offset_of!(pw_node_methods, set_param) - 32usize];
    ["Offset of field: pw_node_methods::send_command"]
        [::std::mem::offset_of!(pw_node_methods, send_command) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port {
    _unused: [u8; 0],
}
unsafe extern "C" {
    #[doc = " Convert a \\ref pw_direction to a readable string"]
    pub fn pw_direction_as_string(direction: spa_direction) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
pub struct pw_port_info {
    #[doc = "< id of the global"]
    pub id: u32,
    #[doc = "< port direction"]
    pub direction: spa_direction,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the properties of the port"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_port_info"][::std::mem::size_of::<pw_port_info>() - 40usize];
    ["Alignment of pw_port_info"][::std::mem::align_of::<pw_port_info>() - 8usize];
    ["Offset of field: pw_port_info::id"][::std::mem::offset_of!(pw_port_info, id) - 0usize];
    ["Offset of field: pw_port_info::direction"]
        [::std::mem::offset_of!(pw_port_info, direction) - 4usize];
    ["Offset of field: pw_port_info::change_mask"]
        [::std::mem::offset_of!(pw_port_info, change_mask) - 8usize];
    ["Offset of field: pw_port_info::props"][::std::mem::offset_of!(pw_port_info, props) - 16usize];
    ["Offset of field: pw_port_info::params"]
        [::std::mem::offset_of!(pw_port_info, params) - 24usize];
    ["Offset of field: pw_port_info::n_params"]
        [::std::mem::offset_of!(pw_port_info, n_params) - 32usize];
};
unsafe extern "C" {
    pub fn pw_port_info_update(
        info: *mut pw_port_info,
        update: *const pw_port_info,
    ) -> *mut pw_port_info;
}
unsafe extern "C" {
    pub fn pw_port_info_merge(
        info: *mut pw_port_info,
        update: *const pw_port_info,
        reset: bool,
    ) -> *mut pw_port_info;
}
unsafe extern "C" {
    pub fn pw_port_info_free(info: *mut pw_port_info);
}
#[doc = " Port events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port_events {
    pub version: u32,
    #[doc = " Notify port info\n\n \\param info info about the port"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_port_info),
    >,
    #[doc = " Notify a port param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_port_events"][::std::mem::size_of::<pw_port_events>() - 24usize];
    ["Alignment of pw_port_events"][::std::mem::align_of::<pw_port_events>() - 8usize];
    ["Offset of field: pw_port_events::version"]
        [::std::mem::offset_of!(pw_port_events, version) - 0usize];
    ["Offset of field: pw_port_events::info"]
        [::std::mem::offset_of!(pw_port_events, info) - 8usize];
    ["Offset of field: pw_port_events::param"]
        [::std::mem::offset_of!(pw_port_events, param) - 16usize];
};
#[doc = " Port methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_port_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_port_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions on the port."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate port parameters\n\n Start enumeration of port parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions on the port."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_port_methods"][::std::mem::size_of::<pw_port_methods>() - 32usize];
    ["Alignment of pw_port_methods"][::std::mem::align_of::<pw_port_methods>() - 8usize];
    ["Offset of field: pw_port_methods::version"]
        [::std::mem::offset_of!(pw_port_methods, version) - 0usize];
    ["Offset of field: pw_port_methods::add_listener"]
        [::std::mem::offset_of!(pw_port_methods, add_listener) - 8usize];
    ["Offset of field: pw_port_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_port_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_port_methods::enum_params"]
        [::std::mem::offset_of!(pw_port_methods, enum_params) - 24usize];
};
#[doc = " \\addtogroup pw_stream\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_stream {
    _unused: [u8; 0],
}
#[doc = "< the stream is in error"]
pub const pw_stream_state_PW_STREAM_STATE_ERROR: pw_stream_state = -1;
#[doc = "< unconnected"]
pub const pw_stream_state_PW_STREAM_STATE_UNCONNECTED: pw_stream_state = 0;
#[doc = "< connection is in progress"]
pub const pw_stream_state_PW_STREAM_STATE_CONNECTING: pw_stream_state = 1;
#[doc = "< paused"]
pub const pw_stream_state_PW_STREAM_STATE_PAUSED: pw_stream_state = 2;
#[doc = "< streaming"]
pub const pw_stream_state_PW_STREAM_STATE_STREAMING: pw_stream_state = 3;
#[doc = " \\enum pw_stream_state The state of a stream"]
pub type pw_stream_state = ::std::os::raw::c_int;
#[doc = " a buffer structure obtained from pw_stream_dequeue_buffer(). The size of this\n structure can grow as more fields are added in the future"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_buffer {
    #[doc = "< the spa buffer"]
    pub buffer: *mut spa_buffer,
    #[doc = "< user data attached to the buffer. The user of\n  the stream can set custom data associated with the\n  buffer, typically in the add_buffer event. Any\n  cleanup should be performed in the remove_buffer\n  event. The user data is returned unmodified each\n  time a buffer is dequeued."]
    pub user_data: *mut ::std::os::raw::c_void,
    #[doc = "< This field is set by the user and the sum of\n  all queued buffers is returned in the time info.\n  For audio, it is advised to use the number of\n  frames in the buffer for this field."]
    pub size: u64,
    #[doc = "< For playback streams, this field contains the\n  suggested amount of data to provide. For audio\n  streams this will be the amount of frames\n  required by the resampler. This field is 0\n  when no suggestion is provided. Since 0.3.49"]
    pub requested: u64,
    #[doc = "< For capture streams, this field contains the\n  cycle time in nanoseconds when this buffer was\n  queued in the stream. It can be compared against\n  the pw_time values or pw_stream_get_nsec()\n  Since 1.0.5"]
    pub time: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_buffer"][::std::mem::size_of::<pw_buffer>() - 40usize];
    ["Alignment of pw_buffer"][::std::mem::align_of::<pw_buffer>() - 8usize];
    ["Offset of field: pw_buffer::buffer"][::std::mem::offset_of!(pw_buffer, buffer) - 0usize];
    ["Offset of field: pw_buffer::user_data"]
        [::std::mem::offset_of!(pw_buffer, user_data) - 8usize];
    ["Offset of field: pw_buffer::size"][::std::mem::offset_of!(pw_buffer, size) - 16usize];
    ["Offset of field: pw_buffer::requested"]
        [::std::mem::offset_of!(pw_buffer, requested) - 24usize];
    ["Offset of field: pw_buffer::time"][::std::mem::offset_of!(pw_buffer, time) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_stream_control {
    #[doc = "< name of the control"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = "< extra flags (unused)"]
    pub flags: u32,
    #[doc = "< default value"]
    pub def: f32,
    #[doc = "< min value"]
    pub min: f32,
    #[doc = "< max value"]
    pub max: f32,
    #[doc = "< array of values"]
    pub values: *mut f32,
    #[doc = "< number of values in array"]
    pub n_values: u32,
    #[doc = "< max values that can be set on this control"]
    pub max_values: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_stream_control"][::std::mem::size_of::<pw_stream_control>() - 40usize];
    ["Alignment of pw_stream_control"][::std::mem::align_of::<pw_stream_control>() - 8usize];
    ["Offset of field: pw_stream_control::name"]
        [::std::mem::offset_of!(pw_stream_control, name) - 0usize];
    ["Offset of field: pw_stream_control::flags"]
        [::std::mem::offset_of!(pw_stream_control, flags) - 8usize];
    ["Offset of field: pw_stream_control::def"]
        [::std::mem::offset_of!(pw_stream_control, def) - 12usize];
    ["Offset of field: pw_stream_control::min"]
        [::std::mem::offset_of!(pw_stream_control, min) - 16usize];
    ["Offset of field: pw_stream_control::max"]
        [::std::mem::offset_of!(pw_stream_control, max) - 20usize];
    ["Offset of field: pw_stream_control::values"]
        [::std::mem::offset_of!(pw_stream_control, values) - 24usize];
    ["Offset of field: pw_stream_control::n_values"]
        [::std::mem::offset_of!(pw_stream_control, n_values) - 32usize];
    ["Offset of field: pw_stream_control::max_values"]
        [::std::mem::offset_of!(pw_stream_control, max_values) - 36usize];
};
#[doc = " A time structure.\n\n Use pw_stream_get_time_n() to get an updated time snapshot of the stream.\n The time snapshot can give information about the time in the driver of the\n graph, the delay to the edge of the graph and the internal queuing in the\n stream.\n\n pw_time.ticks gives a monotonic increasing counter of the time in the graph\n driver. I can be used to generate a timetime to schedule samples as well\n as detect discontinuities in the timeline caused by xruns.\n\n pw_time.delay is expressed as pw_time.rate, the time domain of the graph. This\n value, and pw_time.ticks, were captured at pw_time.now and can be extrapolated\n to the current time like this:\n\n\\code{.c}\n    uint64_t now = pw_stream_get_nsec(stream);\n    int64_t diff = now - pw_time.now;\n    int64_t elapsed = (pw_time.rate.denom * diff) / (pw_time.rate.num * SPA_NSEC_PER_SEC);\n\\endcode\n\n pw_time.delay contains the total delay that a signal will travel through the\n graph. This includes the delay caused by filters in the graph as well as delays\n caused by the hardware. The delay is usually quite stable and should only change when\n the topology, quantum or samplerate of the graph changes.\n\n The delay requires the application to send the stream early relative to other synchronized\n streams in order to arrive at the edge of the graph in time. This is usually done by\n delaying the other streams with the given delay.\n\n Note that the delay can be negative. A negative delay means that this stream should be\n delayed with the (positive) delay relative to other streams.\n\n pw_time.queued and pw_time.buffered is expressed in the time domain of the stream,\n or the format that is used for the buffers of this stream.\n\n pw_time.queued is the sum of all the pw_buffer.size fields of the buffers that are\n currently queued in the stream but not yet processed. The application can choose\n the units of this value, for example, time, samples, frames or bytes (below\n expressed as app.rate).\n\n pw_time.buffered is format dependent, for audio/raw it contains the number of frames\n that are buffered inside the resampler/converter.\n\n The total delay of data in a stream is the sum of the queued and buffered data\n (not yet processed data) and the delay to the edge of the graph, usually a\n playback or capture device.\n\n For an audio playback stream, if you were to queue a buffer, the total delay\n in milliseconds for the first sample in the newly queued buffer to be played\n by the hardware can be calculated as:\n\n\\code{.unparsed}\n  (pw_time.buffered * 1000 / stream.samplerate) +\n    (pw_time.queued * 1000 / app.rate) +\n     ((pw_time.delay - elapsed) * 1000 * pw_time.rate.num / pw_time.rate.denom)\n\\endcode\n\n The current extrapolated time (in ms) in the source or sink can be calculated as:\n\n\\code{.unparsed}\n  (pw_time.ticks + elapsed) * 1000 * pw_time.rate.num / pw_time.rate.denom\n\\endcode\n\n Below is an overview of the different timing values:\n\n\\code{.unparsed}\n           stream time domain           graph time domain\n         /-----------------------\\/-----------------------------\\\n\n queue     +-+ +-+  +-----------+                 +--------+\n ---->     | | | |->| converter | ->   graph  ->  | kernel | -> speaker\n <----     +-+ +-+  +-----------+                 +--------+\n dequeue   buffers                \\-------------------/\\--------/\n                                     graph              internal\n                                    latency             latency\n         \\--------/\\-------------/\\-----------------------------/\n           queued      buffered            delay\n\\endcode"]
#[repr(C)]
pub struct pw_time {
    #[doc = "< the time in nanoseconds. This is the time when this\n  time report was updated. It is usually updated every\n  graph cycle. You can use pw_stream_get_nsec() to\n  calculate the elapsed time between this report and\n  the current time and calculate updated ticks and delay\n  values."]
    pub now: i64,
    #[doc = "< the rate of \\a ticks and delay. This is usually\n  expressed in 1/<samplerate>."]
    pub rate: spa_fraction,
    #[doc = "< the ticks at \\a now. This is the current time that\n  the remote end is reading/writing. This is monotonicaly\n  increasing."]
    pub ticks: u64,
    #[doc = "< delay to device. This is the time it will take for\n  the next output sample of the stream to be presented by\n  the playback device or the time a sample traveled\n  from the capture device. This delay includes the\n  delay introduced by all filters on the path between\n  the stream and the device. The delay is normally\n  constant in a graph and can change when the topology\n  of the graph or the quantum changes. This delay does\n  not include the delay caused by queued buffers."]
    pub delay: i64,
    #[doc = "< data queued in the stream, this is the sum\n  of the size fields in the pw_buffer that are\n  currently queued"]
    pub queued: u64,
    #[doc = "< for audio/raw streams, this contains the extra\n  number of frames buffered in the resampler.\n  Since 0.3.50."]
    pub buffered: u64,
    #[doc = "< the number of buffers that are queued. Since 0.3.50"]
    pub queued_buffers: u32,
    #[doc = "< the number of buffers that can be dequeued. Since 0.3.50"]
    pub avail_buffers: u32,
    #[doc = "< for audio/raw playback streams, this contains the number of\n  samples requested by the resampler for the current\n  quantum. for audio/raw capture streams this will be the number\n  of samples available for the current quantum. Since 1.1.0"]
    pub size: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_time"][::std::mem::size_of::<pw_time>() - 64usize];
    ["Alignment of pw_time"][::std::mem::align_of::<pw_time>() - 8usize];
    ["Offset of field: pw_time::now"][::std::mem::offset_of!(pw_time, now) - 0usize];
    ["Offset of field: pw_time::rate"][::std::mem::offset_of!(pw_time, rate) - 8usize];
    ["Offset of field: pw_time::ticks"][::std::mem::offset_of!(pw_time, ticks) - 16usize];
    ["Offset of field: pw_time::delay"][::std::mem::offset_of!(pw_time, delay) - 24usize];
    ["Offset of field: pw_time::queued"][::std::mem::offset_of!(pw_time, queued) - 32usize];
    ["Offset of field: pw_time::buffered"][::std::mem::offset_of!(pw_time, buffered) - 40usize];
    ["Offset of field: pw_time::queued_buffers"]
        [::std::mem::offset_of!(pw_time, queued_buffers) - 48usize];
    ["Offset of field: pw_time::avail_buffers"]
        [::std::mem::offset_of!(pw_time, avail_buffers) - 52usize];
    ["Offset of field: pw_time::size"][::std::mem::offset_of!(pw_time, size) - 56usize];
};
#[doc = " Events for a stream. These events are always called from the mainloop\n unless explicitly documented otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_stream_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " when the stream state changes. Since 1.4 this also sets errno when the\n new state is PW_STREAM_STATE_ERROR"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_stream_state,
            state: pw_stream_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " Notify information about a control."]
    pub control_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            control: *const pw_stream_control,
        ),
    >,
    #[doc = " when io changed on the stream."]
    pub io_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            area: *mut ::std::os::raw::c_void,
            size: u32,
        ),
    >,
    #[doc = " when a parameter changed"]
    pub param_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32, param: *const spa_pod),
    >,
    #[doc = " when a new buffer was created for this stream"]
    pub add_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, buffer: *mut pw_buffer),
    >,
    #[doc = " when a buffer was destroyed for this stream"]
    pub remove_buffer: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, buffer: *mut pw_buffer),
    >,
    #[doc = " when a buffer can be queued (for playback streams) or\n  dequeued (for capture streams). This is normally called from the\n  mainloop but can also be called directly from the realtime data\n  thread if the user is prepared to deal with this."]
    pub process: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The stream is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " A command notify, Since 0.3.39:1"]
    pub command: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, command: *const spa_command),
    >,
    #[doc = " a trigger_process completed. Since version 0.3.40:2.\n  This is normally called from the mainloop but since 1.1.0 it\n  can also be called directly from the realtime data\n  thread if the user is prepared to deal with this."]
    pub trigger_done:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_stream_events"][::std::mem::size_of::<pw_stream_events>() - 96usize];
    ["Alignment of pw_stream_events"][::std::mem::align_of::<pw_stream_events>() - 8usize];
    ["Offset of field: pw_stream_events::version"]
        [::std::mem::offset_of!(pw_stream_events, version) - 0usize];
    ["Offset of field: pw_stream_events::destroy"]
        [::std::mem::offset_of!(pw_stream_events, destroy) - 8usize];
    ["Offset of field: pw_stream_events::state_changed"]
        [::std::mem::offset_of!(pw_stream_events, state_changed) - 16usize];
    ["Offset of field: pw_stream_events::control_info"]
        [::std::mem::offset_of!(pw_stream_events, control_info) - 24usize];
    ["Offset of field: pw_stream_events::io_changed"]
        [::std::mem::offset_of!(pw_stream_events, io_changed) - 32usize];
    ["Offset of field: pw_stream_events::param_changed"]
        [::std::mem::offset_of!(pw_stream_events, param_changed) - 40usize];
    ["Offset of field: pw_stream_events::add_buffer"]
        [::std::mem::offset_of!(pw_stream_events, add_buffer) - 48usize];
    ["Offset of field: pw_stream_events::remove_buffer"]
        [::std::mem::offset_of!(pw_stream_events, remove_buffer) - 56usize];
    ["Offset of field: pw_stream_events::process"]
        [::std::mem::offset_of!(pw_stream_events, process) - 64usize];
    ["Offset of field: pw_stream_events::drained"]
        [::std::mem::offset_of!(pw_stream_events, drained) - 72usize];
    ["Offset of field: pw_stream_events::command"]
        [::std::mem::offset_of!(pw_stream_events, command) - 80usize];
    ["Offset of field: pw_stream_events::trigger_done"]
        [::std::mem::offset_of!(pw_stream_events, trigger_done) - 88usize];
};
unsafe extern "C" {
    #[doc = " Convert a stream state to a readable string"]
    pub fn pw_stream_state_as_string(state: pw_stream_state) -> *const ::std::os::raw::c_char;
}
#[doc = "< no flags"]
pub const pw_stream_flags_PW_STREAM_FLAG_NONE: pw_stream_flags = 0;
#[doc = "< try to automatically connect\n  this stream"]
pub const pw_stream_flags_PW_STREAM_FLAG_AUTOCONNECT: pw_stream_flags = 1;
#[doc = "< start the stream inactive,\n  pw_stream_set_active() needs to be\n  called explicitly"]
pub const pw_stream_flags_PW_STREAM_FLAG_INACTIVE: pw_stream_flags = 2;
#[doc = "< mmap the buffers except DmaBuf that is not\n  explicitly marked as mappable."]
pub const pw_stream_flags_PW_STREAM_FLAG_MAP_BUFFERS: pw_stream_flags = 4;
#[doc = "< be a driver"]
pub const pw_stream_flags_PW_STREAM_FLAG_DRIVER: pw_stream_flags = 8;
#[doc = "< call process from the realtime\n  thread. You MUST use RT safe functions\n  in the process callback."]
pub const pw_stream_flags_PW_STREAM_FLAG_RT_PROCESS: pw_stream_flags = 16;
#[doc = "< don't convert format"]
pub const pw_stream_flags_PW_STREAM_FLAG_NO_CONVERT: pw_stream_flags = 32;
#[doc = "< require exclusive access to the\n  device"]
pub const pw_stream_flags_PW_STREAM_FLAG_EXCLUSIVE: pw_stream_flags = 64;
#[doc = "< don't try to reconnect this stream\n  when the sink/source is removed"]
pub const pw_stream_flags_PW_STREAM_FLAG_DONT_RECONNECT: pw_stream_flags = 128;
#[doc = "< the application will allocate buffer\n  memory. In the add_buffer event, the\n  data of the buffer should be set"]
pub const pw_stream_flags_PW_STREAM_FLAG_ALLOC_BUFFERS: pw_stream_flags = 256;
#[doc = "< the output stream will not be scheduled\n  automatically but _trigger_process()\n  needs to be called. This can be used\n  when the output of the stream depends\n  on input from other streams."]
pub const pw_stream_flags_PW_STREAM_FLAG_TRIGGER: pw_stream_flags = 512;
#[doc = "< Buffers will not be dequeued/queued from\n  the realtime process() function. This is\n  assumed when RT_PROCESS is unset but can\n  also be the case when the process() function\n  does a trigger_process() that will then\n  dequeue/queue a buffer from another process()\n  function. since 0.3.73"]
pub const pw_stream_flags_PW_STREAM_FLAG_ASYNC: pw_stream_flags = 1024;
#[doc = "< Call process as soon as there is a buffer\n  to dequeue. This is only relevant for\n  playback and when not using RT_PROCESS. It\n  can be used to keep the maximum number of\n  buffers queued. Since 0.3.81"]
pub const pw_stream_flags_PW_STREAM_FLAG_EARLY_PROCESS: pw_stream_flags = 2048;
#[doc = "< Call trigger_done from the realtime\n  thread. You MUST use RT safe functions\n  in the trigger_done callback. Since 1.1.0"]
pub const pw_stream_flags_PW_STREAM_FLAG_RT_TRIGGER_DONE: pw_stream_flags = 4096;
#[doc = " \\enum pw_stream_flags Extra flags that can be used in \\ref pw_stream_connect()"]
pub type pw_stream_flags = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Create a new unconnected \\ref pw_stream\n \\return a newly allocated \\ref pw_stream"]
    pub fn pw_stream_new(
        core: *mut pw_core,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> *mut pw_stream;
}
unsafe extern "C" {
    pub fn pw_stream_new_simple(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
        events: *const pw_stream_events,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut pw_stream;
}
unsafe extern "C" {
    #[doc = " Destroy a stream"]
    pub fn pw_stream_destroy(stream: *mut pw_stream);
}
unsafe extern "C" {
    pub fn pw_stream_add_listener(
        stream: *mut pw_stream,
        listener: *mut spa_hook,
        events: *const pw_stream_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the current stream state. Since 1.4 this also sets errno when the\n state is PW_STREAM_STATE_ERROR"]
    pub fn pw_stream_get_state(
        stream: *mut pw_stream,
        error: *mut *const ::std::os::raw::c_char,
    ) -> pw_stream_state;
}
unsafe extern "C" {
    pub fn pw_stream_get_name(stream: *mut pw_stream) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_stream_get_core(stream: *mut pw_stream) -> *mut pw_core;
}
unsafe extern "C" {
    pub fn pw_stream_get_properties(stream: *mut pw_stream) -> *const pw_properties;
}
unsafe extern "C" {
    pub fn pw_stream_update_properties(
        stream: *mut pw_stream,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Connect a stream for input or output on \\a port_path.\n \\return 0 on success < 0 on error.\n\n You should connect to the process event and use pw_stream_dequeue_buffer()\n to get the latest metadata and data."]
    pub fn pw_stream_connect(
        stream: *mut pw_stream,
        direction: spa_direction,
        target_id: u32,
        flags: pw_stream_flags,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the node ID of the stream.\n \\return node ID."]
    pub fn pw_stream_get_node_id(stream: *mut pw_stream) -> u32;
}
unsafe extern "C" {
    #[doc = " Disconnect \\a stream"]
    pub fn pw_stream_disconnect(stream: *mut pw_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the stream in error state"]
    pub fn pw_stream_set_error(
        stream: *mut pw_stream,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update the param exposed on the stream."]
    pub fn pw_stream_update_params(
        stream: *mut pw_stream,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a parameter on the stream. This is like pw_stream_set_control() but with\n a complete spa_pod param. It can also be called from the param_changed event handler\n to intercept and modify the param for the adapter. Since 0.3.70"]
    pub fn pw_stream_set_param(
        stream: *mut pw_stream,
        id: u32,
        param: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get control values"]
    pub fn pw_stream_get_control(stream: *mut pw_stream, id: u32) -> *const pw_stream_control;
}
unsafe extern "C" {
    #[doc = " Set control values"]
    pub fn pw_stream_set_control(
        stream: *mut pw_stream,
        id: u32,
        n_values: u32,
        values: *mut f32,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query the time on the stream, RT safe"]
    pub fn pw_stream_get_time_n(
        stream: *mut pw_stream,
        time: *mut pw_time,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current time in nanoseconds. This value can be compared with\n the \\ref pw_time.now value. RT safe. Since 1.1.0"]
    pub fn pw_stream_get_nsec(stream: *mut pw_stream) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the data loop that is doing the processing of this stream. This loop\n is assigned after pw_stream_connect().  * Since 1.1.0"]
    pub fn pw_stream_get_data_loop(stream: *mut pw_stream) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Query the time on the stream, deprecated since 0.3.50,\n use pw_stream_get_time_n() to get the fields added since 0.3.50. RT safe."]
    pub fn pw_stream_get_time(stream: *mut pw_stream, time: *mut pw_time) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a buffer that can be filled for playback streams or consumed\n for capture streams. RT safe."]
    pub fn pw_stream_dequeue_buffer(stream: *mut pw_stream) -> *mut pw_buffer;
}
unsafe extern "C" {
    #[doc = " Submit a buffer for playback or recycle a buffer for capture. RT safe."]
    pub fn pw_stream_queue_buffer(
        stream: *mut pw_stream,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Return a buffer to the queue without using it. This makes the buffer\n immediately available to dequeue again. RT safe."]
    pub fn pw_stream_return_buffer(
        stream: *mut pw_stream,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Activate or deactivate the stream"]
    pub fn pw_stream_set_active(stream: *mut pw_stream, active: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Flush a stream. When \\a drain is true, the drained callback will\n be called when all data is played or recorded. The stream can be resumed\n after the drain by setting it active again with\n \\ref pw_stream_set_active(). A flush without a drain is mostly useful afer\n a state change to PAUSED, to flush any remaining data from the queues and\n the converters. RT safe."]
    pub fn pw_stream_flush(stream: *mut pw_stream, drain: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the stream is driving. The stream needs to have the\n PW_STREAM_FLAG_DRIVER set. When the stream is driving,\n pw_stream_trigger_process() needs to be called when data is\n available (output) or needed (input). Since 0.3.34"]
    pub fn pw_stream_is_driving(stream: *mut pw_stream) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if the graph is using lazy scheduling. If the stream is\n driving according to \\ref pw_stream_is_driving(), then it should\n consider taking into account the RequestProcess commands when\n driving the graph.\n\n If the stream is not driving, it should send out RequestProcess\n events with \\ref pw_stream_emit_event() or indirectly with\n \\ref pw_stream_trigger_process() to suggest a new graph cycle\n to the driver.\n\n It is not a requirement that all RequestProcess events/commands\n need to start a graph cycle.\n Since 1.4.0"]
    pub fn pw_stream_is_lazy(stream: *mut pw_stream) -> bool;
}
unsafe extern "C" {
    #[doc = " Trigger a push/pull on the stream. One iteration of the graph will\n be scheduled when the stream is driving according to\n \\ref pw_stream_is_driving(). If it successfully finishes, process()\n will be called and the trigger_done event will be emitted. It is\n possible for the graph iteration to not finish, so\n pw_stream_trigger_process() needs to be called again even if process()\n and trigger_done is not called.\n\n If there is a deadline after which the stream will have xrun,\n pw_stream_trigger_process() should be called then, whether or not\n process()/trigger_done has been called. Sound hardware will xrun if\n there is any delay in audio processing, so the ALSA plugin triggers the\n graph every quantum to ensure audio keeps flowing. Drivers that\n do not have a deadline, such as the freewheel driver, should\n use a timeout to ensure that forward progress keeps being made.\n A reasonable choice of deadline is three times the quantum: if\n the graph is taking 3x longer than normal, it is likely that it\n is hung and should be retriggered.\n\n Streams that are not drivers according to \\ref pw_stream_is_driving()\n can also call this method. The result is that a RequestProcess event\n is sent to the driver. If the graph is lazy scheduling according to\n \\ref pw_stream_is_lazy(), this might result in a graph cycle by the\n driver. If the graph is not lazy scheduling and the stream is not a\n driver, this method will have no effect.\n\n RT safe.\n\n Since 0.3.34"]
    pub fn pw_stream_trigger_process(stream: *mut pw_stream) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Emit an event from this stream. RT safe.\n Since 1.2.6"]
    pub fn pw_stream_emit_event(
        stream: *mut pw_stream,
        event: *const spa_event,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Adjust the rate of the stream.\n When the stream is using an adaptive resampler, adjust the resampler rate.\n When there is no resampler, -ENOTSUP is returned. Activating the adaptive\n resampler will add a small amount of delay to the samples, you can deactivate\n it again by setting a value <= 0.0. RT safe.\n Since 1.4.0"]
    pub fn pw_stream_set_rate(stream: *mut pw_stream, rate: f64) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup pw_filter\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_filter {
    _unused: [u8; 0],
}
#[doc = "< the stream is in error"]
pub const pw_filter_state_PW_FILTER_STATE_ERROR: pw_filter_state = -1;
#[doc = "< unconnected"]
pub const pw_filter_state_PW_FILTER_STATE_UNCONNECTED: pw_filter_state = 0;
#[doc = "< connection is in progress"]
pub const pw_filter_state_PW_FILTER_STATE_CONNECTING: pw_filter_state = 1;
#[doc = "< filter is connected and paused"]
pub const pw_filter_state_PW_FILTER_STATE_PAUSED: pw_filter_state = 2;
#[doc = "< filter is streaming"]
pub const pw_filter_state_PW_FILTER_STATE_STREAMING: pw_filter_state = 3;
#[doc = " \\enum pw_filter_state The state of a filter"]
pub type pw_filter_state = ::std::os::raw::c_int;
#[doc = " Events for a filter. These events are always called from the mainloop\n unless explicitly documented otherwise."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_filter_events {
    pub version: u32,
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " when the filter state changes. Since 1.4 this also sets errno when the\n new state is PW_FILTER_STATE_ERROR"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_filter_state,
            state: pw_filter_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " when io changed on a port of the filter (when port_data is NULL)."]
    pub io_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            id: u32,
            area: *mut ::std::os::raw::c_void,
            size: u32,
        ),
    >,
    #[doc = " when a parameter changed on a port of the filter (when port_data is NULL)."]
    pub param_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            id: u32,
            param: *const spa_pod,
        ),
    >,
    #[doc = " when a new buffer was created for a port"]
    pub add_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            buffer: *mut pw_buffer,
        ),
    >,
    #[doc = " when a buffer was destroyed for a port"]
    pub remove_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port_data: *mut ::std::os::raw::c_void,
            buffer: *mut pw_buffer,
        ),
    >,
    #[doc = " do processing. This is normally called from the\n  mainloop but can also be called directly from the realtime data\n  thread if the user is prepared to deal with this with the\n  PW_FILTER_FLAG_RT_PROCESS. Only call methods marked with RT safe\n  from this event when called from the realtime thread."]
    pub process: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, position: *mut spa_io_position),
    >,
    #[doc = " The filter is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " A command notify, Since 0.3.39:1"]
    pub command: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, command: *const spa_command),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_filter_events"][::std::mem::size_of::<pw_filter_events>() - 80usize];
    ["Alignment of pw_filter_events"][::std::mem::align_of::<pw_filter_events>() - 8usize];
    ["Offset of field: pw_filter_events::version"]
        [::std::mem::offset_of!(pw_filter_events, version) - 0usize];
    ["Offset of field: pw_filter_events::destroy"]
        [::std::mem::offset_of!(pw_filter_events, destroy) - 8usize];
    ["Offset of field: pw_filter_events::state_changed"]
        [::std::mem::offset_of!(pw_filter_events, state_changed) - 16usize];
    ["Offset of field: pw_filter_events::io_changed"]
        [::std::mem::offset_of!(pw_filter_events, io_changed) - 24usize];
    ["Offset of field: pw_filter_events::param_changed"]
        [::std::mem::offset_of!(pw_filter_events, param_changed) - 32usize];
    ["Offset of field: pw_filter_events::add_buffer"]
        [::std::mem::offset_of!(pw_filter_events, add_buffer) - 40usize];
    ["Offset of field: pw_filter_events::remove_buffer"]
        [::std::mem::offset_of!(pw_filter_events, remove_buffer) - 48usize];
    ["Offset of field: pw_filter_events::process"]
        [::std::mem::offset_of!(pw_filter_events, process) - 56usize];
    ["Offset of field: pw_filter_events::drained"]
        [::std::mem::offset_of!(pw_filter_events, drained) - 64usize];
    ["Offset of field: pw_filter_events::command"]
        [::std::mem::offset_of!(pw_filter_events, command) - 72usize];
};
unsafe extern "C" {
    #[doc = " Convert a filter state to a readable string"]
    pub fn pw_filter_state_as_string(state: pw_filter_state) -> *const ::std::os::raw::c_char;
}
#[doc = "< no flags"]
pub const pw_filter_flags_PW_FILTER_FLAG_NONE: pw_filter_flags = 0;
#[doc = "< start the filter inactive,\n  pw_filter_set_active() needs to be\n  called explicitly"]
pub const pw_filter_flags_PW_FILTER_FLAG_INACTIVE: pw_filter_flags = 1;
#[doc = "< be a driver"]
pub const pw_filter_flags_PW_FILTER_FLAG_DRIVER: pw_filter_flags = 2;
#[doc = "< call process from the realtime\n  thread. Only call methods marked as\n  RT safe."]
pub const pw_filter_flags_PW_FILTER_FLAG_RT_PROCESS: pw_filter_flags = 4;
#[doc = "< don't call the default latency algorithm\n  but emit the param_changed event for the\n  ports when Latency params are received."]
pub const pw_filter_flags_PW_FILTER_FLAG_CUSTOM_LATENCY: pw_filter_flags = 8;
#[doc = "< the filter will not be scheduled\n  automatically but _trigger_process()\n  needs to be called. This can be used\n  when the filter depends on processing\n  of other filters."]
pub const pw_filter_flags_PW_FILTER_FLAG_TRIGGER: pw_filter_flags = 16;
#[doc = "< Buffers will not be dequeued/queued from\n  the realtime process() function. This is\n  assumed when RT_PROCESS is unset but can\n  also be the case when the process() function\n  does a trigger_process() that will then\n  dequeue/queue a buffer from another process()\n  function. since 0.3.73"]
pub const pw_filter_flags_PW_FILTER_FLAG_ASYNC: pw_filter_flags = 32;
#[doc = " \\enum pw_filter_flags Extra flags that can be used in \\ref pw_filter_connect()"]
pub type pw_filter_flags = ::std::os::raw::c_uint;
#[doc = "< no flags"]
pub const pw_filter_port_flags_PW_FILTER_PORT_FLAG_NONE: pw_filter_port_flags = 0;
#[doc = "< mmap the buffers except DmaBuf that is not\n  explicitly marked as mappable."]
pub const pw_filter_port_flags_PW_FILTER_PORT_FLAG_MAP_BUFFERS: pw_filter_port_flags = 1;
#[doc = "< the application will allocate buffer\n  memory. In the add_buffer event, the\n  data of the buffer should be set"]
pub const pw_filter_port_flags_PW_FILTER_PORT_FLAG_ALLOC_BUFFERS: pw_filter_port_flags = 2;
pub type pw_filter_port_flags = ::std::os::raw::c_uint;
unsafe extern "C" {
    #[doc = " Create a new unconnected \\ref pw_filter\n \\return a newly allocated \\ref pw_filter"]
    pub fn pw_filter_new(
        core: *mut pw_core,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
    ) -> *mut pw_filter;
}
unsafe extern "C" {
    pub fn pw_filter_new_simple(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *mut pw_properties,
        events: *const pw_filter_events,
        data: *mut ::std::os::raw::c_void,
    ) -> *mut pw_filter;
}
unsafe extern "C" {
    #[doc = " Destroy a filter"]
    pub fn pw_filter_destroy(filter: *mut pw_filter);
}
unsafe extern "C" {
    pub fn pw_filter_add_listener(
        filter: *mut pw_filter,
        listener: *mut spa_hook,
        events: *const pw_filter_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the current filter state. Since 1.4 this also sets errno when the\n state is PW_FILTER_STATE_ERROR"]
    pub fn pw_filter_get_state(
        filter: *mut pw_filter,
        error: *mut *const ::std::os::raw::c_char,
    ) -> pw_filter_state;
}
unsafe extern "C" {
    pub fn pw_filter_get_name(filter: *mut pw_filter) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_filter_get_core(filter: *mut pw_filter) -> *mut pw_core;
}
unsafe extern "C" {
    #[doc = " Connect a filter for processing.\n \\return 0 on success < 0 on error.\n\n You should connect to the process event and use pw_filter_dequeue_buffer()\n to get the latest metadata and data."]
    pub fn pw_filter_connect(
        filter: *mut pw_filter,
        flags: pw_filter_flags,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the node ID of the filter.\n \\return node ID."]
    pub fn pw_filter_get_node_id(filter: *mut pw_filter) -> u32;
}
unsafe extern "C" {
    #[doc = " Disconnect \\a filter"]
    pub fn pw_filter_disconnect(filter: *mut pw_filter) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " add a port to the filter, returns user data of port_data_size."]
    pub fn pw_filter_add_port(
        filter: *mut pw_filter,
        direction: spa_direction,
        flags: pw_filter_port_flags,
        port_data_size: usize,
        props: *mut pw_properties,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " remove a port from the filter"]
    pub fn pw_filter_remove_port(port_data: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " get properties, port_data of NULL will give global properties"]
    pub fn pw_filter_get_properties(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
    ) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update properties, use NULL port_data for global filter properties"]
    pub fn pw_filter_update_properties(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the filter in error state"]
    pub fn pw_filter_set_error(
        filter: *mut pw_filter,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update params, use NULL port_data for global filter params"]
    pub fn pw_filter_update_params(
        filter: *mut pw_filter,
        port_data: *mut ::std::os::raw::c_void,
        params: *mut *const spa_pod,
        n_params: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Query the time on the filter, deprecated, use the spa_io_position in the\n process() method for timing information. RT safe."]
    pub fn pw_filter_get_time(filter: *mut pw_filter, time: *mut pw_time) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current time in nanoseconds. This value can be compared with\n the nsec value in the spa_io_position. RT safe. Since 1.1.0"]
    pub fn pw_filter_get_nsec(filter: *mut pw_filter) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the data loop that is doing the processing of this filter. This loop\n is assigned after pw_filter_connect(). Since 1.1.0"]
    pub fn pw_filter_get_data_loop(filter: *mut pw_filter) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Get a buffer that can be filled for output ports or consumed\n for input ports. RT safe."]
    pub fn pw_filter_dequeue_buffer(port_data: *mut ::std::os::raw::c_void) -> *mut pw_buffer;
}
unsafe extern "C" {
    #[doc = " Submit a buffer for playback or recycle a buffer for capture. RT safe."]
    pub fn pw_filter_queue_buffer(
        port_data: *mut ::std::os::raw::c_void,
        buffer: *mut pw_buffer,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a data pointer to the buffer data. RT safe."]
    pub fn pw_filter_get_dsp_buffer(
        port_data: *mut ::std::os::raw::c_void,
        n_samples: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Activate or deactivate the filter"]
    pub fn pw_filter_set_active(filter: *mut pw_filter, active: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Flush a filter. When \\a drain is true, the drained callback will\n be called when all data is played or recorded. The filter can be resumed\n after the drain by setting it active again with\n \\ref pw_filter_set_active(). A flush without a drain is mostly useful afer\n a state change to PAUSED, to flush any remaining data from the queues.\n RT safe."]
    pub fn pw_filter_flush(filter: *mut pw_filter, drain: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the filter is driving. The filter needs to have the\n PW_FILTER_FLAG_DRIVER set. When the filter is driving,\n pw_filter_trigger_process() needs to be called when data is\n available (output) or needed (input). Since 0.3.66"]
    pub fn pw_filter_is_driving(filter: *mut pw_filter) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if the graph is using lazy scheduling.\n Since 1.4.0"]
    pub fn pw_filter_is_lazy(filter: *mut pw_filter) -> bool;
}
unsafe extern "C" {
    #[doc = " Trigger a push/pull on the filter. One iteration of the graph will\n be scheduled and process() will be called. RT safe. Since 0.3.66"]
    pub fn pw_filter_trigger_process(filter: *mut pw_filter) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Emit an event from this filter. RT safe.\n Since 1.2.6"]
    pub fn pw_filter_emit_event(
        filter: *mut pw_filter,
        event: *const spa_event,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup pw_thread_loop\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_thread_loop {
    _unused: [u8; 0],
}
#[doc = " Thread loop events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_thread_loop_events {
    pub version: u32,
    #[doc = " the loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_thread_loop_events"][::std::mem::size_of::<pw_thread_loop_events>() - 16usize];
    ["Alignment of pw_thread_loop_events"]
        [::std::mem::align_of::<pw_thread_loop_events>() - 8usize];
    ["Offset of field: pw_thread_loop_events::version"]
        [::std::mem::offset_of!(pw_thread_loop_events, version) - 0usize];
    ["Offset of field: pw_thread_loop_events::destroy"]
        [::std::mem::offset_of!(pw_thread_loop_events, destroy) - 8usize];
};
unsafe extern "C" {
    #[doc = " Make a new thread loop with the given name and optional properties."]
    pub fn pw_thread_loop_new(
        name: *const ::std::os::raw::c_char,
        props: *const spa_dict,
    ) -> *mut pw_thread_loop;
}
unsafe extern "C" {
    #[doc = " Make a new thread loop with the given loop, name and optional properties.\n When \\a loop is NULL, a new loop will be created."]
    pub fn pw_thread_loop_new_full(
        loop_: *mut pw_loop,
        name: *const ::std::os::raw::c_char,
        props: *const spa_dict,
    ) -> *mut pw_thread_loop;
}
unsafe extern "C" {
    #[doc = " Destroy a thread loop"]
    pub fn pw_thread_loop_destroy(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_thread_loop_add_listener(
        loop_: *mut pw_thread_loop,
        listener: *mut spa_hook,
        events: *const pw_thread_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the loop implementation of the thread loop"]
    pub fn pw_thread_loop_get_loop(loop_: *mut pw_thread_loop) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Start the thread loop"]
    pub fn pw_thread_loop_start(loop_: *mut pw_thread_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop the thread loop"]
    pub fn pw_thread_loop_stop(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Lock the loop. This ensures exclusive ownership of the loop"]
    pub fn pw_thread_loop_lock(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Unlock the loop"]
    pub fn pw_thread_loop_unlock(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Release the lock and wait until some thread calls \\ref pw_thread_loop_signal"]
    pub fn pw_thread_loop_wait(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Release the lock and wait a maximum of 'wait_max_sec' seconds\n  until some thread calls \\ref pw_thread_loop_signal or time out"]
    pub fn pw_thread_loop_timed_wait(
        loop_: *mut pw_thread_loop,
        wait_max_sec: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get a struct timespec suitable for \\ref pw_thread_loop_timed_wait_full.\n Since: 0.3.7"]
    pub fn pw_thread_loop_get_time(
        loop_: *mut pw_thread_loop,
        abstime: *mut timespec,
        timeout: i64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Release the lock and wait up to \\a abstime until some thread calls\n \\ref pw_thread_loop_signal. Use \\ref pw_thread_loop_get_time to make a timeout.\n Since: 0.3.7"]
    pub fn pw_thread_loop_timed_wait_full(
        loop_: *mut pw_thread_loop,
        abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Signal all threads waiting with \\ref pw_thread_loop_wait"]
    pub fn pw_thread_loop_signal(loop_: *mut pw_thread_loop, wait_for_accept: bool);
}
unsafe extern "C" {
    #[doc = " Signal all threads executing \\ref pw_thread_loop_signal with wait_for_accept"]
    pub fn pw_thread_loop_accept(loop_: *mut pw_thread_loop);
}
unsafe extern "C" {
    #[doc = " Check if inside the thread"]
    pub fn pw_thread_loop_in_thread(loop_: *mut pw_thread_loop) -> bool;
}
#[doc = " Loop events, use \\ref pw_data_loop_add_listener to add a listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_data_loop_events {
    pub version: u32,
    #[doc = " The loop is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_data_loop_events"][::std::mem::size_of::<pw_data_loop_events>() - 16usize];
    ["Alignment of pw_data_loop_events"][::std::mem::align_of::<pw_data_loop_events>() - 8usize];
    ["Offset of field: pw_data_loop_events::version"]
        [::std::mem::offset_of!(pw_data_loop_events, version) - 0usize];
    ["Offset of field: pw_data_loop_events::destroy"]
        [::std::mem::offset_of!(pw_data_loop_events, destroy) - 8usize];
};
unsafe extern "C" {
    #[doc = " Make a new loop."]
    pub fn pw_data_loop_new(props: *const spa_dict) -> *mut pw_data_loop;
}
unsafe extern "C" {
    #[doc = " Add an event listener to loop"]
    pub fn pw_data_loop_add_listener(
        loop_: *mut pw_data_loop,
        listener: *mut spa_hook,
        events: *const pw_data_loop_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " wait for activity on the loop up to \\a timeout milliseconds.\n Should be called from the loop function"]
    pub fn pw_data_loop_wait(
        loop_: *mut pw_data_loop,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " make sure the thread will exit. Can be called from a loop callback"]
    pub fn pw_data_loop_exit(loop_: *mut pw_data_loop);
}
unsafe extern "C" {
    #[doc = " Get the loop implementation of this data loop"]
    pub fn pw_data_loop_get_loop(loop_: *mut pw_data_loop) -> *mut pw_loop;
}
unsafe extern "C" {
    #[doc = " Get the loop name. Since 1.1.0"]
    pub fn pw_data_loop_get_name(loop_: *mut pw_data_loop) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the loop class. Since 1.1.0"]
    pub fn pw_data_loop_get_class(loop_: *mut pw_data_loop) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Destroy the loop"]
    pub fn pw_data_loop_destroy(loop_: *mut pw_data_loop);
}
unsafe extern "C" {
    #[doc = " Start the processing thread"]
    pub fn pw_data_loop_start(loop_: *mut pw_data_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Stop the processing thread"]
    pub fn pw_data_loop_stop(loop_: *mut pw_data_loop) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if the current thread is the processing thread.\n May be called from any thread."]
    pub fn pw_data_loop_in_thread(loop_: *mut pw_data_loop) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the thread object"]
    pub fn pw_data_loop_get_thread(loop_: *mut pw_data_loop) -> *mut spa_thread;
}
unsafe extern "C" {
    #[doc = " invoke func in the context of the thread or in the caller thread when\n the loop is not running. May be called from the loop's thread, but otherwise\n can only be called by a single thread at a time.\n If called from the loop's thread, all callbacks previously queued with\n pw_data_loop_invoke() will be run synchronously, which might cause\n unexpected reentrancy problems.\n\n \\param[in] loop The loop to invoke func on.\n \\param func The function to be invoked.\n \\param seq A sequence number, opaque to PipeWire. This will be made\n            available to func.\n \\param[in] data Data that will be copied into the internal ring buffer and made\n             available to func. Because this data is copied, it is okay to\n             pass a pointer to a local variable, but do not pass a pointer to\n             an object that has identity.\n \\param size The size of data to copy.\n \\param block If \\true, do not return until func has been called. Otherwise,\n              returns immediately. Passing \\true does not risk a deadlock because\n              the data thread is never allowed to wait on any other thread.\n \\param user_data An opaque pointer passed to func.\n \\return `-EPIPE` if the internal ring buffer filled up,\n         if block is \\false, 0 is returned when seq is SPA_ID_INVALID or the\n         sequence number with the ASYNC bit set otherwise. When block is \\true,\n         the return value of func is returned.\n\n Since 0.3.3"]
    pub fn pw_data_loop_invoke(
        loop_: *mut pw_data_loop,
        func: spa_invoke_func_t,
        seq: u32,
        data: *const ::std::os::raw::c_void,
        size: usize,
        block: bool,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a custom spa_thread_utils for this loop. Setting NULL restores the\n system default implementation. Since 0.3.50"]
    pub fn pw_data_loop_set_thread_utils(loop_: *mut pw_data_loop, impl_: *mut spa_thread_utils);
}
unsafe extern "C" {
    #[doc = " Return the version of the library the current application is\n linked to."]
    pub fn pw_get_library_version() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Return TRUE if the currently linked PipeWire library version is equal\n or newer than the specified version. Since 0.3.75"]
    pub fn pw_check_library_version(
        major: ::std::os::raw::c_int,
        minor: ::std::os::raw::c_int,
        micro: ::std::os::raw::c_int,
    ) -> bool;
}
unsafe extern "C" {
    #[doc = " \\addtogroup pw_pipewire\n \\{"]
    pub fn pw_init(argc: *mut ::std::os::raw::c_int, argv: *mut *mut *mut ::std::os::raw::c_char);
}
unsafe extern "C" {
    pub fn pw_deinit();
}
unsafe extern "C" {
    pub fn pw_debug_is_category_enabled(name: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    pub fn pw_get_application_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_prgname() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_user_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_host_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_client_name() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_check_option(
        option: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> bool;
}
unsafe extern "C" {
    pub fn pw_direction_reverse(direction: spa_direction) -> spa_direction;
}
unsafe extern "C" {
    pub fn pw_set_domain(domain: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_get_domain() -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    pub fn pw_get_support(support: *mut spa_support, max_support: u32) -> u32;
}
unsafe extern "C" {
    pub fn pw_load_spa_handle(
        lib: *const ::std::os::raw::c_char,
        factory_name: *const ::std::os::raw::c_char,
        info: *const spa_dict,
        n_support: u32,
        support: *const spa_support,
    ) -> *mut spa_handle;
}
unsafe extern "C" {
    pub fn pw_unload_spa_handle(handle: *mut spa_handle) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node {
    _unused: [u8; 0],
}
#[doc = " information about a buffer"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node_buffer {
    #[doc = "< the memory id for the metadata"]
    pub mem_id: u32,
    #[doc = "< offset in memory"]
    pub offset: u32,
    #[doc = "< size in memory"]
    pub size: u32,
    #[doc = "< buffer describing metadata and buffer memory"]
    pub buffer: *mut spa_buffer,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_node_buffer"][::std::mem::size_of::<pw_client_node_buffer>() - 24usize];
    ["Alignment of pw_client_node_buffer"]
        [::std::mem::align_of::<pw_client_node_buffer>() - 8usize];
    ["Offset of field: pw_client_node_buffer::mem_id"]
        [::std::mem::offset_of!(pw_client_node_buffer, mem_id) - 0usize];
    ["Offset of field: pw_client_node_buffer::offset"]
        [::std::mem::offset_of!(pw_client_node_buffer, offset) - 4usize];
    ["Offset of field: pw_client_node_buffer::size"]
        [::std::mem::offset_of!(pw_client_node_buffer, size) - 8usize];
    ["Offset of field: pw_client_node_buffer::buffer"]
        [::std::mem::offset_of!(pw_client_node_buffer, buffer) - 16usize];
};
#[doc = " \\ref pw_client_node events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node_events {
    pub version: u32,
    #[doc = " Notify of a new transport area\n\n The transport area is used to signal the client and the server.\n\n \\param readfd fd for signal data can be read\n \\param writefd fd for signal data can be written\n \\param mem_id id for activation memory\n \\param offset offset of activation memory\n \\param size size of activation memory"]
    pub transport: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            readfd: ::std::os::raw::c_int,
            writefd: ::std::os::raw::c_int,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify of a property change\n\n When the server configures the properties on the node\n this event is sent\n\n \\param id the id of the parameter\n \\param flags parameter flags\n \\param param the param to set"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure an IO area for the client\n\n IO areas are identified with an id and are used to\n exchange state between client and server\n\n \\param id the id of the io area\n \\param mem_id the id of the memory to use\n \\param offset offset of io area in memory\n \\param size size of the io area"]
    pub set_io: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Receive an event from the client node\n \\param event the received event"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            event: *const spa_event,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify of a new node command\n\n \\param command the command"]
    pub command: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            command: *const spa_command,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A new port was added to the node\n\n The server can at any time add a port to the node when there\n are free ports available.\n\n \\param direction the direction of the port\n \\param port_id the new port id\n \\param props extra properties"]
    pub add_port: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A port was removed from the node\n\n \\param direction a port direction\n \\param port_id the remove port id"]
    pub remove_port: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " A parameter was configured on the port\n\n \\param direction a port direction\n \\param port_id the port id\n \\param id the id of the parameter\n \\param flags flags used when setting the param\n \\param param the new param"]
    pub port_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify the port of buffers\n\n \\param direction a port direction\n \\param port_id the port id\n \\param mix_id the mixer port id\n \\param n_buffer the number of buffers\n \\param buffers and array of buffer descriptions"]
    pub port_use_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            flags: u32,
            n_buffers: u32,
            buffers: *mut pw_client_node_buffer,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Configure the io area with \\a id of \\a port_id.\n\n \\param direction the direction of the port\n \\param port_id the port id\n \\param mix_id the mixer port id\n \\param id the id of the io area to set\n \\param mem_id the id of the memory to use\n \\param offset offset of io area in memory\n \\param size size of the io area"]
    pub port_set_io: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            id: u32,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify the activation record of the next\n node to trigger\n\n \\param node_id the peer node id\n \\param signalfd the fd to wake up the peer\n \\param mem_id the mem id of the memory\n \\param the offset in \\a mem_id to map\n \\param the size of \\a mem_id to map"]
    pub set_activation: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            node_id: u32,
            signalfd: ::std::os::raw::c_int,
            mem_id: u32,
            offset: u32,
            size: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Notify about the peer of mix_id\n\n \\param direction the direction of the port\n \\param port_id the port id\n \\param mix_id the mix id\n \\param peer_id the id of the peer port\n \\param props extra properties\n\n Since version 4:1"]
    pub port_set_mix_info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            peer_id: u32,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_node_events"][::std::mem::size_of::<pw_client_node_events>() - 104usize];
    ["Alignment of pw_client_node_events"]
        [::std::mem::align_of::<pw_client_node_events>() - 8usize];
    ["Offset of field: pw_client_node_events::version"]
        [::std::mem::offset_of!(pw_client_node_events, version) - 0usize];
    ["Offset of field: pw_client_node_events::transport"]
        [::std::mem::offset_of!(pw_client_node_events, transport) - 8usize];
    ["Offset of field: pw_client_node_events::set_param"]
        [::std::mem::offset_of!(pw_client_node_events, set_param) - 16usize];
    ["Offset of field: pw_client_node_events::set_io"]
        [::std::mem::offset_of!(pw_client_node_events, set_io) - 24usize];
    ["Offset of field: pw_client_node_events::event"]
        [::std::mem::offset_of!(pw_client_node_events, event) - 32usize];
    ["Offset of field: pw_client_node_events::command"]
        [::std::mem::offset_of!(pw_client_node_events, command) - 40usize];
    ["Offset of field: pw_client_node_events::add_port"]
        [::std::mem::offset_of!(pw_client_node_events, add_port) - 48usize];
    ["Offset of field: pw_client_node_events::remove_port"]
        [::std::mem::offset_of!(pw_client_node_events, remove_port) - 56usize];
    ["Offset of field: pw_client_node_events::port_set_param"]
        [::std::mem::offset_of!(pw_client_node_events, port_set_param) - 64usize];
    ["Offset of field: pw_client_node_events::port_use_buffers"]
        [::std::mem::offset_of!(pw_client_node_events, port_use_buffers) - 72usize];
    ["Offset of field: pw_client_node_events::port_set_io"]
        [::std::mem::offset_of!(pw_client_node_events, port_set_io) - 80usize];
    ["Offset of field: pw_client_node_events::set_activation"]
        [::std::mem::offset_of!(pw_client_node_events, set_activation) - 88usize];
    ["Offset of field: pw_client_node_events::port_set_mix_info"]
        [::std::mem::offset_of!(pw_client_node_events, port_set_mix_info) - 96usize];
};
#[doc = " \\ref pw_client_node methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_node_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_node_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " get the node object"]
    pub get_node: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            version: u32,
            user_data_size: usize,
        ) -> *mut pw_node,
    >,
    #[doc = " Update the node ports and properties\n\n Update the maximum number of ports and the params of the\n client node.\n \\param change_mask bitfield with changed parameters\n \\param max_input_ports new max input ports\n \\param max_output_ports new max output ports\n \\param params new params"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const spa_node_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update a node port\n\n Update the information of one port of a node.\n \\param direction the direction of the port\n \\param port_id the port id to update\n \\param change_mask a bitfield of changed items\n \\param n_params number of port parameters\n \\param params array of port parameters\n \\param info port information"]
    pub port_update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const spa_port_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Activate or deactivate the node"]
    pub set_active: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            active: bool,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send an event to the node\n \\param event the event to send"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            event: *const spa_event,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Send allocated buffers"]
    pub port_buffers: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            direction: spa_direction,
            port_id: u32,
            mix_id: u32,
            n_buffers: u32,
            buffers: *mut *mut spa_buffer,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_node_methods"][::std::mem::size_of::<pw_client_node_methods>() - 64usize];
    ["Alignment of pw_client_node_methods"]
        [::std::mem::align_of::<pw_client_node_methods>() - 8usize];
    ["Offset of field: pw_client_node_methods::version"]
        [::std::mem::offset_of!(pw_client_node_methods, version) - 0usize];
    ["Offset of field: pw_client_node_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_node_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_node_methods::get_node"]
        [::std::mem::offset_of!(pw_client_node_methods, get_node) - 16usize];
    ["Offset of field: pw_client_node_methods::update"]
        [::std::mem::offset_of!(pw_client_node_methods, update) - 24usize];
    ["Offset of field: pw_client_node_methods::port_update"]
        [::std::mem::offset_of!(pw_client_node_methods, port_update) - 32usize];
    ["Offset of field: pw_client_node_methods::set_active"]
        [::std::mem::offset_of!(pw_client_node_methods, set_active) - 40usize];
    ["Offset of field: pw_client_node_methods::event"]
        [::std::mem::offset_of!(pw_client_node_methods, event) - 48usize];
    ["Offset of field: pw_client_node_methods::port_buffers"]
        [::std::mem::offset_of!(pw_client_node_methods, port_buffers) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_metadata {
    _unused: [u8; 0],
}
#[doc = " \\ref pw_metadata events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_metadata_events {
    pub version: u32,
    pub property: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            subject: u32,
            key: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_metadata_events"][::std::mem::size_of::<pw_metadata_events>() - 16usize];
    ["Alignment of pw_metadata_events"][::std::mem::align_of::<pw_metadata_events>() - 8usize];
    ["Offset of field: pw_metadata_events::version"]
        [::std::mem::offset_of!(pw_metadata_events, version) - 0usize];
    ["Offset of field: pw_metadata_events::property"]
        [::std::mem::offset_of!(pw_metadata_events, property) - 8usize];
};
#[doc = " \\ref pw_metadata methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_metadata_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_metadata_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a metadata property\n\n Automatically emit property events for the subject and key\n when they are changed.\n\n \\param subject the id of the global to associate the metadata\n                with.\n \\param key the key of the metadata, NULL clears all metadata for\n                the subject.\n \\param type the type of the metadata, this can be blank\n \\param value the metadata value. NULL clears the metadata.\n\n This requires X and W permissions on the metadata. It also\n requires M permissions on the subject global."]
    pub set_property: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            subject: u32,
            key: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Clear all metadata\n\n This requires X and W permissions on the metadata."]
    pub clear: ::std::option::Option<
        unsafe extern "C" fn(object: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_metadata_methods"][::std::mem::size_of::<pw_metadata_methods>() - 32usize];
    ["Alignment of pw_metadata_methods"][::std::mem::align_of::<pw_metadata_methods>() - 8usize];
    ["Offset of field: pw_metadata_methods::version"]
        [::std::mem::offset_of!(pw_metadata_methods, version) - 0usize];
    ["Offset of field: pw_metadata_methods::add_listener"]
        [::std::mem::offset_of!(pw_metadata_methods, add_listener) - 8usize];
    ["Offset of field: pw_metadata_methods::set_property"]
        [::std::mem::offset_of!(pw_metadata_methods, set_property) - 16usize];
    ["Offset of field: pw_metadata_methods::clear"]
        [::std::mem::offset_of!(pw_metadata_methods, clear) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_profiler {
    _unused: [u8; 0],
}
#[doc = " \\ref pw_profiler events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_profiler_events {
    pub version: u32,
    pub profile: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, pod: *const spa_pod),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_profiler_events"][::std::mem::size_of::<pw_profiler_events>() - 16usize];
    ["Alignment of pw_profiler_events"][::std::mem::align_of::<pw_profiler_events>() - 8usize];
    ["Offset of field: pw_profiler_events::version"]
        [::std::mem::offset_of!(pw_profiler_events, version) - 0usize];
    ["Offset of field: pw_profiler_events::profile"]
        [::std::mem::offset_of!(pw_profiler_events, profile) - 8usize];
};
#[doc = " \\ref pw_profiler methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_profiler_methods {
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_profiler_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_profiler_methods"][::std::mem::size_of::<pw_profiler_methods>() - 16usize];
    ["Alignment of pw_profiler_methods"][::std::mem::align_of::<pw_profiler_methods>() - 8usize];
    ["Offset of field: pw_profiler_methods::version"]
        [::std::mem::offset_of!(pw_profiler_methods, version) - 0usize];
    ["Offset of field: pw_profiler_methods::add_listener"]
        [::std::mem::offset_of!(pw_profiler_methods, add_listener) - 8usize];
};
#[doc = " \\addtogroup pw_resource\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_resource {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_impl_module\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_module {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_impl_port\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_port {
    _unused: [u8; 0],
}
#[doc = " \\addtogroup pw_control\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_control {
    _unused: [u8; 0],
}
#[doc = " Port events, use \\ref pw_control_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_control_events {
    pub version: u32,
    #[doc = " The control is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The control is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " control is linked to another control"]
    pub linked: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, other: *mut pw_control),
    >,
    #[doc = " control is unlinked from another control"]
    pub unlinked: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, other: *mut pw_control),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_control_events"][::std::mem::size_of::<pw_control_events>() - 40usize];
    ["Alignment of pw_control_events"][::std::mem::align_of::<pw_control_events>() - 8usize];
    ["Offset of field: pw_control_events::version"]
        [::std::mem::offset_of!(pw_control_events, version) - 0usize];
    ["Offset of field: pw_control_events::destroy"]
        [::std::mem::offset_of!(pw_control_events, destroy) - 8usize];
    ["Offset of field: pw_control_events::free"]
        [::std::mem::offset_of!(pw_control_events, free) - 16usize];
    ["Offset of field: pw_control_events::linked"]
        [::std::mem::offset_of!(pw_control_events, linked) - 24usize];
    ["Offset of field: pw_control_events::unlinked"]
        [::std::mem::offset_of!(pw_control_events, unlinked) - 32usize];
};
unsafe extern "C" {
    #[doc = " Get the control parent port or NULL when not set"]
    pub fn pw_control_get_port(control: *mut pw_control) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Add an event listener on the control. May be called multiple times.\n Each listener must be removed, but they may be removed in any order."]
    pub fn pw_control_add_listener(
        control: *mut pw_control,
        listener: *mut spa_hook,
        events: *const pw_control_events,
        data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " \\addtogroup pw_impl_core\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_core {
    _unused: [u8; 0],
}
#[doc = " Factory events, listen to them with \\ref pw_impl_core_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_core_events {
    pub version: u32,
    #[doc = " the core is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the core is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the core is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_core_events"][::std::mem::size_of::<pw_impl_core_events>() - 32usize];
    ["Alignment of pw_impl_core_events"][::std::mem::align_of::<pw_impl_core_events>() - 8usize];
    ["Offset of field: pw_impl_core_events::version"]
        [::std::mem::offset_of!(pw_impl_core_events, version) - 0usize];
    ["Offset of field: pw_impl_core_events::destroy"]
        [::std::mem::offset_of!(pw_impl_core_events, destroy) - 8usize];
    ["Offset of field: pw_impl_core_events::free"]
        [::std::mem::offset_of!(pw_impl_core_events, free) - 16usize];
    ["Offset of field: pw_impl_core_events::initialized"]
        [::std::mem::offset_of!(pw_impl_core_events, initialized) - 24usize];
};
unsafe extern "C" {
    pub fn pw_context_create_core(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_core;
}
unsafe extern "C" {
    pub fn pw_context_get_default_core(context: *mut pw_context) -> *mut pw_impl_core;
}
unsafe extern "C" {
    #[doc = " Get the core properties"]
    pub fn pw_impl_core_get_properties(core: *mut pw_impl_core) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Get the core information"]
    pub fn pw_impl_core_get_info(core: *mut pw_impl_core) -> *const pw_core_info;
}
unsafe extern "C" {
    #[doc = " Update the core properties"]
    pub fn pw_impl_core_update_properties(
        core: *mut pw_impl_core,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_core_register(
        core: *mut pw_impl_core,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_core_destroy(core: *mut pw_impl_core);
}
unsafe extern "C" {
    pub fn pw_impl_core_get_user_data(core: *mut pw_impl_core) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the global of this core"]
    pub fn pw_impl_core_get_global(core: *mut pw_impl_core) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_core_add_listener(
        core: *mut pw_impl_core,
        listener: *mut spa_hook,
        events: *const pw_impl_core_events,
        data: *mut ::std::os::raw::c_void,
    );
}
#[doc = " \\addtogroup pw_impl_device\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_device {
    _unused: [u8; 0],
}
#[doc = " Device events, listen to them with \\ref pw_impl_device_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_device_events {
    pub version: u32,
    #[doc = " the device is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the device is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the device is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the device info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_device_info),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_device_events"][::std::mem::size_of::<pw_impl_device_events>() - 40usize];
    ["Alignment of pw_impl_device_events"]
        [::std::mem::align_of::<pw_impl_device_events>() - 8usize];
    ["Offset of field: pw_impl_device_events::version"]
        [::std::mem::offset_of!(pw_impl_device_events, version) - 0usize];
    ["Offset of field: pw_impl_device_events::destroy"]
        [::std::mem::offset_of!(pw_impl_device_events, destroy) - 8usize];
    ["Offset of field: pw_impl_device_events::free"]
        [::std::mem::offset_of!(pw_impl_device_events, free) - 16usize];
    ["Offset of field: pw_impl_device_events::initialized"]
        [::std::mem::offset_of!(pw_impl_device_events, initialized) - 24usize];
    ["Offset of field: pw_impl_device_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_device_events, info_changed) - 32usize];
};
unsafe extern "C" {
    pub fn pw_context_create_device(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_device;
}
unsafe extern "C" {
    pub fn pw_impl_device_register(
        device: *mut pw_impl_device,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_device_destroy(device: *mut pw_impl_device);
}
unsafe extern "C" {
    pub fn pw_impl_device_get_user_data(device: *mut pw_impl_device)
    -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Set the device implementation"]
    pub fn pw_impl_device_set_implementation(
        device: *mut pw_impl_device,
        spa_device: *mut spa_device,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the device implementation"]
    pub fn pw_impl_device_get_implementation(device: *mut pw_impl_device) -> *mut spa_device;
}
unsafe extern "C" {
    #[doc = " Get the global of this device"]
    pub fn pw_impl_device_get_global(device: *mut pw_impl_device) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_device_add_listener(
        device: *mut pw_impl_device,
        listener: *mut spa_hook,
        events: *const pw_impl_device_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_device_update_properties(
        device: *mut pw_impl_device,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_device_get_properties(device: *mut pw_impl_device) -> *const pw_properties;
}
unsafe extern "C" {
    pub fn pw_impl_device_for_each_param(
        device: *mut pw_impl_device,
        seq: ::std::os::raw::c_int,
        param_id: u32,
        index: u32,
        max: u32,
        filter: *const spa_pod,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                seq: ::std::os::raw::c_int,
                id: u32,
                index: u32,
                next: u32,
                param: *mut spa_pod,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\addtogroup pw_impl_factory\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_factory {
    _unused: [u8; 0],
}
#[doc = " Factory events, listen to them with \\ref pw_impl_factory_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_factory_events {
    pub version: u32,
    #[doc = " the factory is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the factory is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the factory is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_factory_events"][::std::mem::size_of::<pw_impl_factory_events>() - 32usize];
    ["Alignment of pw_impl_factory_events"]
        [::std::mem::align_of::<pw_impl_factory_events>() - 8usize];
    ["Offset of field: pw_impl_factory_events::version"]
        [::std::mem::offset_of!(pw_impl_factory_events, version) - 0usize];
    ["Offset of field: pw_impl_factory_events::destroy"]
        [::std::mem::offset_of!(pw_impl_factory_events, destroy) - 8usize];
    ["Offset of field: pw_impl_factory_events::free"]
        [::std::mem::offset_of!(pw_impl_factory_events, free) - 16usize];
    ["Offset of field: pw_impl_factory_events::initialized"]
        [::std::mem::offset_of!(pw_impl_factory_events, initialized) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_factory_implementation {
    pub version: u32,
    #[doc = " The function to create an object from this factory"]
    pub create_object: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            resource: *mut pw_resource,
            type_: *const ::std::os::raw::c_char,
            version: u32,
            properties: *mut pw_properties,
            new_id: u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_factory_implementation"]
        [::std::mem::size_of::<pw_impl_factory_implementation>() - 16usize];
    ["Alignment of pw_impl_factory_implementation"]
        [::std::mem::align_of::<pw_impl_factory_implementation>() - 8usize];
    ["Offset of field: pw_impl_factory_implementation::version"]
        [::std::mem::offset_of!(pw_impl_factory_implementation, version) - 0usize];
    ["Offset of field: pw_impl_factory_implementation::create_object"]
        [::std::mem::offset_of!(pw_impl_factory_implementation, create_object) - 8usize];
};
unsafe extern "C" {
    pub fn pw_context_create_factory(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_factory;
}
unsafe extern "C" {
    #[doc = " Get the factory properties"]
    pub fn pw_impl_factory_get_properties(factory: *mut pw_impl_factory) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Get the factory info"]
    pub fn pw_impl_factory_get_info(factory: *mut pw_impl_factory) -> *const pw_factory_info;
}
unsafe extern "C" {
    #[doc = " Update the factory properties"]
    pub fn pw_impl_factory_update_properties(
        factory: *mut pw_impl_factory,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_factory_register(
        factory: *mut pw_impl_factory,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_factory_destroy(factory: *mut pw_impl_factory);
}
unsafe extern "C" {
    pub fn pw_impl_factory_get_user_data(
        factory: *mut pw_impl_factory,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the global of this factory"]
    pub fn pw_impl_factory_get_global(factory: *mut pw_impl_factory) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_factory_add_listener(
        factory: *mut pw_impl_factory,
        listener: *mut spa_hook,
        events: *const pw_impl_factory_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_factory_set_implementation(
        factory: *mut pw_impl_factory,
        implementation: *const pw_impl_factory_implementation,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_factory_create_object(
        factory: *mut pw_impl_factory,
        resource: *mut pw_resource,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        properties: *mut pw_properties,
        new_id: u32,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Find a factory by name"]
    pub fn pw_context_find_factory(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
    ) -> *mut pw_impl_factory;
}
#[doc = " \\addtogroup pw_impl_link\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_link {
    _unused: [u8; 0],
}
#[doc = " link events added with \\ref pw_impl_link_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_link_events {
    pub version: u32,
    #[doc = " A link is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " A link is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a Link is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The info changed on a link"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_link_info),
    >,
    #[doc = " The link state changed, \\a error is only valid when the state is\n in error."]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_link_state,
            state: pw_link_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " A port is unlinked"]
    pub port_unlinked: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_link_events"][::std::mem::size_of::<pw_impl_link_events>() - 56usize];
    ["Alignment of pw_impl_link_events"][::std::mem::align_of::<pw_impl_link_events>() - 8usize];
    ["Offset of field: pw_impl_link_events::version"]
        [::std::mem::offset_of!(pw_impl_link_events, version) - 0usize];
    ["Offset of field: pw_impl_link_events::destroy"]
        [::std::mem::offset_of!(pw_impl_link_events, destroy) - 8usize];
    ["Offset of field: pw_impl_link_events::free"]
        [::std::mem::offset_of!(pw_impl_link_events, free) - 16usize];
    ["Offset of field: pw_impl_link_events::initialized"]
        [::std::mem::offset_of!(pw_impl_link_events, initialized) - 24usize];
    ["Offset of field: pw_impl_link_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_link_events, info_changed) - 32usize];
    ["Offset of field: pw_impl_link_events::state_changed"]
        [::std::mem::offset_of!(pw_impl_link_events, state_changed) - 40usize];
    ["Offset of field: pw_impl_link_events::port_unlinked"]
        [::std::mem::offset_of!(pw_impl_link_events, port_unlinked) - 48usize];
};
unsafe extern "C" {
    #[doc = " Make a new link between two ports\n \\return a newly allocated link"]
    pub fn pw_context_create_link(
        context: *mut pw_context,
        output: *mut pw_impl_port,
        input: *mut pw_impl_port,
        format_filter: *mut spa_pod,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_link;
}
unsafe extern "C" {
    #[doc = " Destroy a link"]
    pub fn pw_impl_link_destroy(link: *mut pw_impl_link);
}
unsafe extern "C" {
    #[doc = " Add an event listener to \\a link"]
    pub fn pw_impl_link_add_listener(
        link: *mut pw_impl_link,
        listener: *mut spa_hook,
        events: *const pw_impl_link_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Finish link configuration and register"]
    pub fn pw_impl_link_register(
        link: *mut pw_impl_link,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the context of a link"]
    pub fn pw_impl_link_get_context(link: *mut pw_impl_link) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the user_data of a link, the size of the memory is given when\n constructing the link"]
    pub fn pw_impl_link_get_user_data(link: *mut pw_impl_link) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the link info"]
    pub fn pw_impl_link_get_info(link: *mut pw_impl_link) -> *const pw_link_info;
}
unsafe extern "C" {
    #[doc = " Get the global of the link"]
    pub fn pw_impl_link_get_global(link: *mut pw_impl_link) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the output port of the link"]
    pub fn pw_impl_link_get_output(link: *mut pw_impl_link) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Get the input port of the link"]
    pub fn pw_impl_link_get_input(link: *mut pw_impl_link) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Find the link between 2 ports"]
    pub fn pw_impl_link_find(
        output: *mut pw_impl_port,
        input: *mut pw_impl_port,
    ) -> *mut pw_impl_link;
}
#[doc = " \\addtogroup pw_impl_metadata\n \\{"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_metadata {
    _unused: [u8; 0],
}
#[doc = " Metadata events, listen to them with \\ref pw_impl_metadata_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_metadata_events {
    pub version: u32,
    #[doc = " the metadata is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the metadata is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a property changed"]
    pub property: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            subject: u32,
            key: *const ::std::os::raw::c_char,
            type_: *const ::std::os::raw::c_char,
            value: *const ::std::os::raw::c_char,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_metadata_events"][::std::mem::size_of::<pw_impl_metadata_events>() - 32usize];
    ["Alignment of pw_impl_metadata_events"]
        [::std::mem::align_of::<pw_impl_metadata_events>() - 8usize];
    ["Offset of field: pw_impl_metadata_events::version"]
        [::std::mem::offset_of!(pw_impl_metadata_events, version) - 0usize];
    ["Offset of field: pw_impl_metadata_events::destroy"]
        [::std::mem::offset_of!(pw_impl_metadata_events, destroy) - 8usize];
    ["Offset of field: pw_impl_metadata_events::free"]
        [::std::mem::offset_of!(pw_impl_metadata_events, free) - 16usize];
    ["Offset of field: pw_impl_metadata_events::property"]
        [::std::mem::offset_of!(pw_impl_metadata_events, property) - 24usize];
};
unsafe extern "C" {
    pub fn pw_context_create_metadata(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_metadata;
}
unsafe extern "C" {
    #[doc = " Get the metadata properties"]
    pub fn pw_impl_metadata_get_properties(metadata: *mut pw_impl_metadata)
    -> *const pw_properties;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_register(
        metadata: *mut pw_impl_metadata,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_destroy(metadata: *mut pw_impl_metadata);
}
unsafe extern "C" {
    pub fn pw_impl_metadata_get_user_data(
        metadata: *mut pw_impl_metadata,
    ) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_set_implementation(
        metadata: *mut pw_impl_metadata,
        impl_: *mut pw_metadata,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_get_implementation(metadata: *mut pw_impl_metadata)
    -> *mut pw_metadata;
}
unsafe extern "C" {
    #[doc = " Get the global of this metadata"]
    pub fn pw_impl_metadata_get_global(metadata: *mut pw_impl_metadata) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_metadata_add_listener(
        metadata: *mut pw_impl_metadata,
        listener: *mut spa_hook,
        events: *const pw_impl_metadata_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set a property"]
    pub fn pw_impl_metadata_set_property(
        metadata: *mut pw_impl_metadata,
        subject: u32,
        key: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_metadata_set_propertyf(
        metadata: *mut pw_impl_metadata,
        subject: u32,
        key: *const ::std::os::raw::c_char,
        type_: *const ::std::os::raw::c_char,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
#[doc = " Module init function signature\n\n \\param module A \\ref pw_impl_module\n \\param args Arguments to the module\n \\return 0 on success, < 0 otherwise with an errno style error\n\n A module should provide an init function with this signature. This function\n will be called when a module is loaded."]
pub type pw_impl_module_init_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        module: *mut pw_impl_module,
        args: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Module events added with \\ref pw_impl_module_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_module_events {
    pub version: u32,
    #[doc = " The module is destroyed. This is the time to unregister and\n destroy any objects created by the module."]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The module is freed. This will be called after destroy() returns."]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The module is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The module is registered. This is a good time to register\n objects created from the module."]
    pub registered: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_module_events"][::std::mem::size_of::<pw_impl_module_events>() - 40usize];
    ["Alignment of pw_impl_module_events"]
        [::std::mem::align_of::<pw_impl_module_events>() - 8usize];
    ["Offset of field: pw_impl_module_events::version"]
        [::std::mem::offset_of!(pw_impl_module_events, version) - 0usize];
    ["Offset of field: pw_impl_module_events::destroy"]
        [::std::mem::offset_of!(pw_impl_module_events, destroy) - 8usize];
    ["Offset of field: pw_impl_module_events::free"]
        [::std::mem::offset_of!(pw_impl_module_events, free) - 16usize];
    ["Offset of field: pw_impl_module_events::initialized"]
        [::std::mem::offset_of!(pw_impl_module_events, initialized) - 24usize];
    ["Offset of field: pw_impl_module_events::registered"]
        [::std::mem::offset_of!(pw_impl_module_events, registered) - 32usize];
};
unsafe extern "C" {
    pub fn pw_context_load_module(
        context: *mut pw_context,
        name: *const ::std::os::raw::c_char,
        args: *const ::std::os::raw::c_char,
        properties: *mut pw_properties,
    ) -> *mut pw_impl_module;
}
unsafe extern "C" {
    #[doc = " Get the context of a module"]
    pub fn pw_impl_module_get_context(module: *mut pw_impl_module) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the global of a module"]
    pub fn pw_impl_module_get_global(module: *mut pw_impl_module) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the module properties"]
    pub fn pw_impl_module_get_properties(module: *mut pw_impl_module) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the module properties"]
    pub fn pw_impl_module_update_properties(
        module: *mut pw_impl_module,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the module info"]
    pub fn pw_impl_module_get_info(module: *mut pw_impl_module) -> *const pw_module_info;
}
unsafe extern "C" {
    #[doc = " Add an event listener to a module"]
    pub fn pw_impl_module_add_listener(
        module: *mut pw_impl_module,
        listener: *mut spa_hook,
        events: *const pw_impl_module_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Destroy a module"]
    pub fn pw_impl_module_destroy(module: *mut pw_impl_module);
}
unsafe extern "C" {
    #[doc = " Schedule a destroy later on the main thread"]
    pub fn pw_impl_module_schedule_destroy(module: *mut pw_impl_module);
}
#[doc = " Node events, listen to them with \\ref pw_impl_node_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_node_events {
    pub version: u32,
    #[doc = " the node is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node is about to be freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a port is being initialized on the node"]
    pub port_init: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
    #[doc = " a port was added"]
    pub port_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
    #[doc = " a port was removed"]
    pub port_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, port: *mut pw_impl_port),
    >,
    #[doc = " the node info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_node_info),
    >,
    #[doc = " a port on the node changed info"]
    pub port_info_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            port: *mut pw_impl_port,
            info: *const pw_port_info,
        ),
    >,
    #[doc = " the node active state changed"]
    pub active_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, active: bool),
    >,
    #[doc = " a new state is requested on the node"]
    pub state_request: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, state: pw_node_state),
    >,
    #[doc = " the state of the node changed"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_node_state,
            state: pw_node_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " a result was received"]
    pub result: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            type_: u32,
            result: *const ::std::os::raw::c_void,
        ),
    >,
    #[doc = " an event is emitted"]
    pub event: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, event: *const spa_event),
    >,
    #[doc = " the driver of the node changed"]
    pub driver_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: *mut pw_impl_node,
            driver: *mut pw_impl_node,
        ),
    >,
    #[doc = " a peer was added"]
    pub peer_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, peer: *mut pw_impl_node),
    >,
    #[doc = " a peer was removed"]
    pub peer_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, peer: *mut pw_impl_node),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_node_events"][::std::mem::size_of::<pw_impl_node_events>() - 136usize];
    ["Alignment of pw_impl_node_events"][::std::mem::align_of::<pw_impl_node_events>() - 8usize];
    ["Offset of field: pw_impl_node_events::version"]
        [::std::mem::offset_of!(pw_impl_node_events, version) - 0usize];
    ["Offset of field: pw_impl_node_events::destroy"]
        [::std::mem::offset_of!(pw_impl_node_events, destroy) - 8usize];
    ["Offset of field: pw_impl_node_events::free"]
        [::std::mem::offset_of!(pw_impl_node_events, free) - 16usize];
    ["Offset of field: pw_impl_node_events::initialized"]
        [::std::mem::offset_of!(pw_impl_node_events, initialized) - 24usize];
    ["Offset of field: pw_impl_node_events::port_init"]
        [::std::mem::offset_of!(pw_impl_node_events, port_init) - 32usize];
    ["Offset of field: pw_impl_node_events::port_added"]
        [::std::mem::offset_of!(pw_impl_node_events, port_added) - 40usize];
    ["Offset of field: pw_impl_node_events::port_removed"]
        [::std::mem::offset_of!(pw_impl_node_events, port_removed) - 48usize];
    ["Offset of field: pw_impl_node_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, info_changed) - 56usize];
    ["Offset of field: pw_impl_node_events::port_info_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, port_info_changed) - 64usize];
    ["Offset of field: pw_impl_node_events::active_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, active_changed) - 72usize];
    ["Offset of field: pw_impl_node_events::state_request"]
        [::std::mem::offset_of!(pw_impl_node_events, state_request) - 80usize];
    ["Offset of field: pw_impl_node_events::state_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, state_changed) - 88usize];
    ["Offset of field: pw_impl_node_events::result"]
        [::std::mem::offset_of!(pw_impl_node_events, result) - 96usize];
    ["Offset of field: pw_impl_node_events::event"]
        [::std::mem::offset_of!(pw_impl_node_events, event) - 104usize];
    ["Offset of field: pw_impl_node_events::driver_changed"]
        [::std::mem::offset_of!(pw_impl_node_events, driver_changed) - 112usize];
    ["Offset of field: pw_impl_node_events::peer_added"]
        [::std::mem::offset_of!(pw_impl_node_events, peer_added) - 120usize];
    ["Offset of field: pw_impl_node_events::peer_removed"]
        [::std::mem::offset_of!(pw_impl_node_events, peer_removed) - 128usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_node_rt_events {
    pub version: u32,
    #[doc = " the node is drained"]
    pub drained: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node had an xrun"]
    pub xrun: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the driver node starts processing"]
    pub start: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the driver node completed processing"]
    pub complete: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the driver node did not complete processing"]
    pub incomplete: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the node had a timeout"]
    pub timeout: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_node_rt_events"][::std::mem::size_of::<pw_impl_node_rt_events>() - 56usize];
    ["Alignment of pw_impl_node_rt_events"]
        [::std::mem::align_of::<pw_impl_node_rt_events>() - 8usize];
    ["Offset of field: pw_impl_node_rt_events::version"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, version) - 0usize];
    ["Offset of field: pw_impl_node_rt_events::drained"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, drained) - 8usize];
    ["Offset of field: pw_impl_node_rt_events::xrun"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, xrun) - 16usize];
    ["Offset of field: pw_impl_node_rt_events::start"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, start) - 24usize];
    ["Offset of field: pw_impl_node_rt_events::complete"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, complete) - 32usize];
    ["Offset of field: pw_impl_node_rt_events::incomplete"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, incomplete) - 40usize];
    ["Offset of field: pw_impl_node_rt_events::timeout"]
        [::std::mem::offset_of!(pw_impl_node_rt_events, timeout) - 48usize];
};
unsafe extern "C" {
    #[doc = " Create a new node"]
    pub fn pw_context_create_node(
        context: *mut pw_context,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_node;
}
unsafe extern "C" {
    #[doc = " Complete initialization of the node and register"]
    pub fn pw_impl_node_register(
        node: *mut pw_impl_node,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy a node"]
    pub fn pw_impl_node_destroy(node: *mut pw_impl_node);
}
unsafe extern "C" {
    #[doc = " Get the node info"]
    pub fn pw_impl_node_get_info(node: *mut pw_impl_node) -> *const pw_node_info;
}
unsafe extern "C" {
    #[doc = " Get node user_data. The size of the memory was given in \\ref pw_context_create_node"]
    pub fn pw_impl_node_get_user_data(node: *mut pw_impl_node) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the context of this node"]
    pub fn pw_impl_node_get_context(node: *mut pw_impl_node) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the global of this node"]
    pub fn pw_impl_node_get_global(node: *mut pw_impl_node) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the node properties"]
    pub fn pw_impl_node_get_properties(node: *mut pw_impl_node) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the node properties"]
    pub fn pw_impl_node_update_properties(
        node: *mut pw_impl_node,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set the node implementation"]
    pub fn pw_impl_node_set_implementation(
        node: *mut pw_impl_node,
        spa_node: *mut spa_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the node implementation"]
    pub fn pw_impl_node_get_implementation(node: *mut pw_impl_node) -> *mut spa_node;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_impl_node_add_listener(
        node: *mut pw_impl_node,
        listener: *mut spa_hook,
        events: *const pw_impl_node_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Add an rt_event listener"]
    pub fn pw_impl_node_add_rt_listener(
        node: *mut pw_impl_node,
        listener: *mut spa_hook,
        events: *const pw_impl_node_rt_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    pub fn pw_impl_node_remove_rt_listener(node: *mut pw_impl_node, listener: *mut spa_hook);
}
unsafe extern "C" {
    #[doc = " Iterate the ports in the given direction. The callback should return\n 0 to fetch the next item, any other value stops the iteration and returns\n the value. When all callbacks return 0, this function returns 0 when all\n items are iterated."]
    pub fn pw_impl_node_for_each_port(
        node: *mut pw_impl_node,
        direction: spa_direction,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                port: *mut pw_impl_port,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_impl_node_for_each_param(
        node: *mut pw_impl_node,
        seq: ::std::os::raw::c_int,
        param_id: u32,
        index: u32,
        max: u32,
        filter: *const spa_pod,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                seq: ::std::os::raw::c_int,
                id: u32,
                index: u32,
                next: u32,
                param: *mut spa_pod,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Find the port with direction and port_id or NULL when not found. Passing\n PW_ID_ANY for port_id will return any port, preferably an unlinked one."]
    pub fn pw_impl_node_find_port(
        node: *mut pw_impl_node,
        direction: spa_direction,
        port_id: u32,
    ) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Get a free unused port_id from the node"]
    pub fn pw_impl_node_get_free_port_id(node: *mut pw_impl_node, direction: spa_direction) -> u32;
}
unsafe extern "C" {
    pub fn pw_impl_node_initialized(node: *mut pw_impl_node) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a node active. This will start negotiation with all linked active\n nodes and start data transport"]
    pub fn pw_impl_node_set_active(node: *mut pw_impl_node, active: bool) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Check if a node is active"]
    pub fn pw_impl_node_is_active(node: *mut pw_impl_node) -> bool;
}
unsafe extern "C" {
    #[doc = " Check if a node is active, Since 0.3.39"]
    pub fn pw_impl_node_send_command(
        node: *mut pw_impl_node,
        command: *const spa_command,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a param on the node, Since 0.3.65"]
    pub fn pw_impl_node_set_param(
        node: *mut pw_impl_node,
        id: u32,
        flags: u32,
        param: *const spa_pod,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< the port is in error"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_ERROR: pw_impl_port_state = -1;
#[doc = "< the port is being created"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_INIT: pw_impl_port_state = 0;
#[doc = "< the port is ready for format negotiation"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_CONFIGURE: pw_impl_port_state = 1;
#[doc = "< the port is ready for buffer allocation"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_READY: pw_impl_port_state = 2;
#[doc = "< the port is paused"]
pub const pw_impl_port_state_PW_IMPL_PORT_STATE_PAUSED: pw_impl_port_state = 3;
pub type pw_impl_port_state = ::std::os::raw::c_int;
#[doc = " Port events, use \\ref pw_impl_port_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_port_events {
    pub version: u32,
    #[doc = " The port is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The port is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The port is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the port info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_port_info),
    >,
    #[doc = " a new link is added on this port"]
    pub link_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, link: *mut pw_impl_link),
    >,
    #[doc = " a link is removed from this port"]
    pub link_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, link: *mut pw_impl_link),
    >,
    #[doc = " the state of the port changed"]
    pub state_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            old: pw_impl_port_state,
            state: pw_impl_port_state,
            error: *const ::std::os::raw::c_char,
        ),
    >,
    #[doc = " a control was added to the port"]
    pub control_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, control: *mut pw_control),
    >,
    #[doc = " a control was removed from the port"]
    pub control_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, control: *mut pw_control),
    >,
    #[doc = " a parameter changed, since version 1"]
    pub param_changed:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, id: u32)>,
    #[doc = " latency changed. Since version 2"]
    pub latency_changed:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " tag changed. Since version 3"]
    pub tag_changed: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_port_events"][::std::mem::size_of::<pw_impl_port_events>() - 104usize];
    ["Alignment of pw_impl_port_events"][::std::mem::align_of::<pw_impl_port_events>() - 8usize];
    ["Offset of field: pw_impl_port_events::version"]
        [::std::mem::offset_of!(pw_impl_port_events, version) - 0usize];
    ["Offset of field: pw_impl_port_events::destroy"]
        [::std::mem::offset_of!(pw_impl_port_events, destroy) - 8usize];
    ["Offset of field: pw_impl_port_events::free"]
        [::std::mem::offset_of!(pw_impl_port_events, free) - 16usize];
    ["Offset of field: pw_impl_port_events::initialized"]
        [::std::mem::offset_of!(pw_impl_port_events, initialized) - 24usize];
    ["Offset of field: pw_impl_port_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, info_changed) - 32usize];
    ["Offset of field: pw_impl_port_events::link_added"]
        [::std::mem::offset_of!(pw_impl_port_events, link_added) - 40usize];
    ["Offset of field: pw_impl_port_events::link_removed"]
        [::std::mem::offset_of!(pw_impl_port_events, link_removed) - 48usize];
    ["Offset of field: pw_impl_port_events::state_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, state_changed) - 56usize];
    ["Offset of field: pw_impl_port_events::control_added"]
        [::std::mem::offset_of!(pw_impl_port_events, control_added) - 64usize];
    ["Offset of field: pw_impl_port_events::control_removed"]
        [::std::mem::offset_of!(pw_impl_port_events, control_removed) - 72usize];
    ["Offset of field: pw_impl_port_events::param_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, param_changed) - 80usize];
    ["Offset of field: pw_impl_port_events::latency_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, latency_changed) - 88usize];
    ["Offset of field: pw_impl_port_events::tag_changed"]
        [::std::mem::offset_of!(pw_impl_port_events, tag_changed) - 96usize];
};
unsafe extern "C" {
    #[doc = " Create a new port\n \\return a newly allocated port"]
    pub fn pw_context_create_port(
        context: *mut pw_context,
        direction: spa_direction,
        port_id: u32,
        info: *const spa_port_info,
        user_data_size: usize,
    ) -> *mut pw_impl_port;
}
unsafe extern "C" {
    #[doc = " Get the port direction"]
    pub fn pw_impl_port_get_direction(port: *mut pw_impl_port) -> spa_direction;
}
unsafe extern "C" {
    #[doc = " Get the port properties"]
    pub fn pw_impl_port_get_properties(port: *mut pw_impl_port) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the port properties"]
    pub fn pw_impl_port_update_properties(
        port: *mut pw_impl_port,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the port info"]
    pub fn pw_impl_port_get_info(port: *mut pw_impl_port) -> *const pw_port_info;
}
unsafe extern "C" {
    #[doc = " Get the port id"]
    pub fn pw_impl_port_get_id(port: *mut pw_impl_port) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the port state as a string"]
    pub fn pw_impl_port_state_as_string(state: pw_impl_port_state)
    -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the port parent node or NULL when not yet set"]
    pub fn pw_impl_port_get_node(port: *mut pw_impl_port) -> *mut pw_impl_node;
}
unsafe extern "C" {
    #[doc = " check is a port has links, return 0 if not, 1 if it is linked"]
    pub fn pw_impl_port_is_linked(port: *mut pw_impl_port) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add a port to a node"]
    pub fn pw_impl_port_add(
        port: *mut pw_impl_port,
        node: *mut pw_impl_node,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an event listener on the port"]
    pub fn pw_impl_port_add_listener(
        port: *mut pw_impl_port,
        listener: *mut spa_hook,
        events: *const pw_impl_port_events,
        data: *mut ::std::os::raw::c_void,
    );
}
pub type pw_work_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        obj: *mut ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
        res: ::std::os::raw::c_int,
        id: u32,
    ),
>;
unsafe extern "C" {
    pub fn pw_work_queue_new(loop_: *mut pw_loop) -> *mut pw_work_queue;
}
unsafe extern "C" {
    pub fn pw_work_queue_destroy(queue: *mut pw_work_queue);
}
unsafe extern "C" {
    pub fn pw_work_queue_add(
        queue: *mut pw_work_queue,
        obj: *mut ::std::os::raw::c_void,
        res: ::std::os::raw::c_int,
        func: pw_work_func_t,
        data: *mut ::std::os::raw::c_void,
    ) -> u32;
}
unsafe extern "C" {
    pub fn pw_work_queue_cancel(
        queue: *mut pw_work_queue,
        obj: *mut ::std::os::raw::c_void,
        id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_work_queue_complete(
        queue: *mut pw_work_queue,
        obj: *mut ::std::os::raw::c_void,
        seq: u32,
        res: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type pw_global_bind_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        object: *mut ::std::os::raw::c_void,
        client: *mut pw_impl_client,
        permissions: u32,
        version: u32,
        id: u32,
    ) -> ::std::os::raw::c_int,
>;
#[doc = " Global events, use \\ref pw_global_add_listener"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_global_events {
    pub version: u32,
    #[doc = " The global is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The global is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " The permissions changed for a client"]
    pub permissions_changed: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            client: *mut pw_impl_client,
            old_permissions: u32,
            new_permissions: u32,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_global_events"][::std::mem::size_of::<pw_global_events>() - 32usize];
    ["Alignment of pw_global_events"][::std::mem::align_of::<pw_global_events>() - 8usize];
    ["Offset of field: pw_global_events::version"]
        [::std::mem::offset_of!(pw_global_events, version) - 0usize];
    ["Offset of field: pw_global_events::destroy"]
        [::std::mem::offset_of!(pw_global_events, destroy) - 8usize];
    ["Offset of field: pw_global_events::free"]
        [::std::mem::offset_of!(pw_global_events, free) - 16usize];
    ["Offset of field: pw_global_events::permissions_changed"]
        [::std::mem::offset_of!(pw_global_events, permissions_changed) - 24usize];
};
unsafe extern "C" {
    #[doc = " Create a new global object"]
    pub fn pw_global_new(
        context: *mut pw_context,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        permission_mask: u32,
        properties: *mut pw_properties,
        func: pw_global_bind_func_t,
        object: *mut ::std::os::raw::c_void,
    ) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Register a global object to the context registry"]
    pub fn pw_global_register(global: *mut pw_global) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Add an event listener on the global"]
    pub fn pw_global_add_listener(
        global: *mut pw_global,
        listener: *mut spa_hook,
        events: *const pw_global_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Get the permissions of the global for a given client"]
    pub fn pw_global_get_permissions(global: *mut pw_global, client: *mut pw_impl_client) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the context object of this global"]
    pub fn pw_global_get_context(global: *mut pw_global) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the global type"]
    pub fn pw_global_get_type(global: *mut pw_global) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Check a global type"]
    pub fn pw_global_is_type(global: *mut pw_global, type_: *const ::std::os::raw::c_char) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the global version"]
    pub fn pw_global_get_version(global: *mut pw_global) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the global properties"]
    pub fn pw_global_get_properties(global: *mut pw_global) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Update the global properties, must be done when unregistered"]
    pub fn pw_global_update_keys(
        global: *mut pw_global,
        dict: *const spa_dict,
        keys: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the object associated with the global. This depends on the type of the\n global"]
    pub fn pw_global_get_object(global: *mut pw_global) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the unique id of the global"]
    pub fn pw_global_get_id(global: *mut pw_global) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the serial number of the global"]
    pub fn pw_global_get_serial(global: *mut pw_global) -> u64;
}
unsafe extern "C" {
    #[doc = " Add a resource to a global"]
    pub fn pw_global_add_resource(
        global: *mut pw_global,
        resource: *mut pw_resource,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Iterate all resources added to the global The callback should return\n 0 to fetch the next item, any other value stops the iteration and returns\n the value. When all callbacks return 0, this function returns 0 when all\n items are iterated."]
    pub fn pw_global_for_each_resource(
        global: *mut pw_global,
        callback: ::std::option::Option<
            unsafe extern "C" fn(
                data: *mut ::std::os::raw::c_void,
                resource: *mut pw_resource,
            ) -> ::std::os::raw::c_int,
        >,
        data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Let a client bind to a global"]
    pub fn pw_global_bind(
        global: *mut pw_global,
        client: *mut pw_impl_client,
        permissions: u32,
        version: u32,
        id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    pub fn pw_global_update_permissions(
        global: *mut pw_global,
        client: *mut pw_impl_client,
        old_permissions: u32,
        new_permissions: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy a global"]
    pub fn pw_global_destroy(global: *mut pw_global);
}
#[doc = " The events that a client can emit"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_impl_client_events {
    pub version: u32,
    #[doc = " emitted when the client is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " emitted right before the client is freed"]
    pub free: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " the client is initialized"]
    pub initialized: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " emitted when the client info changed"]
    pub info_changed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_client_info),
    >,
    #[doc = " emitted when a new resource is added for client"]
    pub resource_added: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, resource: *mut pw_resource),
    >,
    #[doc = " emitted when a resource is removed"]
    pub resource_removed: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, resource: *mut pw_resource),
    >,
    #[doc = " emitted when the client becomes busy processing an asynchronous\n message. In the busy state no messages should be processed.\n Processing should resume when the client becomes not busy"]
    pub busy_changed:
        ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, busy: bool)>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_impl_client_events"][::std::mem::size_of::<pw_impl_client_events>() - 64usize];
    ["Alignment of pw_impl_client_events"]
        [::std::mem::align_of::<pw_impl_client_events>() - 8usize];
    ["Offset of field: pw_impl_client_events::version"]
        [::std::mem::offset_of!(pw_impl_client_events, version) - 0usize];
    ["Offset of field: pw_impl_client_events::destroy"]
        [::std::mem::offset_of!(pw_impl_client_events, destroy) - 8usize];
    ["Offset of field: pw_impl_client_events::free"]
        [::std::mem::offset_of!(pw_impl_client_events, free) - 16usize];
    ["Offset of field: pw_impl_client_events::initialized"]
        [::std::mem::offset_of!(pw_impl_client_events, initialized) - 24usize];
    ["Offset of field: pw_impl_client_events::info_changed"]
        [::std::mem::offset_of!(pw_impl_client_events, info_changed) - 32usize];
    ["Offset of field: pw_impl_client_events::resource_added"]
        [::std::mem::offset_of!(pw_impl_client_events, resource_added) - 40usize];
    ["Offset of field: pw_impl_client_events::resource_removed"]
        [::std::mem::offset_of!(pw_impl_client_events, resource_removed) - 48usize];
    ["Offset of field: pw_impl_client_events::busy_changed"]
        [::std::mem::offset_of!(pw_impl_client_events, busy_changed) - 56usize];
};
unsafe extern "C" {
    #[doc = " Create a new client. This is mainly used by protocols."]
    pub fn pw_context_create_client(
        core: *mut pw_impl_core,
        protocol: *mut pw_protocol,
        properties: *mut pw_properties,
        user_data_size: usize,
    ) -> *mut pw_impl_client;
}
unsafe extern "C" {
    #[doc = " Destroy a previously created client"]
    pub fn pw_impl_client_destroy(client: *mut pw_impl_client);
}
unsafe extern "C" {
    #[doc = " Finish configuration and register a client"]
    pub fn pw_impl_client_register(
        client: *mut pw_impl_client,
        properties: *mut pw_properties,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the client user data"]
    pub fn pw_impl_client_get_user_data(client: *mut pw_impl_client)
    -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the client information"]
    pub fn pw_impl_client_get_info(client: *mut pw_impl_client) -> *const pw_client_info;
}
unsafe extern "C" {
    #[doc = " Update the client properties"]
    pub fn pw_impl_client_update_properties(
        client: *mut pw_impl_client,
        dict: *const spa_dict,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Update the client permissions"]
    pub fn pw_impl_client_update_permissions(
        client: *mut pw_impl_client,
        n_permissions: u32,
        permissions: *const pw_permission,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " check if a client has permissions for global_id, Since 0.3.9"]
    pub fn pw_impl_client_check_permissions(
        client: *mut pw_impl_client,
        global_id: u32,
        permissions: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the client properties"]
    pub fn pw_impl_client_get_properties(client: *mut pw_impl_client) -> *const pw_properties;
}
unsafe extern "C" {
    #[doc = " Get the context used to create this client"]
    pub fn pw_impl_client_get_context(client: *mut pw_impl_client) -> *mut pw_context;
}
unsafe extern "C" {
    #[doc = " Get the protocol used to create this client"]
    pub fn pw_impl_client_get_protocol(client: *mut pw_impl_client) -> *mut pw_protocol;
}
unsafe extern "C" {
    #[doc = " Get the client core resource"]
    pub fn pw_impl_client_get_core_resource(client: *mut pw_impl_client) -> *mut pw_resource;
}
unsafe extern "C" {
    #[doc = " Get a resource with the given id"]
    pub fn pw_impl_client_find_resource(client: *mut pw_impl_client, id: u32) -> *mut pw_resource;
}
unsafe extern "C" {
    #[doc = " Get the global associated with this client"]
    pub fn pw_impl_client_get_global(client: *mut pw_impl_client) -> *mut pw_global;
}
unsafe extern "C" {
    #[doc = " Get the mempool associated with this client, Since 0.3.74"]
    pub fn pw_impl_client_get_mempool(client: *mut pw_impl_client) -> *mut pw_mempool;
}
unsafe extern "C" {
    #[doc = " listen to events from this client"]
    pub fn pw_impl_client_add_listener(
        client: *mut pw_impl_client,
        listener: *mut spa_hook,
        events: *const pw_impl_client_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Mark the client busy. This can be used when an asynchronous operation is\n started and no further processing is allowed to happen for the client"]
    pub fn pw_impl_client_set_busy(client: *mut pw_impl_client, busy: bool);
}
#[doc = " Resource events"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_resource_events {
    pub version: u32,
    #[doc = " The resource is destroyed"]
    pub destroy: ::std::option::Option<unsafe extern "C" fn(data: *mut ::std::os::raw::c_void)>,
    #[doc = " a reply to a ping event completed"]
    pub pong: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, seq: ::std::os::raw::c_int),
    >,
    #[doc = " an error occurred on the resource"]
    pub error: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            res: ::std::os::raw::c_int,
            message: *const ::std::os::raw::c_char,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_resource_events"][::std::mem::size_of::<pw_resource_events>() - 32usize];
    ["Alignment of pw_resource_events"][::std::mem::align_of::<pw_resource_events>() - 8usize];
    ["Offset of field: pw_resource_events::version"]
        [::std::mem::offset_of!(pw_resource_events, version) - 0usize];
    ["Offset of field: pw_resource_events::destroy"]
        [::std::mem::offset_of!(pw_resource_events, destroy) - 8usize];
    ["Offset of field: pw_resource_events::pong"]
        [::std::mem::offset_of!(pw_resource_events, pong) - 16usize];
    ["Offset of field: pw_resource_events::error"]
        [::std::mem::offset_of!(pw_resource_events, error) - 24usize];
};
unsafe extern "C" {
    #[doc = " Make a new resource for client"]
    pub fn pw_resource_new(
        client: *mut pw_impl_client,
        id: u32,
        permissions: u32,
        type_: *const ::std::os::raw::c_char,
        version: u32,
        user_data_size: usize,
    ) -> *mut pw_resource;
}
unsafe extern "C" {
    #[doc = " Destroy a resource"]
    pub fn pw_resource_destroy(resource: *mut pw_resource);
}
unsafe extern "C" {
    #[doc = " Remove a resource, like pw_resource_destroy but without sending a\n remove_id message to the client"]
    pub fn pw_resource_remove(resource: *mut pw_resource);
}
unsafe extern "C" {
    #[doc = " Get the client owning this resource"]
    pub fn pw_resource_get_client(resource: *mut pw_resource) -> *mut pw_impl_client;
}
unsafe extern "C" {
    #[doc = " Get the unique id of this resource"]
    pub fn pw_resource_get_id(resource: *mut pw_resource) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the permissions of this resource"]
    pub fn pw_resource_get_permissions(resource: *mut pw_resource) -> u32;
}
unsafe extern "C" {
    #[doc = " Get the type and optionally the version of this resource"]
    pub fn pw_resource_get_type(
        resource: *mut pw_resource,
        version: *mut u32,
    ) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Get the protocol used for this resource"]
    pub fn pw_resource_get_protocol(resource: *mut pw_resource) -> *mut pw_protocol;
}
unsafe extern "C" {
    #[doc = " Get the user data for the resource, the size was given in \\ref pw_resource_new"]
    pub fn pw_resource_get_user_data(resource: *mut pw_resource) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Add an event listener"]
    pub fn pw_resource_add_listener(
        resource: *mut pw_resource,
        listener: *mut spa_hook,
        events: *const pw_resource_events,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set the resource implementation."]
    pub fn pw_resource_add_object_listener(
        resource: *mut pw_resource,
        listener: *mut spa_hook,
        funcs: *const ::std::os::raw::c_void,
        data: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Generate an ping event for a resource. This will generate a pong event\n with the same \\a sequence number in the return value."]
    pub fn pw_resource_ping(
        resource: *mut pw_resource,
        seq: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " ref/unref a resource, Since 0.3.52"]
    pub fn pw_resource_ref(resource: *mut pw_resource);
}
unsafe extern "C" {
    pub fn pw_resource_unref(resource: *mut pw_resource);
}
unsafe extern "C" {
    #[doc = " Notify global id this resource is bound to"]
    pub fn pw_resource_set_bound_id(
        resource: *mut pw_resource,
        global_id: u32,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the global id this resource is bound to or SPA_ID_INVALID when not bound"]
    pub fn pw_resource_get_bound_id(resource: *mut pw_resource) -> u32;
}
unsafe extern "C" {
    #[doc = " Generate an error for a resource"]
    pub fn pw_resource_error(
        resource: *mut pw_resource,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
    );
}
unsafe extern "C" {
    pub fn pw_resource_errorf(
        resource: *mut pw_resource,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    pub fn pw_resource_errorf_id(
        resource: *mut pw_resource,
        id: u32,
        res: ::std::os::raw::c_int,
        error: *const ::std::os::raw::c_char,
        ...
    );
}
unsafe extern "C" {
    #[doc = " Get the list of object listeners from a resource"]
    pub fn pw_resource_get_object_listeners(resource: *mut pw_resource) -> *mut spa_hook_list;
}
unsafe extern "C" {
    #[doc = " Get the marshal functions for the resource"]
    pub fn pw_resource_get_marshal(resource: *mut pw_resource) -> *const pw_protocol_marshal;
}
unsafe extern "C" {
    #[doc = " install a marshal function on a resource"]
    pub fn pw_resource_install_marshal(
        resource: *mut pw_resource,
        implementor: bool,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_native_message {
    pub id: u32,
    pub opcode: u32,
    pub data: *mut ::std::os::raw::c_void,
    pub size: u32,
    pub n_fds: u32,
    pub fds: *mut ::std::os::raw::c_int,
    pub seq: ::std::os::raw::c_int,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_native_message"]
        [::std::mem::size_of::<pw_protocol_native_message>() - 40usize];
    ["Alignment of pw_protocol_native_message"]
        [::std::mem::align_of::<pw_protocol_native_message>() - 8usize];
    ["Offset of field: pw_protocol_native_message::id"]
        [::std::mem::offset_of!(pw_protocol_native_message, id) - 0usize];
    ["Offset of field: pw_protocol_native_message::opcode"]
        [::std::mem::offset_of!(pw_protocol_native_message, opcode) - 4usize];
    ["Offset of field: pw_protocol_native_message::data"]
        [::std::mem::offset_of!(pw_protocol_native_message, data) - 8usize];
    ["Offset of field: pw_protocol_native_message::size"]
        [::std::mem::offset_of!(pw_protocol_native_message, size) - 16usize];
    ["Offset of field: pw_protocol_native_message::n_fds"]
        [::std::mem::offset_of!(pw_protocol_native_message, n_fds) - 20usize];
    ["Offset of field: pw_protocol_native_message::fds"]
        [::std::mem::offset_of!(pw_protocol_native_message, fds) - 24usize];
    ["Offset of field: pw_protocol_native_message::seq"]
        [::std::mem::offset_of!(pw_protocol_native_message, seq) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_native_demarshal {
    pub func: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            msg: *const pw_protocol_native_message,
        ) -> ::std::os::raw::c_int,
    >,
    pub permissions: u32,
    pub flags: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_native_demarshal"]
        [::std::mem::size_of::<pw_protocol_native_demarshal>() - 16usize];
    ["Alignment of pw_protocol_native_demarshal"]
        [::std::mem::align_of::<pw_protocol_native_demarshal>() - 8usize];
    ["Offset of field: pw_protocol_native_demarshal::func"]
        [::std::mem::offset_of!(pw_protocol_native_demarshal, func) - 0usize];
    ["Offset of field: pw_protocol_native_demarshal::permissions"]
        [::std::mem::offset_of!(pw_protocol_native_demarshal, permissions) - 8usize];
    ["Offset of field: pw_protocol_native_demarshal::flags"]
        [::std::mem::offset_of!(pw_protocol_native_demarshal, flags) - 12usize];
};
#[doc = " \\ref pw_protocol_native_ext methods"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_protocol_native_ext {
    pub version: u32,
    pub begin_proxy: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut pw_proxy,
            opcode: u8,
            msg: *mut *mut pw_protocol_native_message,
        ) -> *mut spa_pod_builder,
    >,
    pub add_proxy_fd: ::std::option::Option<
        unsafe extern "C" fn(proxy: *mut pw_proxy, fd: ::std::os::raw::c_int) -> u32,
    >,
    pub get_proxy_fd: ::std::option::Option<
        unsafe extern "C" fn(proxy: *mut pw_proxy, index: u32) -> ::std::os::raw::c_int,
    >,
    pub end_proxy: ::std::option::Option<
        unsafe extern "C" fn(
            proxy: *mut pw_proxy,
            builder: *mut spa_pod_builder,
        ) -> ::std::os::raw::c_int,
    >,
    pub begin_resource: ::std::option::Option<
        unsafe extern "C" fn(
            resource: *mut pw_resource,
            opcode: u8,
            msg: *mut *mut pw_protocol_native_message,
        ) -> *mut spa_pod_builder,
    >,
    pub add_resource_fd: ::std::option::Option<
        unsafe extern "C" fn(resource: *mut pw_resource, fd: ::std::os::raw::c_int) -> u32,
    >,
    pub get_resource_fd: ::std::option::Option<
        unsafe extern "C" fn(resource: *mut pw_resource, index: u32) -> ::std::os::raw::c_int,
    >,
    pub end_resource: ::std::option::Option<
        unsafe extern "C" fn(
            resource: *mut pw_resource,
            builder: *mut spa_pod_builder,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_protocol_native_ext"][::std::mem::size_of::<pw_protocol_native_ext>() - 72usize];
    ["Alignment of pw_protocol_native_ext"]
        [::std::mem::align_of::<pw_protocol_native_ext>() - 8usize];
    ["Offset of field: pw_protocol_native_ext::version"]
        [::std::mem::offset_of!(pw_protocol_native_ext, version) - 0usize];
    ["Offset of field: pw_protocol_native_ext::begin_proxy"]
        [::std::mem::offset_of!(pw_protocol_native_ext, begin_proxy) - 8usize];
    ["Offset of field: pw_protocol_native_ext::add_proxy_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, add_proxy_fd) - 16usize];
    ["Offset of field: pw_protocol_native_ext::get_proxy_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, get_proxy_fd) - 24usize];
    ["Offset of field: pw_protocol_native_ext::end_proxy"]
        [::std::mem::offset_of!(pw_protocol_native_ext, end_proxy) - 32usize];
    ["Offset of field: pw_protocol_native_ext::begin_resource"]
        [::std::mem::offset_of!(pw_protocol_native_ext, begin_resource) - 40usize];
    ["Offset of field: pw_protocol_native_ext::add_resource_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, add_resource_fd) - 48usize];
    ["Offset of field: pw_protocol_native_ext::get_resource_fd"]
        [::std::mem::offset_of!(pw_protocol_native_ext, get_resource_fd) - 56usize];
    ["Offset of field: pw_protocol_native_ext::end_resource"]
        [::std::mem::offset_of!(pw_protocol_native_ext, end_resource) - 64usize];
};
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_ERROR: pw_endpoint_link_state = -1;
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_PREPARING: pw_endpoint_link_state = 0;
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_INACTIVE: pw_endpoint_link_state = 1;
pub const pw_endpoint_link_state_PW_ENDPOINT_LINK_STATE_ACTIVE: pw_endpoint_link_state = 2;
#[doc = " \\addtogroup pw_session_manager\n \\{"]
pub type pw_endpoint_link_state = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the session id (global)"]
    pub id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_session_info"][::std::mem::size_of::<pw_session_info>() - 40usize];
    ["Alignment of pw_session_info"][::std::mem::align_of::<pw_session_info>() - 8usize];
    ["Offset of field: pw_session_info::version"]
        [::std::mem::offset_of!(pw_session_info, version) - 0usize];
    ["Offset of field: pw_session_info::id"][::std::mem::offset_of!(pw_session_info, id) - 4usize];
    ["Offset of field: pw_session_info::change_mask"]
        [::std::mem::offset_of!(pw_session_info, change_mask) - 8usize];
    ["Offset of field: pw_session_info::props"]
        [::std::mem::offset_of!(pw_session_info, props) - 16usize];
    ["Offset of field: pw_session_info::params"]
        [::std::mem::offset_of!(pw_session_info, params) - 24usize];
    ["Offset of field: pw_session_info::n_params"]
        [::std::mem::offset_of!(pw_session_info, n_params) - 32usize];
};
#[repr(C)]
pub struct pw_endpoint_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the endpoint id (global)"]
    pub id: u32,
    #[doc = "< name of the endpoint"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< media class of the endpoint"]
    pub media_class: *mut ::std::os::raw::c_char,
    #[doc = "< direction of the endpoint"]
    pub direction: spa_direction,
    #[doc = "< additional flags"]
    pub flags: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< number of streams available"]
    pub n_streams: u32,
    #[doc = "< the id of the controlling session"]
    pub session_id: u32,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_info"][::std::mem::size_of::<pw_endpoint_info>() - 72usize];
    ["Alignment of pw_endpoint_info"][::std::mem::align_of::<pw_endpoint_info>() - 8usize];
    ["Offset of field: pw_endpoint_info::version"]
        [::std::mem::offset_of!(pw_endpoint_info, version) - 0usize];
    ["Offset of field: pw_endpoint_info::id"]
        [::std::mem::offset_of!(pw_endpoint_info, id) - 4usize];
    ["Offset of field: pw_endpoint_info::name"]
        [::std::mem::offset_of!(pw_endpoint_info, name) - 8usize];
    ["Offset of field: pw_endpoint_info::media_class"]
        [::std::mem::offset_of!(pw_endpoint_info, media_class) - 16usize];
    ["Offset of field: pw_endpoint_info::direction"]
        [::std::mem::offset_of!(pw_endpoint_info, direction) - 24usize];
    ["Offset of field: pw_endpoint_info::flags"]
        [::std::mem::offset_of!(pw_endpoint_info, flags) - 28usize];
    ["Offset of field: pw_endpoint_info::change_mask"]
        [::std::mem::offset_of!(pw_endpoint_info, change_mask) - 32usize];
    ["Offset of field: pw_endpoint_info::n_streams"]
        [::std::mem::offset_of!(pw_endpoint_info, n_streams) - 40usize];
    ["Offset of field: pw_endpoint_info::session_id"]
        [::std::mem::offset_of!(pw_endpoint_info, session_id) - 44usize];
    ["Offset of field: pw_endpoint_info::props"]
        [::std::mem::offset_of!(pw_endpoint_info, props) - 48usize];
    ["Offset of field: pw_endpoint_info::params"]
        [::std::mem::offset_of!(pw_endpoint_info, params) - 56usize];
    ["Offset of field: pw_endpoint_info::n_params"]
        [::std::mem::offset_of!(pw_endpoint_info, n_params) - 64usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the stream id (local or global)"]
    pub id: u32,
    #[doc = "< the endpoint id (global)"]
    pub endpoint_id: u32,
    #[doc = "< name of the stream"]
    pub name: *mut ::std::os::raw::c_char,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< information for linking this stream"]
    pub link_params: *mut spa_pod,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_stream_info"][::std::mem::size_of::<pw_endpoint_stream_info>() - 64usize];
    ["Alignment of pw_endpoint_stream_info"]
        [::std::mem::align_of::<pw_endpoint_stream_info>() - 8usize];
    ["Offset of field: pw_endpoint_stream_info::version"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, version) - 0usize];
    ["Offset of field: pw_endpoint_stream_info::id"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, id) - 4usize];
    ["Offset of field: pw_endpoint_stream_info::endpoint_id"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, endpoint_id) - 8usize];
    ["Offset of field: pw_endpoint_stream_info::name"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, name) - 16usize];
    ["Offset of field: pw_endpoint_stream_info::change_mask"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, change_mask) - 24usize];
    ["Offset of field: pw_endpoint_stream_info::link_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, link_params) - 32usize];
    ["Offset of field: pw_endpoint_stream_info::props"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, props) - 40usize];
    ["Offset of field: pw_endpoint_stream_info::params"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, params) - 48usize];
    ["Offset of field: pw_endpoint_stream_info::n_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_info, n_params) - 56usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link_info {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = "< the link id (global)"]
    pub id: u32,
    #[doc = "< the session id (global)"]
    pub session_id: u32,
    #[doc = "< the output endpoint id (global)"]
    pub output_endpoint_id: u32,
    #[doc = "< the output stream id (local or global)"]
    pub output_stream_id: u32,
    #[doc = "< the input endpoint id (global)"]
    pub input_endpoint_id: u32,
    #[doc = "< the input stream id (local or global)"]
    pub input_stream_id: u32,
    #[doc = "< bitfield of changed fields since last call"]
    pub change_mask: u64,
    #[doc = "< the state of the link"]
    pub state: pw_endpoint_link_state,
    #[doc = "< error string if state == ERROR"]
    pub error: *mut ::std::os::raw::c_char,
    #[doc = "< extra properties"]
    pub props: *mut spa_dict,
    #[doc = "< parameters"]
    pub params: *mut spa_param_info,
    #[doc = "< number of items in \\a params"]
    pub n_params: u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_link_info"][::std::mem::size_of::<pw_endpoint_link_info>() - 80usize];
    ["Alignment of pw_endpoint_link_info"]
        [::std::mem::align_of::<pw_endpoint_link_info>() - 8usize];
    ["Offset of field: pw_endpoint_link_info::version"]
        [::std::mem::offset_of!(pw_endpoint_link_info, version) - 0usize];
    ["Offset of field: pw_endpoint_link_info::id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, id) - 4usize];
    ["Offset of field: pw_endpoint_link_info::session_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, session_id) - 8usize];
    ["Offset of field: pw_endpoint_link_info::output_endpoint_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, output_endpoint_id) - 12usize];
    ["Offset of field: pw_endpoint_link_info::output_stream_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, output_stream_id) - 16usize];
    ["Offset of field: pw_endpoint_link_info::input_endpoint_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, input_endpoint_id) - 20usize];
    ["Offset of field: pw_endpoint_link_info::input_stream_id"]
        [::std::mem::offset_of!(pw_endpoint_link_info, input_stream_id) - 24usize];
    ["Offset of field: pw_endpoint_link_info::change_mask"]
        [::std::mem::offset_of!(pw_endpoint_link_info, change_mask) - 32usize];
    ["Offset of field: pw_endpoint_link_info::state"]
        [::std::mem::offset_of!(pw_endpoint_link_info, state) - 40usize];
    ["Offset of field: pw_endpoint_link_info::error"]
        [::std::mem::offset_of!(pw_endpoint_link_info, error) - 48usize];
    ["Offset of field: pw_endpoint_link_info::props"]
        [::std::mem::offset_of!(pw_endpoint_link_info, props) - 56usize];
    ["Offset of field: pw_endpoint_link_info::params"]
        [::std::mem::offset_of!(pw_endpoint_link_info, params) - 64usize];
    ["Offset of field: pw_endpoint_link_info::n_params"]
        [::std::mem::offset_of!(pw_endpoint_link_info, n_params) - 72usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify session info\n\n \\param info info about the session"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_session_info),
    >,
    #[doc = " Notify a session param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_session_events"][::std::mem::size_of::<pw_session_events>() - 24usize];
    ["Alignment of pw_session_events"][::std::mem::align_of::<pw_session_events>() - 8usize];
    ["Offset of field: pw_session_events::version"]
        [::std::mem::offset_of!(pw_session_events, version) - 0usize];
    ["Offset of field: pw_session_events::info"]
        [::std::mem::offset_of!(pw_session_events, info) - 8usize];
    ["Offset of field: pw_session_events::param"]
        [::std::mem::offset_of!(pw_session_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_session_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_session_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate session parameters\n\n Start enumeration of session parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the session\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_session_methods"][::std::mem::size_of::<pw_session_methods>() - 40usize];
    ["Alignment of pw_session_methods"][::std::mem::align_of::<pw_session_methods>() - 8usize];
    ["Offset of field: pw_session_methods::version"]
        [::std::mem::offset_of!(pw_session_methods, version) - 0usize];
    ["Offset of field: pw_session_methods::add_listener"]
        [::std::mem::offset_of!(pw_session_methods, add_listener) - 8usize];
    ["Offset of field: pw_session_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_session_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_session_methods::enum_params"]
        [::std::mem::offset_of!(pw_session_methods, enum_params) - 24usize];
    ["Offset of field: pw_session_methods::set_param"]
        [::std::mem::offset_of!(pw_session_methods, set_param) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify endpoint info\n\n \\param info info about the endpoint"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_endpoint_info),
    >,
    #[doc = " Notify a endpoint param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_events"][::std::mem::size_of::<pw_endpoint_events>() - 24usize];
    ["Alignment of pw_endpoint_events"][::std::mem::align_of::<pw_endpoint_events>() - 8usize];
    ["Offset of field: pw_endpoint_events::version"]
        [::std::mem::offset_of!(pw_endpoint_events, version) - 0usize];
    ["Offset of field: pw_endpoint_events::info"]
        [::std::mem::offset_of!(pw_endpoint_events, info) - 8usize];
    ["Offset of field: pw_endpoint_events::param"]
        [::std::mem::offset_of!(pw_endpoint_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_endpoint_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate endpoint parameters\n\n Start enumeration of endpoint parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the endpoint\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Create a link\n\n This requires X permissions."]
    pub create_link: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_methods"][::std::mem::size_of::<pw_endpoint_methods>() - 48usize];
    ["Alignment of pw_endpoint_methods"][::std::mem::align_of::<pw_endpoint_methods>() - 8usize];
    ["Offset of field: pw_endpoint_methods::version"]
        [::std::mem::offset_of!(pw_endpoint_methods, version) - 0usize];
    ["Offset of field: pw_endpoint_methods::add_listener"]
        [::std::mem::offset_of!(pw_endpoint_methods, add_listener) - 8usize];
    ["Offset of field: pw_endpoint_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_endpoint_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_endpoint_methods::enum_params"]
        [::std::mem::offset_of!(pw_endpoint_methods, enum_params) - 24usize];
    ["Offset of field: pw_endpoint_methods::set_param"]
        [::std::mem::offset_of!(pw_endpoint_methods, set_param) - 32usize];
    ["Offset of field: pw_endpoint_methods::create_link"]
        [::std::mem::offset_of!(pw_endpoint_methods, create_link) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify endpoint stream info\n\n \\param info info about the endpoint stream"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            info: *const pw_endpoint_stream_info,
        ),
    >,
    #[doc = " Notify a endpoint stream param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_stream_events"]
        [::std::mem::size_of::<pw_endpoint_stream_events>() - 24usize];
    ["Alignment of pw_endpoint_stream_events"]
        [::std::mem::align_of::<pw_endpoint_stream_events>() - 8usize];
    ["Offset of field: pw_endpoint_stream_events::version"]
        [::std::mem::offset_of!(pw_endpoint_stream_events, version) - 0usize];
    ["Offset of field: pw_endpoint_stream_events::info"]
        [::std::mem::offset_of!(pw_endpoint_stream_events, info) - 8usize];
    ["Offset of field: pw_endpoint_stream_events::param"]
        [::std::mem::offset_of!(pw_endpoint_stream_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_stream_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_endpoint_stream_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate stream parameters\n\n Start enumeration of stream parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the stream\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_stream_methods"]
        [::std::mem::size_of::<pw_endpoint_stream_methods>() - 40usize];
    ["Alignment of pw_endpoint_stream_methods"]
        [::std::mem::align_of::<pw_endpoint_stream_methods>() - 8usize];
    ["Offset of field: pw_endpoint_stream_methods::version"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, version) - 0usize];
    ["Offset of field: pw_endpoint_stream_methods::add_listener"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, add_listener) - 8usize];
    ["Offset of field: pw_endpoint_stream_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_endpoint_stream_methods::enum_params"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, enum_params) - 24usize];
    ["Offset of field: pw_endpoint_stream_methods::set_param"]
        [::std::mem::offset_of!(pw_endpoint_stream_methods, set_param) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Notify endpoint link info\n\n \\param info info about the endpoint link"]
    pub info: ::std::option::Option<
        unsafe extern "C" fn(data: *mut ::std::os::raw::c_void, info: *const pw_endpoint_link_info),
    >,
    #[doc = " Notify a endpoint link param\n\n Event emitted as a result of the enum_params method.\n\n \\param seq the sequence number of the request\n \\param id the param id\n \\param index the param index\n \\param next the param index of the next param\n \\param param the parameter"]
    pub param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            index: u32,
            next: u32,
            param: *const spa_pod,
        ),
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_link_events"][::std::mem::size_of::<pw_endpoint_link_events>() - 24usize];
    ["Alignment of pw_endpoint_link_events"]
        [::std::mem::align_of::<pw_endpoint_link_events>() - 8usize];
    ["Offset of field: pw_endpoint_link_events::version"]
        [::std::mem::offset_of!(pw_endpoint_link_events, version) - 0usize];
    ["Offset of field: pw_endpoint_link_events::info"]
        [::std::mem::offset_of!(pw_endpoint_link_events, info) - 8usize];
    ["Offset of field: pw_endpoint_link_events::param"]
        [::std::mem::offset_of!(pw_endpoint_link_events, param) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_endpoint_link_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_endpoint_link_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Subscribe to parameter changes\n\n Automatically emit param events for the given ids when\n they are changed.\n\n \\param ids an array of param ids\n \\param n_ids the number of ids in \\a ids\n\n This requires X permissions."]
    pub subscribe_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            ids: *mut u32,
            n_ids: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Enumerate link parameters\n\n Start enumeration of link parameters. For each param, a\n param event will be emitted.\n\n \\param seq a sequence number returned in the reply\n \\param id the parameter id to enumerate\n \\param start the start index or 0 for the first param\n \\param num the maximum number of params to retrieve\n \\param filter a param filter or NULL\n\n This requires X permissions."]
    pub enum_params: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            seq: ::std::os::raw::c_int,
            id: u32,
            start: u32,
            num: u32,
            filter: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on the link\n\n \\param id the parameter id to set\n \\param flags extra parameter flags\n \\param param the parameter to set\n\n This requires X and W permissions."]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Request a state on the link.\n\n This requires X and W permissions."]
    pub request_state: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            state: pw_endpoint_link_state,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_endpoint_link_methods"]
        [::std::mem::size_of::<pw_endpoint_link_methods>() - 48usize];
    ["Alignment of pw_endpoint_link_methods"]
        [::std::mem::align_of::<pw_endpoint_link_methods>() - 8usize];
    ["Offset of field: pw_endpoint_link_methods::version"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, version) - 0usize];
    ["Offset of field: pw_endpoint_link_methods::add_listener"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, add_listener) - 8usize];
    ["Offset of field: pw_endpoint_link_methods::subscribe_params"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, subscribe_params) - 16usize];
    ["Offset of field: pw_endpoint_link_methods::enum_params"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, enum_params) - 24usize];
    ["Offset of field: pw_endpoint_link_methods::set_param"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, set_param) - 32usize];
    ["Offset of field: pw_endpoint_link_methods::request_state"]
        [::std::mem::offset_of!(pw_endpoint_link_methods, request_state) - 40usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_endpoint {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_endpoint_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Sets the session id of the \\a endpoint.\n\n On endpoints that are not session masters, this method notifies\n the implementation that it has been associated with a session.\n The implementation is obliged to set this id in the\n #struct pw_endpoint_info \\a session_id field.\n\n \\param endpoint a #pw_endpoint\n \\param id the session id associated with this endpoint\n\n \\return 0 on success\n         -EINVAL when the session id has already been set\n         -ENOTSUP when the endpoint is a session master"]
    pub set_session_id: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            session_id: u32,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set the configurable parameter in \\a endpoint.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param endpoint a #struct pw_endpoint\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when \\a endpoint is NULL\n         -ENOTSUP when there are no parameters implemented on \\a endpoint\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a stream_id of \\a endpoint.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread.\n\n \\param endpoint a #struct pw_endpoint\n \\param stream_id the stream to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a #struct spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can\n                be found by doing stream_enum_params.\n         -EINVAL when \\a endpoint is NULL or invalid arguments are given\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub stream_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            stream_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_link: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            props: *const spa_dict,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_endpoint_events"]
        [::std::mem::size_of::<pw_client_endpoint_events>() - 40usize];
    ["Alignment of pw_client_endpoint_events"]
        [::std::mem::align_of::<pw_client_endpoint_events>() - 8usize];
    ["Offset of field: pw_client_endpoint_events::version"]
        [::std::mem::offset_of!(pw_client_endpoint_events, version) - 0usize];
    ["Offset of field: pw_client_endpoint_events::set_session_id"]
        [::std::mem::offset_of!(pw_client_endpoint_events, set_session_id) - 8usize];
    ["Offset of field: pw_client_endpoint_events::set_param"]
        [::std::mem::offset_of!(pw_client_endpoint_events, set_param) - 16usize];
    ["Offset of field: pw_client_endpoint_events::stream_set_param"]
        [::std::mem::offset_of!(pw_client_endpoint_events, stream_set_param) - 24usize];
    ["Offset of field: pw_client_endpoint_events::create_link"]
        [::std::mem::offset_of!(pw_client_endpoint_events, create_link) - 32usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_endpoint_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_endpoint_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update endpoint information"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_endpoint_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update stream information"]
    pub stream_update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            stream_id: u32,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_endpoint_stream_info,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_endpoint_methods"]
        [::std::mem::size_of::<pw_client_endpoint_methods>() - 32usize];
    ["Alignment of pw_client_endpoint_methods"]
        [::std::mem::align_of::<pw_client_endpoint_methods>() - 8usize];
    ["Offset of field: pw_client_endpoint_methods::version"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, version) - 0usize];
    ["Offset of field: pw_client_endpoint_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_endpoint_methods::update"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, update) - 16usize];
    ["Offset of field: pw_client_endpoint_methods::stream_update"]
        [::std::mem::offset_of!(pw_client_endpoint_methods, stream_update) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_session {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_session_events {
    #[doc = "< version of this structure"]
    pub version: u32,
    #[doc = " Set the configurable parameter in \\a session.\n\n Usually, \\a param will be obtained from enum_params and then\n modified but it is also possible to set another spa_pod\n as long as its keys and types match a supported object.\n\n Objects with property keys that are not known are ignored.\n\n This function must be called from the main thread.\n\n \\param session a #struct pw_session\n \\param id the parameter id to configure\n \\param flags additional flags\n \\param param the parameter to configure\n\n \\return 0 on success\n         -EINVAL when \\a session is NULL\n         -ENOTSUP when there are no parameters implemented on \\a session\n         -ENOENT the parameter is unknown"]
    pub set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Set a parameter on \\a link_id of \\a session.\n\n When \\a param is NULL, the parameter will be unset.\n\n This function must be called from the main thread.\n\n \\param session a #struct pw_session\n \\param link_id the link to configure\n \\param id the parameter id to set\n \\param flags optional flags\n \\param param a #struct spa_pod with the parameter to set\n \\return 0 on success\n         1 on success, the value of \\a param might have been\n                changed depending on \\a flags and the final value can\n                be found by doing link_enum_params.\n         -EINVAL when \\a session is NULL or invalid arguments are given\n         -ESRCH when the type or size of a property is not correct.\n         -ENOENT when the param id is not found"]
    pub link_set_param: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            link_id: u32,
            id: u32,
            flags: u32,
            param: *const spa_pod,
        ) -> ::std::os::raw::c_int,
    >,
    pub link_request_state: ::std::option::Option<
        unsafe extern "C" fn(
            data: *mut ::std::os::raw::c_void,
            link_id: u32,
            state: u32,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_session_events"]
        [::std::mem::size_of::<pw_client_session_events>() - 32usize];
    ["Alignment of pw_client_session_events"]
        [::std::mem::align_of::<pw_client_session_events>() - 8usize];
    ["Offset of field: pw_client_session_events::version"]
        [::std::mem::offset_of!(pw_client_session_events, version) - 0usize];
    ["Offset of field: pw_client_session_events::set_param"]
        [::std::mem::offset_of!(pw_client_session_events, set_param) - 8usize];
    ["Offset of field: pw_client_session_events::link_set_param"]
        [::std::mem::offset_of!(pw_client_session_events, link_set_param) - 16usize];
    ["Offset of field: pw_client_session_events::link_request_state"]
        [::std::mem::offset_of!(pw_client_session_events, link_request_state) - 24usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pw_client_session_methods {
    #[doc = "< version of this structure"]
    pub version: u32,
    pub add_listener: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            listener: *mut spa_hook,
            events: *const pw_client_session_events,
            data: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update session information"]
    pub update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_session_info,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Update link information"]
    pub link_update: ::std::option::Option<
        unsafe extern "C" fn(
            object: *mut ::std::os::raw::c_void,
            link_id: u32,
            change_mask: u32,
            n_params: u32,
            params: *mut *const spa_pod,
            info: *const pw_endpoint_link_info,
        ) -> ::std::os::raw::c_int,
    >,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of pw_client_session_methods"]
        [::std::mem::size_of::<pw_client_session_methods>() - 32usize];
    ["Alignment of pw_client_session_methods"]
        [::std::mem::align_of::<pw_client_session_methods>() - 8usize];
    ["Offset of field: pw_client_session_methods::version"]
        [::std::mem::offset_of!(pw_client_session_methods, version) - 0usize];
    ["Offset of field: pw_client_session_methods::add_listener"]
        [::std::mem::offset_of!(pw_client_session_methods, add_listener) - 8usize];
    ["Offset of field: pw_client_session_methods::update"]
        [::std::mem::offset_of!(pw_client_session_methods, update) - 16usize];
    ["Offset of field: pw_client_session_methods::link_update"]
        [::std::mem::offset_of!(pw_client_session_methods, link_update) - 24usize];
};
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __va_list_tag"][::std::mem::size_of::<__va_list_tag>() - 24usize];
    ["Alignment of __va_list_tag"][::std::mem::align_of::<__va_list_tag>() - 8usize];
    ["Offset of field: __va_list_tag::gp_offset"]
        [::std::mem::offset_of!(__va_list_tag, gp_offset) - 0usize];
    ["Offset of field: __va_list_tag::fp_offset"]
        [::std::mem::offset_of!(__va_list_tag, fp_offset) - 4usize];
    ["Offset of field: __va_list_tag::overflow_arg_area"]
        [::std::mem::offset_of!(__va_list_tag, overflow_arg_area) - 8usize];
    ["Offset of field: __va_list_tag::reg_save_area"]
        [::std::mem::offset_of!(__va_list_tag, reg_save_area) - 16usize];
};
